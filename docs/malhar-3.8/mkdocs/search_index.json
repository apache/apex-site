{
    "docs": [
        {
            "location": "/",
            "text": "Apache Apex Malhar\n\n\nApache Apex Malhar is an open source operator and codec library that can be used with the \nApache Apex\n platform to build real-time streaming applications.  Enabling users to extract value quickly, Malhar operators help get data in, analyze it in real-time, and get data out of Hadoop.  In addition to the operators, the library contains a number of example applications, demonstrating operator features and capabilities.\n\n\n\n\nCapabilities common across Malhar operators\n\n\nFor most streaming platforms, connectors are afterthoughts and often end up being simple \u2018bolt-ons\u2019 to the platform. As a result they often cause performance issues or data loss when put through failure scenarios and scalability requirements. Malhar operators do not face these issues as they were designed to be integral parts of Apex. Hence, they have following core streaming runtime capabilities\n\n\n\n\nFault tolerance\n \u2013 Malhar operators where applicable have fault tolerance built in. They use the checkpoint capability provided by the framework to ensure that there is no data loss under ANY failure scenario.\n\n\nProcessing guarantees\n \u2013 Malhar operators where applicable provide out of the box support for ALL three processing guarantees \u2013 exactly once, at-least once, and at-most once WITHOUT requiring the user to write any additional code.  Some operators, like MQTT operator, deal with source systems that can not track processed data and hence need the operators to keep track of the data.  Malhar has support for a generic operator that uses alternate storage like HDFS to facilitate this.  Finally for databases that support transactions or support any sort of atomic batch operations Malhar operators can do exactly once down to the tuple level.\n\n\nDynamic updates\n \u2013 Based on changing business conditions you often have to tweak several parameters used by the operators in your streaming application without incurring any application downtime. You can also change properties of a Malhar operator at runtime without having to bring down the application.\n\n\nEase of extensibility\n \u2013 Malhar operators are based on templates that are easy to extend.\n\n\nPartitioning support\n \u2013 In streaming applications the input data stream often needs to be partitioned based on the contents of the stream. Also for operators that ingest data from external systems partitioning needs to be done based on the capabilities of the external system.  For example with Kafka, the operator can automatically scale up or down based on the changes in the number of Kafka partitions.\n\n\n\n\nOperator Library Overview\n\n\nInput/output connectors\n\n\nBelow is a summary of the various sub categories of input and output operators. Input operators also have a corresponding output operator\n\n\n\n\nFile Systems\n \u2013 Most streaming analytics use cases require the data to be stored in HDFS or perhaps S3 if the application is running in AWS.  Users often need to re-run their streaming analytical applications against historical data or consume data from upstream processes that are perhaps writing to some NFS share.  Apex supports input & output operators for HDFS, S3, NFS & Local Files.  There are also File Splitter and Block Reader operators, which can accelecate processing of large files by splitting and paralellizing the work across non-overlapping sets of file blocks.\n\n\nRelational Databases\n \u2013 Most stream processing use cases require some reference data lookups to enrich, tag or filter streaming data. There is also a need to save results of the streaming analytical computation to a database so an operational dashboard can see them. Apex supports a JDBC operator so you can read/write data from any JDBC compliant RDBMS like Oracle, MySQL, Sqlite, etc.\n\n\nNoSQL Databases\n \u2013 NoSQL key-value pair databases like Cassandra & HBase are a common part of streaming analytics application architectures to lookup reference data or store results.  Malhar has operators for HBase, Cassandra, Accumulo, Aerospike, MongoDB, and CouchDB.\n\n\nMessaging Systems\n \u2013 Kafka, JMS, and similar systems are the workhorses of messaging infrastructure in most enterprises.  Malhar has a robust, industry-tested set of operators to read and write Kafka, JMS, ZeroMQ, and RabbitMQ messages.\n\n\nNotification Systems\n \u2013 Malhar includes an operator for sending notifications via SMTP.\n\n\nIn-memory Databases & Caching platforms\n - Some streaming use cases need instantaneous access to shared state across the application. Caching platforms and in-memory databases serve this purpose really well. To support these use cases, Malhar has operators for memcached and Redis.\n\n\nSocial Media\n - Malhar includes an operator to connect to the popular Twitter stream fire hose.\n\n\nProtocols\n - Malhar provides connectors that can communicate in HTTP, RSS, Socket, WebSocket, FTP, and MQTT.\n\n\n\n\nParsers\n\n\nThere are many industry vertical specific data formats that a streaming application developer might need to parse. Often there are existing parsers available for these that can be directly plugged into an Apache Apex application. For example in the Telco space, a Java based CDR parser can be directly plugged into Apache Apex operator. To further simplify development experience, Malhar also provides some operators for parsing common formats like XML (DOM & SAX), JSON (flat map converter), Apache log files, syslog, etc.\n\n\nStream manipulation\n\n\nStreaming data inevitably needs processing to clean, filter, tag, summarize, etc. The goal of Malhar is to enable the application developer to focus on WHAT needs to be done to the stream to get it in the right format and not worry about the HOW.  Malhar has several operators to perform the common stream manipulation actions like \u2013 GroupBy, Join, Distinct/Unique, Limit, OrderBy, Split, Sample, Inner join, Outer join, Select, Update etc.\n\n\nCompute\n\n\nOne of the most important promises of a streaming analytics platform like Apache Apex is the ability to do analytics in real-time. However delivering on the promise becomes really difficult when the platform does not provide out of the box operators to support variety of common compute functions as the user then has to worry about making these scalable, fault tolerant, stateful, etc.  Malhar takes this responsibility away from the application developer by providing a variety of out of the box computational operators.\n\n\nBelow is just a snapshot of the compute operators available in Malhar\n\n\n\n\nStatistics and math - Various mathematical and statistical computations over application defined time windows.\n\n\nFiltering and pattern matching\n\n\nSorting, maps, frequency, TopN, BottomN\n\n\nRandom data generators\n\n\n\n\nLanguages Support\n\n\nMigrating to a new platform often requires re-use of the existing code that would be difficult or time-consuming to re-write.  With this in mind, Malhar supports invocation of code written in other languages by wrapping them in one of the library operators, and allows execution of software written in:\n\n\n\n\nJavaScript\n\n\nPython\n\n\nR\n\n\nRuby",
            "title": "Apache Apex Malhar"
        },
        {
            "location": "/#apache-apex-malhar",
            "text": "Apache Apex Malhar is an open source operator and codec library that can be used with the  Apache Apex  platform to build real-time streaming applications.  Enabling users to extract value quickly, Malhar operators help get data in, analyze it in real-time, and get data out of Hadoop.  In addition to the operators, the library contains a number of example applications, demonstrating operator features and capabilities.",
            "title": "Apache Apex Malhar"
        },
        {
            "location": "/#capabilities-common-across-malhar-operators",
            "text": "For most streaming platforms, connectors are afterthoughts and often end up being simple \u2018bolt-ons\u2019 to the platform. As a result they often cause performance issues or data loss when put through failure scenarios and scalability requirements. Malhar operators do not face these issues as they were designed to be integral parts of Apex. Hence, they have following core streaming runtime capabilities   Fault tolerance  \u2013 Malhar operators where applicable have fault tolerance built in. They use the checkpoint capability provided by the framework to ensure that there is no data loss under ANY failure scenario.  Processing guarantees  \u2013 Malhar operators where applicable provide out of the box support for ALL three processing guarantees \u2013 exactly once, at-least once, and at-most once WITHOUT requiring the user to write any additional code.  Some operators, like MQTT operator, deal with source systems that can not track processed data and hence need the operators to keep track of the data.  Malhar has support for a generic operator that uses alternate storage like HDFS to facilitate this.  Finally for databases that support transactions or support any sort of atomic batch operations Malhar operators can do exactly once down to the tuple level.  Dynamic updates  \u2013 Based on changing business conditions you often have to tweak several parameters used by the operators in your streaming application without incurring any application downtime. You can also change properties of a Malhar operator at runtime without having to bring down the application.  Ease of extensibility  \u2013 Malhar operators are based on templates that are easy to extend.  Partitioning support  \u2013 In streaming applications the input data stream often needs to be partitioned based on the contents of the stream. Also for operators that ingest data from external systems partitioning needs to be done based on the capabilities of the external system.  For example with Kafka, the operator can automatically scale up or down based on the changes in the number of Kafka partitions.",
            "title": "Capabilities common across Malhar operators"
        },
        {
            "location": "/#operator-library-overview",
            "text": "",
            "title": "Operator Library Overview"
        },
        {
            "location": "/#inputoutput-connectors",
            "text": "Below is a summary of the various sub categories of input and output operators. Input operators also have a corresponding output operator   File Systems  \u2013 Most streaming analytics use cases require the data to be stored in HDFS or perhaps S3 if the application is running in AWS.  Users often need to re-run their streaming analytical applications against historical data or consume data from upstream processes that are perhaps writing to some NFS share.  Apex supports input & output operators for HDFS, S3, NFS & Local Files.  There are also File Splitter and Block Reader operators, which can accelecate processing of large files by splitting and paralellizing the work across non-overlapping sets of file blocks.  Relational Databases  \u2013 Most stream processing use cases require some reference data lookups to enrich, tag or filter streaming data. There is also a need to save results of the streaming analytical computation to a database so an operational dashboard can see them. Apex supports a JDBC operator so you can read/write data from any JDBC compliant RDBMS like Oracle, MySQL, Sqlite, etc.  NoSQL Databases  \u2013 NoSQL key-value pair databases like Cassandra & HBase are a common part of streaming analytics application architectures to lookup reference data or store results.  Malhar has operators for HBase, Cassandra, Accumulo, Aerospike, MongoDB, and CouchDB.  Messaging Systems  \u2013 Kafka, JMS, and similar systems are the workhorses of messaging infrastructure in most enterprises.  Malhar has a robust, industry-tested set of operators to read and write Kafka, JMS, ZeroMQ, and RabbitMQ messages.  Notification Systems  \u2013 Malhar includes an operator for sending notifications via SMTP.  In-memory Databases & Caching platforms  - Some streaming use cases need instantaneous access to shared state across the application. Caching platforms and in-memory databases serve this purpose really well. To support these use cases, Malhar has operators for memcached and Redis.  Social Media  - Malhar includes an operator to connect to the popular Twitter stream fire hose.  Protocols  - Malhar provides connectors that can communicate in HTTP, RSS, Socket, WebSocket, FTP, and MQTT.",
            "title": "Input/output connectors"
        },
        {
            "location": "/#parsers",
            "text": "There are many industry vertical specific data formats that a streaming application developer might need to parse. Often there are existing parsers available for these that can be directly plugged into an Apache Apex application. For example in the Telco space, a Java based CDR parser can be directly plugged into Apache Apex operator. To further simplify development experience, Malhar also provides some operators for parsing common formats like XML (DOM & SAX), JSON (flat map converter), Apache log files, syslog, etc.",
            "title": "Parsers"
        },
        {
            "location": "/#stream-manipulation",
            "text": "Streaming data inevitably needs processing to clean, filter, tag, summarize, etc. The goal of Malhar is to enable the application developer to focus on WHAT needs to be done to the stream to get it in the right format and not worry about the HOW.  Malhar has several operators to perform the common stream manipulation actions like \u2013 GroupBy, Join, Distinct/Unique, Limit, OrderBy, Split, Sample, Inner join, Outer join, Select, Update etc.",
            "title": "Stream manipulation"
        },
        {
            "location": "/#compute",
            "text": "One of the most important promises of a streaming analytics platform like Apache Apex is the ability to do analytics in real-time. However delivering on the promise becomes really difficult when the platform does not provide out of the box operators to support variety of common compute functions as the user then has to worry about making these scalable, fault tolerant, stateful, etc.  Malhar takes this responsibility away from the application developer by providing a variety of out of the box computational operators.  Below is just a snapshot of the compute operators available in Malhar   Statistics and math - Various mathematical and statistical computations over application defined time windows.  Filtering and pattern matching  Sorting, maps, frequency, TopN, BottomN  Random data generators",
            "title": "Compute"
        },
        {
            "location": "/#languages-support",
            "text": "Migrating to a new platform often requires re-use of the existing code that would be difficult or time-consuming to re-write.  With this in mind, Malhar supports invocation of code written in other languages by wrapping them in one of the library operators, and allows execution of software written in:   JavaScript  Python  R  Ruby",
            "title": "Languages Support"
        },
        {
            "location": "/apis/calcite/",
            "text": "Apache Apex is a unified stream and batch processing engine that enables application developers to process data at very high throughput with low latency. Although the different types of data have different processing needs, SQL remains a popular and a generic way for processing data. To ensure that existing ETL developers and developers who are well versed with Database applications adopt stream processing application development with ease, integration of SQL with Apex was needed. Being a popular Apache project, Apache Calcite was chosen for this purpose and its integration with Apex is described below.\n\n\nApex-Calcite Integration\n\n\nApache Calcite is a highly customizable engine for parsing and planning queries on relational data from various data sources; it provides storage independent optimization of queries and ways to integrate them into other frameworks which would like to take advantage and expose SQL capability to their users. For details, please read at \nApache Calcite Website\n. \n\n\nParticularly in SQL on Apex, Calcite processes a query and then creates relational algebra to create processing pipelines. These relational algebra processing pipelines are converted to a DAG with a set of operators to perform business logic on streaming data.\n\n\n\n\nAbove figure explains how SQL query gets converted to Apex DAG.\n\n\n\n\nUser specified query is processed by Calcite Query planner; this involves parsing and optimizing the query to generate Relation Expression Tree. \n\n\nThis Relation Expression Tree is received by Apache Apex\u2019s SQL module to finally convert to an Apex DAG having series of operators.\n\n\n\n\nOne peculiarity of Calcite queries is that the data source and destination need not be RDBMS systems; in the above example, \nFile\n refers to a file in the filesystem and \nKafka\n to a Kafka message broker. Calcite allows Apex to register table sources and destinations as anything which can return a row type results. So a \u201cscan\u201d relational expression gets converted to \u201cKafkaInputOperator + ParseOperator\u201d, a result of which is series of POJOs reflecting a Row Type. Similarly, the \u201cinsert\u201d Relational Expression translated to \u201cFormatOperator + FileOutputOperator\u201d.\n\n\nFor more details about the integration, click \nhere\n.\n\n\nSQL APIs for Apache Apex\n\n\nListed below are the Java APIs which can be used by SQL/Apex users to create a DAG in the implementation of the \npopulateDAG\n method of the \nStreamingApplication\n interface.\n\n\n\n\n\n\n\n\nAPI\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSQLExecEnvironment.getEnvironment()\n\n\nCreates a new SQL execution environment\n\n\n\n\n\n\nSQLExecEnvironment.registerTable(tableName, endpointInstance)\n\n\nRegisters a new abstract table with existing environment. \nendpointInstance\n is an object of type \nEndpoint\n which defines a table.\n\n\n\n\n\n\nSQLExecEnvironment.registerFunction(sqlFunctionName, holderClass, staticFunctionName)\n\n\nRegisters a new User Defined Scalar function\n\n\n\n\n\n\nSQLExecEnvironment.executeSQL(dag, sqlStatement)\n\n\nCreates a DAG for a particular SQL statement\n\n\n\n\n\n\n\n\nUsage of above APIs is described in detail in following sections.\n\n\nExample 1: Pure Style SQL Application\n\n\nWith Apache Calcite Integration, you can use SQL queries across different data sources and provide UDFs (User Defined Functions) as per your business logic. This example will use a Kafka topic as the source and a HDFS file as the destination.\nFollowing application code will be used to explain APIs. Actual source code can be found \nhere\n.\n\n\n  public class PureStyleSQLApplication implements StreamingApplication\n  {\n    @Override\n    public void populateDAG(DAG dag, Configuration conf)\n    {\n       // Create new SQLExecEnvironment\n       SQLExecEnvironment sqlEnv = SQLExecEnvironment.getEnvironment();\n\n      // This is a string that defines a schema and is discussed in more detail in \"Registering tables with SQLExecEnvironment\" section \n      String inputSchemaString = \"...\";\n\n      // similar to inputSchemaString, we also need to define outputSchemaString\n      String outputSchemaString = \"...\";\n\n       // Register KafkaEnpoint as \"ORDERS\" table with kafka topic and data format as CSV\n       sqlEnv = sqlEnv.registerTable( \n                                    \"ORDERS\", \n                                    new KafkaEndpoint(\"localhost:9090\", \n                                                      \"inputTopic\", \n                                                      new CSVMessageFormat(inputSchemaString))\n                                  );\n\n       // Register FileEndpoint as \"SALES\" table with file path and data format as CSV\n       sqlEnv = sqlEnv.registerTable( \n                                    \"SALES\", \n                                    new FileEndpoint(\"/tmp/output\", \n                                                     \"out.file\", \n                                                     new CSVMessageFormat(outputSchemaString))\n                                  );\n\n       // Register scalar SQL UDF \n       sqlEnv = sqlEnv.registerFunction(\"APEXCONCAT\", PureStyleSQLApplication.class, \"apex_concat_str\");\n\n       // Converting SQL statement to DAG \n       String sql = \"INSERT INTO SALES \n                       SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n                       FROM ORDERS \n                       WHERE ID > 3 AND PRODUCT LIKE 'paint%'\";\n       sqlEnv.executeSQL(dag, sql);\n    }// populateDAG finished\n\n    public static String apex_concat_str(String s1, String s2)\n    {\n        return s1 + s2;\n    } \n  }\n\n\n\n\nConstructing SQLExecEnvironment\n\n\nThe class \nSQLExecEnvironment\n provides a starting point and a simple way to define metadata needed for running a SQL statement; a new instance of this class is returned by the \ngetEnvironment\n static method.  \n\n\n  // Creates SQLExecEnvironment instance by using static method getEnvironment\n  SQLExecEnvironment sqlEnv = SQLExecEnvironment.getEnvironment();\n\n\n\n\nRegistering tables with SQLExecEnvironment\n\n\nNext, we need to register tables which can be used in a query. For this purpose, we can use \nregisterTable\n method from SQLExecEnvironment.\n\n\n  // Register KafkaEnpoint as \"ORDERS\" table with kafka topic and data format as CSV\n  sqlEnv = sqlEnv.registerTable( \n                              \"ORDERS\", \n                              new KafkaEndpoint(\"localhost:9090\", \n                                                \"inputTopic\", \n                                                new CSVMessageFormat(inputSchemaString))\n                            );\n\n  // Register FileEndpoint as \"SALES\" table with file path and data format as CSV\n  sqlEnv = sqlEnv.registerTable( \n                              \"SALES\", \n                              new FileEndpoint(\"/tmp/output\", \n                                               \"out.file\", \n                                               new CSVMessageFormat(inputSchemaString))\n                            );\n\n\n\n\n\"registerTable\"\n method takes the name of the table and an instance of endpoint as parameters. Endpoint signifies data storage mechanism and type of source/destination for the data. These endpoints require different types of configurations and possibly data formats. The data format is defined using an implementation of the \nMessageFormat\n interface; the \nCSVMessageFormat\n implementation can be configured with a schema string as follows:\n\n\n{\n  \"separator\": \",\",\n  \"quoteChar\": \"\\\"\",\n  \"fields\": [\n    {\n      \"name\": \"RowTime\",\n      \"type\": \"Date\",\n      \"constraints\": {\n        \"format\": \"dd/MM/yyyy hh:mm:ss Z\"\n      }\n    },\n    {\n      \"name\": \"id\",\n      \"type\": \"Integer\"\n    },\n    {\n      \"name\": \"Product\",\n      \"type\": \"String\"\n    },\n    {\n      \"name\": \"units\",\n      \"type\": \"Integer\"\n    }\n  ]\n}\n\n\n\n\nThe schema string is a JSON string defining a separator character, quote character for fields with String type and a list of fields where, for each field, its name, type and any additional constraints are specified.\n\n\nFollowing data endpoints are supported: \n\n\n\n\nKafkaEnpoint\n\n: To define a Kafka Endpoint we need to specify the Kafka broker (as host:port), topic name and MessageFormat as seen in line 1 in the code above.\n\n\nFileEndpoint\n\n: It needs to be configured with the filesystem path, file name and MessageFormat as in line 2 in the code above. \n\n\nStreamEndpoint\n \n: This allows us to connect existing operator output or input ports to the SQL query as a data source or sink respectively. StreamEndpoint needs immediate downstream operator's input port or immediate upstream operator's output port and the field mapping for CSV data or POJO class. This will be explained in detail in next \nexample\n.\n\n\n\n\nUsing User Defined Functions (UDF) in a SQL query\n\n\nWe can use our own scalar UDF, implemented in Java, in a SQL statement for data manipulation but first, we need to register the function with the execution environment by using the \nregisterFunction\n method.\n\n\n  sqlEnv = sqlEnv.registerFunction(\"APEXCONCAT\", PureStyleSQLApplication.class, \"apex_concat_str\");\n\n\n\n\nIn above code, \nregisterFunction\n takes the UDF name to be used in SQL, JAVA class which implements the static method and name of that method as parameters. \nThe static method \napex_concat_str\n takes two String objects as input parameters from the SQL query.\n\n\n  public static String apex_concat_str(String s1, String s2)\n  {\n    return s1 + s2;\n  }\n\n\n\n\nThe scalar UDF \"APEXCONCAT\" that was registered above can be used in SQL as described below. FLOOR and SUBSTRING are standard SQL scalar functions supported by Apache Calcite.\n\n\nINSERT INTO SALES \n       SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n       FROM ORDERS \n       WHERE ID > 3 AND PRODUCT LIKE 'paint%'\n\n\n\n\nTo read about all functions and operators supported by Apache Calcite, click \nhere\n.\n\n\nExecuting SQL Query\n\n\nFinally to execute the query we need to use \nexecuteSQL\n function with a DAG and SQL statement as parameters.\n\n\n  // Converting SQL statement to DAG \n  String sql = \"INSERT INTO SALES \n                SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n                FROM ORDERS \n                WHERE ID > 3 AND PRODUCT LIKE 'paint%'\";\n  sqlEnv.executeSQL(dag, sql);\n\n\n\n\nWhen executeSQL method is called, the query goes through various phases like conversion to relational algebra, optimization and planning in Calcite to generate Relation Expression Tree. \nThe generated Relation Expression Tree is consumed by Apex SQL and converted to a DAG using operators available in Apache Malhar. In the above example, the ORDERS and SALES tables will be converted to the operators KafkaInputOperator and FileOutputFormatter respectively, paired with the CSVParser formatter in both cases.\n\n\nA \nWHERE\n clause is used in this query; it defines the desired filter for rows and is converted to a \nFilterTransformOperator\n in the DAG. Similarly, the projection defining desired columns is converted into another instance of the \nFilterTransformOperator\n. The DAG created for this application will look like this:\n\n\n\n\n\n\nExample 2: Fusion Style SQL Application\n\n\nAs described in Pure Style SQL application, we can use different data sources as source and sink while developing Apex Applications with Calcite. This example will describe how we can develop Apex application with Apex stream as abstract table for SQL query. Actual source code can be found \nhere\n.\n\n\n  // Define Kafka Input Operator for reading data from Kafka\n  KafkaSinglePortInputOperator kafkaInput = dag.addOperator(\"KafkaInput\", \n                                                           KafkaSinglePortInputOperator.class);\n\n  kafkaInput.setInitialOffset(\"EARLIEST\");\n\n  // Add CSVParser\n  CsvParser csvParser = dag.addOperator(\"CSVParser\", CsvParser.class);\n  dag.addStream(\"KafkaToCSV\", kafkaInput.outputPort, csvParser.in);\n\n\n\n\nOnce we define DAG with KafkaInputOperator and CSVParser, it can parse data from Kafka topic. Upto this point, this is a regular Apex application without SQL. After this, we can register the output of CSVParser as a table using \nStreamEndpoint\n to run a SQL statement. This way we can develop applications in fusion style where the DAG is part SQL and part regular Apex DAG.\n\n\nThe following code will describe how we can define StreamEndpoint. \n\n\n  SQLExecEnvironment sqlEnv = sqlEnv.getEnvironment();\n  Map<String, Class> fieldMapping = ImmutableMap.<String, Class>of(\"RowTime\", Date.class,\n                                                                 \"id\", Integer.class,\n                                                                 \"Product\", String.class,\n                                                                 \"units\", Integer.class);\n  sqlEnv = sqlEnv.registerTable(\"FROMCSV\", new StreamEndpoint(csvParser.out, fieldMapping));\n\n\n\n\nTo read existing data stream, we need to register it as a table with SQL execution environment with the name of the table and StreamEndpoint. StreamEndpoint can serve as input table or output table in SQL. For input table configuration we need to initialise StreamEndpoint with immediate upstream operator's output port and fieldMapping or POJO class for input tuple(as shown above). For output table configuration, we need to initialise StreamEndpoint with immediate downstream operator's input port and fieldMapping or POJO class for output tuple. Once we register StreamEndpoint as a table with a name in SQL Execution Environment, it can be used as a table in SQL statement similar to other endpoints.\n\n\nWhen executeSQL method is called, the specified SQL is converted to DAG as described in the previous section. Both examples read CSV data from Kafka. But in the pure style SQL example the \nKafkaInputOperator\n and \nCSVParser\n in the DAG are created implicitly by the use of the KafkaEndpoint usage while in the fusion style example, they are explicitly defined as part of the DAG which is then extended with other operators as shown in the image below. \n\n\n\n\nFor all Apex-Calcite integration examples, click \nhere\n. \n\n\nOngoing efforts\n\n\nApache Apex-Calcite integration provides support for basic queries and efforts are underway to extend support for aggregations, sorting and other features using Tumbling, Hopping and Session Windows.\nSupport for JSON, XML and JDBC endpoint are also planned. The goal of this integration is to make developing a streaming application using SQL easy so that SQL Developers don't have to write any java code at all.",
            "title": "SQL"
        },
        {
            "location": "/apis/calcite/#apex-calcite-integration",
            "text": "Apache Calcite is a highly customizable engine for parsing and planning queries on relational data from various data sources; it provides storage independent optimization of queries and ways to integrate them into other frameworks which would like to take advantage and expose SQL capability to their users. For details, please read at  Apache Calcite Website .   Particularly in SQL on Apex, Calcite processes a query and then creates relational algebra to create processing pipelines. These relational algebra processing pipelines are converted to a DAG with a set of operators to perform business logic on streaming data.   Above figure explains how SQL query gets converted to Apex DAG.   User specified query is processed by Calcite Query planner; this involves parsing and optimizing the query to generate Relation Expression Tree.   This Relation Expression Tree is received by Apache Apex\u2019s SQL module to finally convert to an Apex DAG having series of operators.   One peculiarity of Calcite queries is that the data source and destination need not be RDBMS systems; in the above example,  File  refers to a file in the filesystem and  Kafka  to a Kafka message broker. Calcite allows Apex to register table sources and destinations as anything which can return a row type results. So a \u201cscan\u201d relational expression gets converted to \u201cKafkaInputOperator + ParseOperator\u201d, a result of which is series of POJOs reflecting a Row Type. Similarly, the \u201cinsert\u201d Relational Expression translated to \u201cFormatOperator + FileOutputOperator\u201d.  For more details about the integration, click  here .",
            "title": "Apex-Calcite Integration"
        },
        {
            "location": "/apis/calcite/#sql-apis-for-apache-apex",
            "text": "Listed below are the Java APIs which can be used by SQL/Apex users to create a DAG in the implementation of the  populateDAG  method of the  StreamingApplication  interface.     API  Description      SQLExecEnvironment.getEnvironment()  Creates a new SQL execution environment    SQLExecEnvironment.registerTable(tableName, endpointInstance)  Registers a new abstract table with existing environment.  endpointInstance  is an object of type  Endpoint  which defines a table.    SQLExecEnvironment.registerFunction(sqlFunctionName, holderClass, staticFunctionName)  Registers a new User Defined Scalar function    SQLExecEnvironment.executeSQL(dag, sqlStatement)  Creates a DAG for a particular SQL statement     Usage of above APIs is described in detail in following sections.",
            "title": "SQL APIs for Apache Apex"
        },
        {
            "location": "/apis/calcite/#example-1-pure-style-sql-application",
            "text": "With Apache Calcite Integration, you can use SQL queries across different data sources and provide UDFs (User Defined Functions) as per your business logic. This example will use a Kafka topic as the source and a HDFS file as the destination.\nFollowing application code will be used to explain APIs. Actual source code can be found  here .    public class PureStyleSQLApplication implements StreamingApplication\n  {\n    @Override\n    public void populateDAG(DAG dag, Configuration conf)\n    {\n       // Create new SQLExecEnvironment\n       SQLExecEnvironment sqlEnv = SQLExecEnvironment.getEnvironment();\n\n      // This is a string that defines a schema and is discussed in more detail in \"Registering tables with SQLExecEnvironment\" section \n      String inputSchemaString = \"...\";\n\n      // similar to inputSchemaString, we also need to define outputSchemaString\n      String outputSchemaString = \"...\";\n\n       // Register KafkaEnpoint as \"ORDERS\" table with kafka topic and data format as CSV\n       sqlEnv = sqlEnv.registerTable( \n                                    \"ORDERS\", \n                                    new KafkaEndpoint(\"localhost:9090\", \n                                                      \"inputTopic\", \n                                                      new CSVMessageFormat(inputSchemaString))\n                                  );\n\n       // Register FileEndpoint as \"SALES\" table with file path and data format as CSV\n       sqlEnv = sqlEnv.registerTable( \n                                    \"SALES\", \n                                    new FileEndpoint(\"/tmp/output\", \n                                                     \"out.file\", \n                                                     new CSVMessageFormat(outputSchemaString))\n                                  );\n\n       // Register scalar SQL UDF \n       sqlEnv = sqlEnv.registerFunction(\"APEXCONCAT\", PureStyleSQLApplication.class, \"apex_concat_str\");\n\n       // Converting SQL statement to DAG \n       String sql = \"INSERT INTO SALES \n                       SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n                       FROM ORDERS \n                       WHERE ID > 3 AND PRODUCT LIKE 'paint%'\";\n       sqlEnv.executeSQL(dag, sql);\n    }// populateDAG finished\n\n    public static String apex_concat_str(String s1, String s2)\n    {\n        return s1 + s2;\n    } \n  }",
            "title": "Example 1: Pure Style SQL Application"
        },
        {
            "location": "/apis/calcite/#constructing-sqlexecenvironment",
            "text": "The class  SQLExecEnvironment  provides a starting point and a simple way to define metadata needed for running a SQL statement; a new instance of this class is returned by the  getEnvironment  static method.      // Creates SQLExecEnvironment instance by using static method getEnvironment\n  SQLExecEnvironment sqlEnv = SQLExecEnvironment.getEnvironment();",
            "title": "Constructing SQLExecEnvironment"
        },
        {
            "location": "/apis/calcite/#registering-tables-with-sqlexecenvironment",
            "text": "Next, we need to register tables which can be used in a query. For this purpose, we can use  registerTable  method from SQLExecEnvironment.    // Register KafkaEnpoint as \"ORDERS\" table with kafka topic and data format as CSV\n  sqlEnv = sqlEnv.registerTable( \n                              \"ORDERS\", \n                              new KafkaEndpoint(\"localhost:9090\", \n                                                \"inputTopic\", \n                                                new CSVMessageFormat(inputSchemaString))\n                            );\n\n  // Register FileEndpoint as \"SALES\" table with file path and data format as CSV\n  sqlEnv = sqlEnv.registerTable( \n                              \"SALES\", \n                              new FileEndpoint(\"/tmp/output\", \n                                               \"out.file\", \n                                               new CSVMessageFormat(inputSchemaString))\n                            );  \"registerTable\"  method takes the name of the table and an instance of endpoint as parameters. Endpoint signifies data storage mechanism and type of source/destination for the data. These endpoints require different types of configurations and possibly data formats. The data format is defined using an implementation of the  MessageFormat  interface; the  CSVMessageFormat  implementation can be configured with a schema string as follows:  {\n  \"separator\": \",\",\n  \"quoteChar\": \"\\\"\",\n  \"fields\": [\n    {\n      \"name\": \"RowTime\",\n      \"type\": \"Date\",\n      \"constraints\": {\n        \"format\": \"dd/MM/yyyy hh:mm:ss Z\"\n      }\n    },\n    {\n      \"name\": \"id\",\n      \"type\": \"Integer\"\n    },\n    {\n      \"name\": \"Product\",\n      \"type\": \"String\"\n    },\n    {\n      \"name\": \"units\",\n      \"type\": \"Integer\"\n    }\n  ]\n}  The schema string is a JSON string defining a separator character, quote character for fields with String type and a list of fields where, for each field, its name, type and any additional constraints are specified.  Following data endpoints are supported:    KafkaEnpoint \n: To define a Kafka Endpoint we need to specify the Kafka broker (as host:port), topic name and MessageFormat as seen in line 1 in the code above.  FileEndpoint \n: It needs to be configured with the filesystem path, file name and MessageFormat as in line 2 in the code above.   StreamEndpoint  \n: This allows us to connect existing operator output or input ports to the SQL query as a data source or sink respectively. StreamEndpoint needs immediate downstream operator's input port or immediate upstream operator's output port and the field mapping for CSV data or POJO class. This will be explained in detail in next  example .",
            "title": "Registering tables with SQLExecEnvironment"
        },
        {
            "location": "/apis/calcite/#using-user-defined-functions-udf-in-a-sql-query",
            "text": "We can use our own scalar UDF, implemented in Java, in a SQL statement for data manipulation but first, we need to register the function with the execution environment by using the  registerFunction  method.    sqlEnv = sqlEnv.registerFunction(\"APEXCONCAT\", PureStyleSQLApplication.class, \"apex_concat_str\");  In above code,  registerFunction  takes the UDF name to be used in SQL, JAVA class which implements the static method and name of that method as parameters. \nThe static method  apex_concat_str  takes two String objects as input parameters from the SQL query.    public static String apex_concat_str(String s1, String s2)\n  {\n    return s1 + s2;\n  }  The scalar UDF \"APEXCONCAT\" that was registered above can be used in SQL as described below. FLOOR and SUBSTRING are standard SQL scalar functions supported by Apache Calcite.  INSERT INTO SALES \n       SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n       FROM ORDERS \n       WHERE ID > 3 AND PRODUCT LIKE 'paint%'  To read about all functions and operators supported by Apache Calcite, click  here .",
            "title": "Using User Defined Functions (UDF) in a SQL query"
        },
        {
            "location": "/apis/calcite/#executing-sql-query",
            "text": "Finally to execute the query we need to use  executeSQL  function with a DAG and SQL statement as parameters.    // Converting SQL statement to DAG \n  String sql = \"INSERT INTO SALES \n                SELECT STREAM ROWTIME, FLOOR(ROWTIME TO DAY), APEXCONCAT('OILPAINT', SUBSTRING(PRODUCT, 6, 7)) \n                FROM ORDERS \n                WHERE ID > 3 AND PRODUCT LIKE 'paint%'\";\n  sqlEnv.executeSQL(dag, sql);  When executeSQL method is called, the query goes through various phases like conversion to relational algebra, optimization and planning in Calcite to generate Relation Expression Tree. \nThe generated Relation Expression Tree is consumed by Apex SQL and converted to a DAG using operators available in Apache Malhar. In the above example, the ORDERS and SALES tables will be converted to the operators KafkaInputOperator and FileOutputFormatter respectively, paired with the CSVParser formatter in both cases.  A  WHERE  clause is used in this query; it defines the desired filter for rows and is converted to a  FilterTransformOperator  in the DAG. Similarly, the projection defining desired columns is converted into another instance of the  FilterTransformOperator . The DAG created for this application will look like this:",
            "title": "Executing SQL Query"
        },
        {
            "location": "/apis/calcite/#example-2-fusion-style-sql-application",
            "text": "As described in Pure Style SQL application, we can use different data sources as source and sink while developing Apex Applications with Calcite. This example will describe how we can develop Apex application with Apex stream as abstract table for SQL query. Actual source code can be found  here .    // Define Kafka Input Operator for reading data from Kafka\n  KafkaSinglePortInputOperator kafkaInput = dag.addOperator(\"KafkaInput\", \n                                                           KafkaSinglePortInputOperator.class);\n\n  kafkaInput.setInitialOffset(\"EARLIEST\");\n\n  // Add CSVParser\n  CsvParser csvParser = dag.addOperator(\"CSVParser\", CsvParser.class);\n  dag.addStream(\"KafkaToCSV\", kafkaInput.outputPort, csvParser.in);  Once we define DAG with KafkaInputOperator and CSVParser, it can parse data from Kafka topic. Upto this point, this is a regular Apex application without SQL. After this, we can register the output of CSVParser as a table using  StreamEndpoint  to run a SQL statement. This way we can develop applications in fusion style where the DAG is part SQL and part regular Apex DAG.  The following code will describe how we can define StreamEndpoint.     SQLExecEnvironment sqlEnv = sqlEnv.getEnvironment();\n  Map<String, Class> fieldMapping = ImmutableMap.<String, Class>of(\"RowTime\", Date.class,\n                                                                 \"id\", Integer.class,\n                                                                 \"Product\", String.class,\n                                                                 \"units\", Integer.class);\n  sqlEnv = sqlEnv.registerTable(\"FROMCSV\", new StreamEndpoint(csvParser.out, fieldMapping));  To read existing data stream, we need to register it as a table with SQL execution environment with the name of the table and StreamEndpoint. StreamEndpoint can serve as input table or output table in SQL. For input table configuration we need to initialise StreamEndpoint with immediate upstream operator's output port and fieldMapping or POJO class for input tuple(as shown above). For output table configuration, we need to initialise StreamEndpoint with immediate downstream operator's input port and fieldMapping or POJO class for output tuple. Once we register StreamEndpoint as a table with a name in SQL Execution Environment, it can be used as a table in SQL statement similar to other endpoints.  When executeSQL method is called, the specified SQL is converted to DAG as described in the previous section. Both examples read CSV data from Kafka. But in the pure style SQL example the  KafkaInputOperator  and  CSVParser  in the DAG are created implicitly by the use of the KafkaEndpoint usage while in the fusion style example, they are explicitly defined as part of the DAG which is then extended with other operators as shown in the image below.    For all Apex-Calcite integration examples, click  here .",
            "title": "Example 2: Fusion Style SQL Application"
        },
        {
            "location": "/apis/calcite/#ongoing-efforts",
            "text": "Apache Apex-Calcite integration provides support for basic queries and efforts are underway to extend support for aggregations, sorting and other features using Tumbling, Hopping and Session Windows.\nSupport for JSON, XML and JDBC endpoint are also planned. The goal of this integration is to make developing a streaming application using SQL easy so that SQL Developers don't have to write any java code at all.",
            "title": "Ongoing efforts"
        },
        {
            "location": "/operators/block_reader/",
            "text": "Block Reader\n\n\nThis is a scalable operator that reads and parses blocks of data sources into records. A data source can be a file or a message bus that contains records and a block defines a chunk of data in the source by specifying the block offset and the length of the source belonging to the block. \n\n\nWhy is it needed?\n\n\nA Block Reader is needed to parallelize reading and parsing of a single data source, for example a file. Simple parallelism of reading data sources can be achieved by multiple partitions reading different source of same type (for files see \nAbstractFileInputOperator\n) but Block Reader partitions can read blocks of same source in parallel and parse them for records ensuring that no record is duplicated or missed.\n\n\nClass Diagram\n\n\n\n\nAbstractBlockReader\n\n\nThis is the abstract implementation that serves as the base for different types of data sources. It defines how a block metadata is processed. The flow diagram below describes the processing of a block metadata.\n\n\n\n\nPorts\n\n\n\n\n\n\nblocksMetadataInput: input port on which block metadata are received.\n\n\n\n\n\n\nblocksMetadataOutput: output port on which block metadata are emitted if the port is connected. This port is useful when a downstream operator that receives records from block reader may also be interested to know the details of the corresponding blocks.\n\n\n\n\n\n\nmessages: output port on which tuples of type \ncom.datatorrent.lib.io.block.AbstractBlockReader.ReaderRecord\n are emitted. This class encapsulates a \nrecord\n and the \nblockId\n of the corresponding block.\n\n\n\n\n\n\nreaderContext\n\n\nThis is one of the most important fields in the block reader. It is of type \ncom.datatorrent.lib.io.block.ReaderContext\n and is responsible for fetching bytes that make a record. It also lets the reader know how many total bytes were consumed which may not be equal to the total bytes in a record because consumed bytes also include bytes for the record delimiter which may not be a part of the actual record.\n\n\nOnce the reader creates an input stream for the block (or uses the previous opened stream if the current block is successor of the previous block) it initializes the reader context by invoking \nreaderContext.initialize(stream, blockMetadata, consecutiveBlock);\n. Initialize method is where any implementation of \nReaderContext\n can perform all the operations which have to be executed just before reading the block or create states which are used during the lifetime of reading the block.\n\n\nOnce the initialization is done, \nreaderContext.next()\n is called repeatedly until it returns \nnull\n. It is left to the \nReaderContext\n implementations to decide when a block is completely processed. In cases when a record is split across adjacent blocks, reader context may decide to read ahead of the current block boundary to completely fetch the split record (examples- \nLineReaderContext\n and \nReadAheadLineReaderContext\n). In other cases when there isn't a possibility of split record (example- \nFixedBytesReaderContext\n), it returns \nnull\n immediately when the block boundary is reached. The return type of \nreaderContext.next()\n is of type \ncom.datatorrent.lib.io.block.ReaderContext.Entity\n which is just a wrapper for a \nbyte[]\n that represents the record and total bytes used in fetching the record.\n\n\nAbstract methods\n\n\n\n\n\n\nSTREAM setupStream(B block)\n: creating a stream for a block is dependent on the type of source which is not known to AbstractBlockReader. Sub-classes which deal with a specific data source provide this implementation.\n\n\n\n\n\n\nR convertToRecord(byte[] bytes)\n: this converts the array of bytes into the actual instance of record type.\n\n\n\n\n\n\nAuto-scalability\n\n\nBlock reader can auto-scale, that is, depending on the backlog (total number of all the blocks which are waiting in the \nblocksMetadataInput\n port queue of all partitions) it can create more partitions or reduce them. Details are discussed in the last section which covers the \npartitioner and stats-listener\n.\n\n\nConfiguration\n\n\n\n\nmaxReaders\n: when auto-scaling is enabled, this controls the maximum number of block reader partitions that can be created.\n\n\nminReaders\n: when auto-scaling is enabled, this controls the minimum number of block reader partitions that should always exist.\n\n\ncollectStats\n: this enables or disables auto-scaling. When it is set to \ntrue\n the stats (number of blocks in the queue) are collected and this triggers partitioning; otherwise auto-scaling is disabled.\n\n\nintervalMillis\n: when auto-scaling is enabled, this specifies the interval at which the reader will trigger the logic of computing the backlog and auto-scale.\n\n\n\n\n AbstractFSBlockReader\n\n\nThis abstract implementation deals with files. Different types of file systems that are implementations of \norg.apache.hadoop.fs.FileSystem\n are supported. The user can override \ngetFSInstance()\n method to create an instance of a specific \nFileSystem\n. By default, filesystem instance is created from the filesytem URI that comes from the default hadoop configuration.\n\n\nprotected FileSystem getFSInstance() throws IOException\n{\n  return FileSystem.newInstance(configuration);\n}\n\n\n\n\nIt uses this filesystem instance to setup a stream of type \norg.apache.hadoop.fs.FSDataInputStream\n to read the block.\n\n\n@Override\nprotected FSDataInputStream setupStream(BlockMetadata.FileBlockMetadata block) throws IOException\n{\n  return fs.open(new Path(block.getFilePath()));\n}\n\n\n\n\nAll the ports and configurations are derived from the super class. It doesn't provide an implementation of \nconvertToRecord(byte[] bytes)\n method which is delegated to concrete sub-classes.\n\n\nExample Application\n\n\nThis simple dag demonstrates how any concrete implementation of \nAbstractFSBlockReader\n can be plugged into an application. \n\n\n\n\nIn the above application, file splitter creates block metadata for files which are sent to block reader. Partitions of the block reader parses the file blocks for records which are filtered, transformed and then persisted to a file (created per block). Therefore block reader is parallel partitioned with the 2 downstream operators - filter/converter and record output operator. The code which implements this dag is below.\n\n\npublic class ExampleApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    FileSplitterInput input = dag.addOperator(\"File-splitter\", new FileSplitterInput());\n    //any concrete implementation of AbstractFSBlockReader based on the use-case can be added here.\n    LineReader blockReader = dag.addOperator(\"Block-reader\", new LineReader());\n    Filter filter = dag.addOperator(\"Filter\", new Filter());\n    RecordOutputOperator recordOutputOperator = dag.addOperator(\"Record-writer\", new RecordOutputOperator());\n\n    dag.addStream(\"file-block metadata\", input.blocksMetadataOutput, blockReader.blocksMetadataInput);\n    dag.addStream(\"records\", blockReader.messages, filter.input);\n    dag.addStream(\"filtered-records\", filter.output, recordOutputOperator.input);\n  }\n\n  /**\n   * Concrete implementation of {@link AbstractFSBlockReader} for which a record is a line in the file.\n   */\n  public static class LineReader extends AbstractFSBlockReader.AbstractFSReadAheadLineReader<String>\n  {\n\n    @Override\n    protected String convertToRecord(byte[] bytes)\n    {\n      return new String(bytes);\n    }\n  }\n\n  /**\n   * Considers any line starting with a '.' as invalid. Emits the valid records.\n   */\n  public static class Filter extends BaseOperator\n  {\n    public final transient DefaultOutputPort<AbstractBlockReader.ReaderRecord<String>> output = new DefaultOutputPort<>();\n    public final transient DefaultInputPort<AbstractBlockReader.ReaderRecord<String>> input = new DefaultInputPort<AbstractBlockReader.ReaderRecord<String>>()\n    {\n      @Override\n      public void process(AbstractBlockReader.ReaderRecord<String> stringRecord)\n      {\n        //filter records and transform\n        //if the string starts with a '.' ignore the string.\n        if (!StringUtils.startsWith(stringRecord.getRecord(), \".\")) {\n          output.emit(stringRecord);\n        }\n      }\n    };\n  }\n\n  /**\n   * Persists the valid records to corresponding block files.\n   */\n  public static class RecordOutputOperator extends AbstractFileOutputOperator<AbstractBlockReader.ReaderRecord<String>>\n  {\n    @Override\n    protected String getFileName(AbstractBlockReader.ReaderRecord<String> tuple)\n    {\n      return Long.toHexString(tuple.getBlockId());\n    }\n\n    @Override\n    protected byte[] getBytesForTuple(AbstractBlockReader.ReaderRecord<String> tuple)\n    {\n      return tuple.getRecord().getBytes();\n    }\n  }\n}\n\n\n\n\nConfiguration to parallel partition block reader with its downstream operators.\n\n\n  <property>\n    <name>dt.operator.Filter.port.input.attr.PARTITION_PARALLEL</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>dt.operator.Record-writer.port.input.attr.PARTITION_PARALLEL</name>\n    <value>true</value>\n  </property>\n\n\n\n\nAbstractFSReadAheadLineReader\n\n\nThis extension of \nAbstractFSBlockReader\n parses lines from a block and binds the \nreaderContext\n field to an instance of \nReaderContext.ReadAheadLineReaderContext\n.\n\n\nIt is abstract because it doesn't provide an implementation of \nconvertToRecord(byte[] bytes)\n since the user may want to convert the bytes that make a line into some other type. \n\n\nReadAheadLineReaderContext\n\n\nIn order to handle a line split across adjacent blocks, ReadAheadLineReaderContext always reads beyond the block boundary and ignores the bytes till the first end-of-line character of all the blocks except the first block of the file. This ensures that no line is missed or incomplete.\n\n\nThis is one of the most common ways of handling a split record. It doesn't require any further information to decide if a line is complete. However, the cost of this consistent way to handle a line split is that it always reads from the next block.\n\n\nAbstractFSLineReader\n\n\nSimilar to \nAbstractFSReadAheadLineReader\n, even this parses lines from a block. However, it binds the \nreaderContext\n field to an instance of \nReaderContext.LineReaderContext\n.\n\n\nLineReaderContext\n\n\nThis handles the line split differently from \nReadAheadLineReaderContext\n. It doesn't always read from the next block. If the end of the last line is aligned with the block boundary then it stops processing the block. It does read from the next block when the boundaries are not aligned, that is, last line extends beyond the block boundary. The result of this is an inconsistency in reading the next block.\n\n\nWhen the boundary of the last line of the previous block was aligned with its block, then the first line of the current block is a valid line. However, in the other case the bytes from the block start offset to the first end-of-line character should be ignored. Therefore, this means that any record formed by this reader context has to be validated. For example, if the lines are of fixed size then size of each record can be validated or if each line begins with a special field then that knowledge can be used to check if a record is complete.\n\n\nIf the validations of completeness fails for a line then \nconvertToRecord(byte[] bytes)\n should return null.\n\n\nFSSliceReader\n\n\nA concrete extension of \nAbstractFSBlockReader\n that reads fixed-size \nbyte[]\n from a block and emits the byte array wrapped in \ncom.datatorrent.netlet.util.Slice\n.\n\n\nThis operator binds the \nreaderContext\n to an instance of \nReaderContext.FixedBytesReaderContext\n.\n\n\nFixedBytesReaderContext\n\n\nThis implementation of \nReaderContext\n never reads beyond a block boundary which can result in the last \nbyte[]\n of a block to be of a shorter length than the rest of the records.\n\n\nConfiguration\n\n\nreaderContext.length\n: length of each record. By default, this is initialized to the default hdfs block size.\n\n\nPartitioner and StatsListener\n\n\nThe logical instance of the block reader acts as the Partitioner (unless a custom partitioner is set using the operator attribute - \nPARTITIONER\n) as well as a StatsListener. This is because the \n\nAbstractBlockReader\n implements both the \ncom.datatorrent.api.Partitioner\n and \ncom.datatorrent.api.StatsListener\n interfaces and provides an implementation of \ndefinePartitions(...)\n and \nprocessStats(...)\n which make it auto-scalable.\n\n\nprocessStats \n\n\nThe application master invokes \nResponse processStats(BatchedOperatorStats stats)\n method on the logical instance with the stats (\ntuplesProcessedPSMA\n, \ntuplesEmittedPSMA\n, \nlatencyMA\n, etc.) of each partition. The data which this operator is interested in is the \nqueueSize\n of the input port \nblocksMetadataInput\n.\n\n\nUsually the \nqueueSize\n of an input port gives the count of waiting control tuples plus data tuples. However, if a stats listener is interested only in the count of data tuples then that can be expressed by annotating the class with \n@DataQueueSize\n. In this case \nAbstractBlockReader\n itself is the \nStatsListener\n which is why it is annotated with \n@DataQueueSize\n.\n\n\nThe logical instance caches the queue size per partition and at regular intervals (configured by \nintervalMillis\n) sums these values to find the total backlog which is then used to decide whether re-partitioning is needed. The flow-diagram below describes this logic.\n\n\n\n\nThe goal of this logic is to create as many partitions within bounds (see \nmaxReaders\n and \nminReaders\n above) to quickly reduce this backlog or if the backlog is small then remove any idle partitions.\n\n\ndefinePartitions\n\n\nBased on the \nrepartitionRequired\n field of the \nResponse\n object which is returned by \nprocessStats\n method, the application master invokes \n\n\nCollection<Partition<AbstractBlockReader<...>>> definePartitions(Collection<Partition<AbstractBlockReader<...>>> partitions, PartitioningContext context)\n\n\n\n\non the logical instance which is also the partitioner instance. The implementation calculates the difference between required partitions and the existing count of partitions. If this difference is negative, then equivalent number of partitions are removed otherwise new partitions are created. \n\n\nPlease note auto-scaling can be disabled by setting \ncollectStats\n to \nfalse\n. If the use-case requires only static partitioning, then that can be achieved by setting \nStatelessPartitioner\n as the operator attribute- \nPARTITIONER\n on the block reader.",
            "title": "Block Reader"
        },
        {
            "location": "/operators/block_reader/#block-reader",
            "text": "This is a scalable operator that reads and parses blocks of data sources into records. A data source can be a file or a message bus that contains records and a block defines a chunk of data in the source by specifying the block offset and the length of the source belonging to the block.",
            "title": "Block Reader"
        },
        {
            "location": "/operators/block_reader/#why-is-it-needed",
            "text": "A Block Reader is needed to parallelize reading and parsing of a single data source, for example a file. Simple parallelism of reading data sources can be achieved by multiple partitions reading different source of same type (for files see  AbstractFileInputOperator ) but Block Reader partitions can read blocks of same source in parallel and parse them for records ensuring that no record is duplicated or missed.",
            "title": "Why is it needed?"
        },
        {
            "location": "/operators/block_reader/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/block_reader/#abstractblockreader",
            "text": "This is the abstract implementation that serves as the base for different types of data sources. It defines how a block metadata is processed. The flow diagram below describes the processing of a block metadata.",
            "title": "AbstractBlockReader"
        },
        {
            "location": "/operators/block_reader/#ports",
            "text": "blocksMetadataInput: input port on which block metadata are received.    blocksMetadataOutput: output port on which block metadata are emitted if the port is connected. This port is useful when a downstream operator that receives records from block reader may also be interested to know the details of the corresponding blocks.    messages: output port on which tuples of type  com.datatorrent.lib.io.block.AbstractBlockReader.ReaderRecord  are emitted. This class encapsulates a  record  and the  blockId  of the corresponding block.",
            "title": "Ports"
        },
        {
            "location": "/operators/block_reader/#readercontext",
            "text": "This is one of the most important fields in the block reader. It is of type  com.datatorrent.lib.io.block.ReaderContext  and is responsible for fetching bytes that make a record. It also lets the reader know how many total bytes were consumed which may not be equal to the total bytes in a record because consumed bytes also include bytes for the record delimiter which may not be a part of the actual record.  Once the reader creates an input stream for the block (or uses the previous opened stream if the current block is successor of the previous block) it initializes the reader context by invoking  readerContext.initialize(stream, blockMetadata, consecutiveBlock); . Initialize method is where any implementation of  ReaderContext  can perform all the operations which have to be executed just before reading the block or create states which are used during the lifetime of reading the block.  Once the initialization is done,  readerContext.next()  is called repeatedly until it returns  null . It is left to the  ReaderContext  implementations to decide when a block is completely processed. In cases when a record is split across adjacent blocks, reader context may decide to read ahead of the current block boundary to completely fetch the split record (examples-  LineReaderContext  and  ReadAheadLineReaderContext ). In other cases when there isn't a possibility of split record (example-  FixedBytesReaderContext ), it returns  null  immediately when the block boundary is reached. The return type of  readerContext.next()  is of type  com.datatorrent.lib.io.block.ReaderContext.Entity  which is just a wrapper for a  byte[]  that represents the record and total bytes used in fetching the record.",
            "title": "readerContext"
        },
        {
            "location": "/operators/block_reader/#abstract-methods",
            "text": "STREAM setupStream(B block) : creating a stream for a block is dependent on the type of source which is not known to AbstractBlockReader. Sub-classes which deal with a specific data source provide this implementation.    R convertToRecord(byte[] bytes) : this converts the array of bytes into the actual instance of record type.",
            "title": "Abstract methods"
        },
        {
            "location": "/operators/block_reader/#auto-scalability",
            "text": "Block reader can auto-scale, that is, depending on the backlog (total number of all the blocks which are waiting in the  blocksMetadataInput  port queue of all partitions) it can create more partitions or reduce them. Details are discussed in the last section which covers the  partitioner and stats-listener .",
            "title": "Auto-scalability"
        },
        {
            "location": "/operators/block_reader/#configuration",
            "text": "maxReaders : when auto-scaling is enabled, this controls the maximum number of block reader partitions that can be created.  minReaders : when auto-scaling is enabled, this controls the minimum number of block reader partitions that should always exist.  collectStats : this enables or disables auto-scaling. When it is set to  true  the stats (number of blocks in the queue) are collected and this triggers partitioning; otherwise auto-scaling is disabled.  intervalMillis : when auto-scaling is enabled, this specifies the interval at which the reader will trigger the logic of computing the backlog and auto-scale.",
            "title": "Configuration"
        },
        {
            "location": "/operators/block_reader/#example-application",
            "text": "This simple dag demonstrates how any concrete implementation of  AbstractFSBlockReader  can be plugged into an application.    In the above application, file splitter creates block metadata for files which are sent to block reader. Partitions of the block reader parses the file blocks for records which are filtered, transformed and then persisted to a file (created per block). Therefore block reader is parallel partitioned with the 2 downstream operators - filter/converter and record output operator. The code which implements this dag is below.  public class ExampleApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    FileSplitterInput input = dag.addOperator(\"File-splitter\", new FileSplitterInput());\n    //any concrete implementation of AbstractFSBlockReader based on the use-case can be added here.\n    LineReader blockReader = dag.addOperator(\"Block-reader\", new LineReader());\n    Filter filter = dag.addOperator(\"Filter\", new Filter());\n    RecordOutputOperator recordOutputOperator = dag.addOperator(\"Record-writer\", new RecordOutputOperator());\n\n    dag.addStream(\"file-block metadata\", input.blocksMetadataOutput, blockReader.blocksMetadataInput);\n    dag.addStream(\"records\", blockReader.messages, filter.input);\n    dag.addStream(\"filtered-records\", filter.output, recordOutputOperator.input);\n  }\n\n  /**\n   * Concrete implementation of {@link AbstractFSBlockReader} for which a record is a line in the file.\n   */\n  public static class LineReader extends AbstractFSBlockReader.AbstractFSReadAheadLineReader<String>\n  {\n\n    @Override\n    protected String convertToRecord(byte[] bytes)\n    {\n      return new String(bytes);\n    }\n  }\n\n  /**\n   * Considers any line starting with a '.' as invalid. Emits the valid records.\n   */\n  public static class Filter extends BaseOperator\n  {\n    public final transient DefaultOutputPort<AbstractBlockReader.ReaderRecord<String>> output = new DefaultOutputPort<>();\n    public final transient DefaultInputPort<AbstractBlockReader.ReaderRecord<String>> input = new DefaultInputPort<AbstractBlockReader.ReaderRecord<String>>()\n    {\n      @Override\n      public void process(AbstractBlockReader.ReaderRecord<String> stringRecord)\n      {\n        //filter records and transform\n        //if the string starts with a '.' ignore the string.\n        if (!StringUtils.startsWith(stringRecord.getRecord(), \".\")) {\n          output.emit(stringRecord);\n        }\n      }\n    };\n  }\n\n  /**\n   * Persists the valid records to corresponding block files.\n   */\n  public static class RecordOutputOperator extends AbstractFileOutputOperator<AbstractBlockReader.ReaderRecord<String>>\n  {\n    @Override\n    protected String getFileName(AbstractBlockReader.ReaderRecord<String> tuple)\n    {\n      return Long.toHexString(tuple.getBlockId());\n    }\n\n    @Override\n    protected byte[] getBytesForTuple(AbstractBlockReader.ReaderRecord<String> tuple)\n    {\n      return tuple.getRecord().getBytes();\n    }\n  }\n}  Configuration to parallel partition block reader with its downstream operators.    <property>\n    <name>dt.operator.Filter.port.input.attr.PARTITION_PARALLEL</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>dt.operator.Record-writer.port.input.attr.PARTITION_PARALLEL</name>\n    <value>true</value>\n  </property>",
            "title": "Example Application"
        },
        {
            "location": "/operators/block_reader/#abstractfsreadaheadlinereader",
            "text": "This extension of  AbstractFSBlockReader  parses lines from a block and binds the  readerContext  field to an instance of  ReaderContext.ReadAheadLineReaderContext .  It is abstract because it doesn't provide an implementation of  convertToRecord(byte[] bytes)  since the user may want to convert the bytes that make a line into some other type.",
            "title": "AbstractFSReadAheadLineReader"
        },
        {
            "location": "/operators/block_reader/#readaheadlinereadercontext",
            "text": "In order to handle a line split across adjacent blocks, ReadAheadLineReaderContext always reads beyond the block boundary and ignores the bytes till the first end-of-line character of all the blocks except the first block of the file. This ensures that no line is missed or incomplete.  This is one of the most common ways of handling a split record. It doesn't require any further information to decide if a line is complete. However, the cost of this consistent way to handle a line split is that it always reads from the next block.",
            "title": "ReadAheadLineReaderContext"
        },
        {
            "location": "/operators/block_reader/#abstractfslinereader",
            "text": "Similar to  AbstractFSReadAheadLineReader , even this parses lines from a block. However, it binds the  readerContext  field to an instance of  ReaderContext.LineReaderContext .",
            "title": "AbstractFSLineReader"
        },
        {
            "location": "/operators/block_reader/#linereadercontext",
            "text": "This handles the line split differently from  ReadAheadLineReaderContext . It doesn't always read from the next block. If the end of the last line is aligned with the block boundary then it stops processing the block. It does read from the next block when the boundaries are not aligned, that is, last line extends beyond the block boundary. The result of this is an inconsistency in reading the next block.  When the boundary of the last line of the previous block was aligned with its block, then the first line of the current block is a valid line. However, in the other case the bytes from the block start offset to the first end-of-line character should be ignored. Therefore, this means that any record formed by this reader context has to be validated. For example, if the lines are of fixed size then size of each record can be validated or if each line begins with a special field then that knowledge can be used to check if a record is complete.  If the validations of completeness fails for a line then  convertToRecord(byte[] bytes)  should return null.",
            "title": "LineReaderContext"
        },
        {
            "location": "/operators/block_reader/#fsslicereader",
            "text": "A concrete extension of  AbstractFSBlockReader  that reads fixed-size  byte[]  from a block and emits the byte array wrapped in  com.datatorrent.netlet.util.Slice .  This operator binds the  readerContext  to an instance of  ReaderContext.FixedBytesReaderContext .",
            "title": "FSSliceReader"
        },
        {
            "location": "/operators/block_reader/#fixedbytesreadercontext",
            "text": "This implementation of  ReaderContext  never reads beyond a block boundary which can result in the last  byte[]  of a block to be of a shorter length than the rest of the records.",
            "title": "FixedBytesReaderContext"
        },
        {
            "location": "/operators/block_reader/#configuration_1",
            "text": "readerContext.length : length of each record. By default, this is initialized to the default hdfs block size.",
            "title": "Configuration"
        },
        {
            "location": "/operators/block_reader/#partitioner-and-statslistener",
            "text": "The logical instance of the block reader acts as the Partitioner (unless a custom partitioner is set using the operator attribute -  PARTITIONER ) as well as a StatsListener. This is because the  AbstractBlockReader  implements both the  com.datatorrent.api.Partitioner  and  com.datatorrent.api.StatsListener  interfaces and provides an implementation of  definePartitions(...)  and  processStats(...)  which make it auto-scalable.",
            "title": "Partitioner and StatsListener"
        },
        {
            "location": "/operators/block_reader/#processstats",
            "text": "The application master invokes  Response processStats(BatchedOperatorStats stats)  method on the logical instance with the stats ( tuplesProcessedPSMA ,  tuplesEmittedPSMA ,  latencyMA , etc.) of each partition. The data which this operator is interested in is the  queueSize  of the input port  blocksMetadataInput .  Usually the  queueSize  of an input port gives the count of waiting control tuples plus data tuples. However, if a stats listener is interested only in the count of data tuples then that can be expressed by annotating the class with  @DataQueueSize . In this case  AbstractBlockReader  itself is the  StatsListener  which is why it is annotated with  @DataQueueSize .  The logical instance caches the queue size per partition and at regular intervals (configured by  intervalMillis ) sums these values to find the total backlog which is then used to decide whether re-partitioning is needed. The flow-diagram below describes this logic.   The goal of this logic is to create as many partitions within bounds (see  maxReaders  and  minReaders  above) to quickly reduce this backlog or if the backlog is small then remove any idle partitions.",
            "title": "processStats "
        },
        {
            "location": "/operators/block_reader/#definepartitions",
            "text": "Based on the  repartitionRequired  field of the  Response  object which is returned by  processStats  method, the application master invokes   Collection<Partition<AbstractBlockReader<...>>> definePartitions(Collection<Partition<AbstractBlockReader<...>>> partitions, PartitioningContext context)  on the logical instance which is also the partitioner instance. The implementation calculates the difference between required partitions and the existing count of partitions. If this difference is negative, then equivalent number of partitions are removed otherwise new partitions are created.   Please note auto-scaling can be disabled by setting  collectStats  to  false . If the use-case requires only static partitioning, then that can be achieved by setting  StatelessPartitioner  as the operator attribute-  PARTITIONER  on the block reader.",
            "title": "definePartitions"
        },
        {
            "location": "/operators/csvformatter/",
            "text": "CsvFormatter\n\n\nOperator Objective\n\n\nThis operator receives a POJO (\nPlain Old Java Object\n) as an incoming tuple, converts the data in \nthe incoming POJO to a custom delimited string and emits the delimited string.\n\n\nCsvFormatter supports schema definition as a JSON string. \n\n\nCsvFormatter does not hold any state and is \nidempotent\n, \nfault-tolerant\n and \nstatically/dynamically partitionable\n.\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-contrib\n\n\nAvailable since: \n3.2.0\n\n\nOperator state: \nEvolving\n\n\nJava Packages:\n\n\nOperator: \ncom.datatorrent.contrib.formatter.CsvFormatter\n\n\n\n\n\n\n\n\nProperties, Attributes and Ports\n\n\nProperties of POJOEnricher\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nContents of the schema.Schema is specified in a json format.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on input port which tells operator the class of POJO which will be incoming\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples which need to be formatted are received on this port\n\n\nObject (POJO)\n\n\nYes\n\n\n\n\n\n\nout\n\n\nTuples that are formatted are emitted from this port\n\n\nString\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nTuples that could not be converted are emitted on this port\n\n\nObject\n\n\nNo\n\n\n\n\n\n\n\n\nLimitations\n\n\nCurrent CsvFormatter contain following limitations:\n\n\n\n\nThe field names in schema and the pojo field names should match.For eg. if name of the schema field is \"customerName\", then POJO should contain a field with the same name. \n\n\nField wise validation/formatting is not yet supported.\n\n\nThe fields will be written to the file in the same order as specified in schema.json\n\n\n\n\nExample\n\n\nExample for CsvFormatter can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/csvformatter\n\n\nAdvanced\n\n\n Schema format for CsvFormatter\n\n\nCsvFormatter expects schema to be a String in JSON format:\n\n\nExample for format of schema:\n\n\n{\n  \"separator\": \",\",\n  \"quoteChar\": \"\\\"\",\n  \"lineDelimiter\": \"\\n\",\n  \"fields\": [\n    {\n      \"name\": \"campaignId\",\n      \"type\": \"Integer\"\n    },\n    {\n      \"name\": \"startDate\",\n      \"type\": \"Date\",\n      \"constraints\": {\n        \"format\": \"yyyy-MM-dd\"\n      }\n    }\n    ]\n}\n\n\n\n\nPartitioning of CsvFormatter\n\n\nBeing stateless operator, CsvFormatter will ensure built-in partitioners present in Malhar library can be directly used by setting properties as follows:\n\n\nStateless partioning of CsvFormatter\n\n\nStateless partitioning will ensure that CsvFormatter will be partitioned right at the start of the application and will remain partitioned throughout the lifetime of the DAG.\nCsvFormatter can be stateless partitioned by adding following lines to properties.xml:\n\n\n  <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>\n\n\n\n\nwhere {OperatorName} is the name of the CsvFormatter operator.\nAbove lines will partition CsvFormatter statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partitioning of CsvFormatter\n\n\nDynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain conditions.\nCsvFormatter can be dynamically partitioned using below out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partition CsvFormatter:\n\n\n    StatelessThroughputBasedPartitioner<CsvFormatter> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(csvFormatter, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(csvFormatter, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition CsvFormatter when throughput changes.\nIf overall throughput of CsvFormatter goes beyond 30000 or less than 10000, the platform will repartition CsvFormatter \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as threshold time for which  throughput change is observed.",
            "title": "CSV Formatter"
        },
        {
            "location": "/operators/csvformatter/#csvformatter",
            "text": "",
            "title": "CsvFormatter"
        },
        {
            "location": "/operators/csvformatter/#operator-objective",
            "text": "This operator receives a POJO ( Plain Old Java Object ) as an incoming tuple, converts the data in \nthe incoming POJO to a custom delimited string and emits the delimited string.  CsvFormatter supports schema definition as a JSON string.   CsvFormatter does not hold any state and is  idempotent ,  fault-tolerant  and  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/csvformatter/#operator-information",
            "text": "Operator location:  malhar-contrib  Available since:  3.2.0  Operator state:  Evolving  Java Packages:  Operator:  com.datatorrent.contrib.formatter.CsvFormatter",
            "title": "Operator Information"
        },
        {
            "location": "/operators/csvformatter/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/csvformatter/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      in.TUPLE_CLASS  TUPLE_CLASS attribute on input port which tells operator the class of POJO which will be incoming  Class or FQCN  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/csvformatter/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples which need to be formatted are received on this port  Object (POJO)  Yes    out  Tuples that are formatted are emitted from this port  String  No    err  Tuples that could not be converted are emitted on this port  Object  No",
            "title": "Ports"
        },
        {
            "location": "/operators/csvformatter/#limitations",
            "text": "Current CsvFormatter contain following limitations:   The field names in schema and the pojo field names should match.For eg. if name of the schema field is \"customerName\", then POJO should contain a field with the same name.   Field wise validation/formatting is not yet supported.  The fields will be written to the file in the same order as specified in schema.json",
            "title": "Limitations"
        },
        {
            "location": "/operators/csvformatter/#example",
            "text": "Example for CsvFormatter can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/csvformatter",
            "title": "Example"
        },
        {
            "location": "/operators/csvformatter/#advanced",
            "text": "",
            "title": "Advanced"
        },
        {
            "location": "/operators/csvformatter/#partitioning-of-csvformatter",
            "text": "Being stateless operator, CsvFormatter will ensure built-in partitioners present in Malhar library can be directly used by setting properties as follows:",
            "title": "Partitioning of CsvFormatter"
        },
        {
            "location": "/operators/csvformatter/#stateless-partioning-of-csvformatter",
            "text": "Stateless partitioning will ensure that CsvFormatter will be partitioned right at the start of the application and will remain partitioned throughout the lifetime of the DAG.\nCsvFormatter can be stateless partitioned by adding following lines to properties.xml:    <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>  where {OperatorName} is the name of the CsvFormatter operator.\nAbove lines will partition CsvFormatter statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Stateless partioning of CsvFormatter"
        },
        {
            "location": "/operators/csvformatter/#dynamic-partitioning-of-csvformatter",
            "text": "Dynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain conditions.\nCsvFormatter can be dynamically partitioned using below out-of-the-box partitioner:",
            "title": "Dynamic Partitioning of CsvFormatter"
        },
        {
            "location": "/operators/csvformatter/#throughput-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partition CsvFormatter:      StatelessThroughputBasedPartitioner<CsvFormatter> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(csvFormatter, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(csvFormatter, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition CsvFormatter when throughput changes.\nIf overall throughput of CsvFormatter goes beyond 30000 or less than 10000, the platform will repartition CsvFormatter \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as threshold time for which  throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/csvParserOperator/",
            "text": "Csv Parser Operator\n\n\nOperator Objective\n\n\nThis operator is designed to parse delimited records and construct a map or concrete java class also known as \n\"POJO\"\n out of it. User need to provide the schema to describe the delimited data. Based on schema definition the operator will parse the incoming record to object map and POJO.  User can also provide constraints if any, in the schema. The supported constraints are listed in \nconstraints table\n. The incoming record will be validated against those constraints. Valid records will be emitted as POJO / map while invalid ones are emitted on error port with error message.\n\n\nNote\n: field names of POJO must match field names in schema and in the same order as it appears in the incoming data.\n\n\nOverview\n\n\nThe operator is \nidempotent\n, \nfault-tolerant\n and \npartitionable\n.\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location:\nmalhar-contrib\n\n\nAvailable since:\n3.2.0\n\n\nOperator state:\nEvolving\n\n\nJava Package:\ncom.datatorrent.contrib.parser.CsvParser\n\n\n\n\nProperties of Csv Parser\n\n\nUser need to set the schema which describes delimited data as well as specifies constraints on values if any.\ne.g.\n\n\n{\n  \"separator\":\",\",\n  \"quoteChar\":\"\\\"\",\n  \"fields\":[\n    {\n      \"name\":\"adId\",\n      \"type\":\"Integer\",\n      \"constraints\":{\n         \"required\":\"true\"\n      }\n    },\n    {\n      \"name\":\"adName\",\n      \"type\":\"String\",\n      \"constraints\":{\n         \"required\":\"true\",\n         \"pattern\":\"[a-z].*[a-z]$\",\n         \"maxLength\":\"10\"\n      }\n    },\n    {\n      \"name\":\"bidPrice\",\n      \"type\":\"Double\",\n      \"constraints\":{\n         \"required\":\"true\",\n         \"minValue\":\"0.1\",\n         \"maxValue\":\"3.2\"\n      }\n    },\n    {\n      \"name\":\"startDate\",\n      \"type\":\"Date\",\n      \"constraints\":{\n         \"format\":\"yyyy-MM-dd HH:mm:ss\"\n      }\n    }\n  ]\n}\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nSchema\n  describing delimited data\n\n\nString\n\n\nYES\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nout.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted\n\n\nClass\n\n\nYes\n\n\n\n\n\n\n\n\nSupported DataTypes in Schema\n\n\n\n\nInteger\n\n\nLong\n\n\nDouble\n\n\nCharacter\n\n\nString\n\n\nBoolean\n\n\nDate\n\n\nFloat\n\n\n\n\nSchema Constraints\n\n\n\n\n\n\n\n\nDataType\n\n\nConstraints\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAll data Types\n\n\nrequired\n\n\nIf mentioned, indicates that the data type constraints that follow are required. It cannot be blank/null. It may or may not satisfy other constraints ( like equals/minVal/maxVal etc )\n\n\n\n\n\n\nAll data Types\n\n\nequals\n\n\nIf mentioned, indicates that the data string or value declared in the data type constraints must be an exact match with the specified value. \nNote: This constraints is not applicable for data type boolean and date\n\n\n\n\n\n\nString\n\n\nLength\n\n\nThe string must be of the length that is specified.\n\n\n\n\n\n\nString\n\n\nminLength\n\n\nThe string is at least the length specified as minLength value.\n\n\n\n\n\n\nString\n\n\nmaxLength\n\n\nThe string can be at the most the length specified as maxLength value.\n\n\n\n\n\n\nString\n\n\npattern\n\n\nThe string must match the specified regular expression.\n\n\n\n\n\n\nLong\n\n\nmaxValue\n\n\nThe numeric can be at the most the value specified as maxValue.\n\n\n\n\n\n\nLong\n\n\nminValue\n\n\nThe numeric is at least the value specified as minValue.\n\n\n\n\n\n\nDouble\n\n\nmaxValue\n\n\nThe numeric can be at the most the value specified as maxValue.\n\n\n\n\n\n\nDouble\n\n\nminValue\n\n\nThe numeric is at least the value specified as minValue.\n\n\n\n\n\n\nFloat\n\n\nmaxValue\n\n\nThe numeric can be at the most the value specified as maxValue.\n\n\n\n\n\n\nFloat\n\n\nminValue\n\n\nThe numeric is at least the value specified as minValue.\n\n\n\n\n\n\nInteger\n\n\nmaxValue\n\n\nThe numeric can be at the most the value specified as maxValue.\n\n\n\n\n\n\nInteger\n\n\nminValue\n\n\nThe numeric is at least the value specified as minValue.\n\n\n\n\n\n\nDate\n\n\nformat\n\n\nA simple date format as specified in the SimpleDateFormat class: http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html?is-external=true\n\n\n\n\n\n\nBoolean\n\n\ntrueValue\n\n\nString for which boolean value is true. The default values are: true, 1, y, and t. \nNote: If you specify trueValue, you must also specify falseValue.\n\n\n\n\n\n\nBoolean\n\n\nfalseValue\n\n\nString for which boolean value is false. The default values are: false, 0, n, and f. \nNote: If you specify falseValue, you must also specify trueValue.\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be parsed are recieved on this port\n\n\nbyte[]\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid Tuples that are emitted as pojo\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nparsedOutput\n\n\nValid Tuples that are emitted as map\n\n\nMap\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid Tuples are emitted with error message\n\n\nKeyValPair <String, String>\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nCSV Parser is both statically and dynamically partitionable.\n\n\nStatic Partitioning\n\n\nThis can be achieved in 2 ways as shown below.\n\n\nSpecifying the partitioner and number of partitions in the populateDAG() method\n\n\n    CsvParser csvParser = dag.addOperator(\"csvParser\", CsvParser.class);\n    StatelessPartitioner<CsvParser> partitioner1 = new StatelessPartitioner<CsvParser>(2);\n    dag.setAttribute(csvParser, Context.OperatorContext.PARTITIONER, partitioner1);\n\n\n\n\nSpecifying the partitioner in properties file.\n\n\n   <property>\n     <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n     <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n   </property>\n\n\n\n\nwhere {OperatorName} is the name of the CsvParser operator.\n Above lines will partition CsvParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Paritioning\n\n\nCsvParser can be dynamically partitioned using out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partition CsvParser:\n\n\nCsvParser csvParser = dag.addOperator(\"csvParser\", CsvParser.class);\nStatelessThroughputBasedPartitioner<CsvParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(csvParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(csvParser, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition csvParser when the throughput changes.\nIf the overall throughput of csvParser goes beyond 30000 or less than 10000, the platform will repartition CsvParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nExample for Csv Parser can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "CSV Parser"
        },
        {
            "location": "/operators/csvParserOperator/#csv-parser-operator",
            "text": "",
            "title": "Csv Parser Operator"
        },
        {
            "location": "/operators/csvParserOperator/#operator-objective",
            "text": "This operator is designed to parse delimited records and construct a map or concrete java class also known as  \"POJO\"  out of it. User need to provide the schema to describe the delimited data. Based on schema definition the operator will parse the incoming record to object map and POJO.  User can also provide constraints if any, in the schema. The supported constraints are listed in  constraints table . The incoming record will be validated against those constraints. Valid records will be emitted as POJO / map while invalid ones are emitted on error port with error message.  Note : field names of POJO must match field names in schema and in the same order as it appears in the incoming data.",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/csvParserOperator/#overview",
            "text": "The operator is  idempotent ,  fault-tolerant  and  partitionable .",
            "title": "Overview"
        },
        {
            "location": "/operators/csvParserOperator/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/csvParserOperator/#operator-information",
            "text": "Operator location: malhar-contrib  Available since: 3.2.0  Operator state: Evolving  Java Package: com.datatorrent.contrib.parser.CsvParser",
            "title": "Operator Information"
        },
        {
            "location": "/operators/csvParserOperator/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      out.TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted  Class  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/csvParserOperator/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be parsed are recieved on this port  byte[]  Yes    out  Valid Tuples that are emitted as pojo  Object (POJO)  No    parsedOutput  Valid Tuples that are emitted as map  Map  No    err  Invalid Tuples are emitted with error message  KeyValPair <String, String>  No",
            "title": "Ports"
        },
        {
            "location": "/operators/csvParserOperator/#partitioning",
            "text": "CSV Parser is both statically and dynamically partitionable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/csvParserOperator/#static-partitioning",
            "text": "This can be achieved in 2 ways as shown below.  Specifying the partitioner and number of partitions in the populateDAG() method      CsvParser csvParser = dag.addOperator(\"csvParser\", CsvParser.class);\n    StatelessPartitioner<CsvParser> partitioner1 = new StatelessPartitioner<CsvParser>(2);\n    dag.setAttribute(csvParser, Context.OperatorContext.PARTITIONER, partitioner1);  Specifying the partitioner in properties file.     <property>\n     <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n     <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n   </property>  where {OperatorName} is the name of the CsvParser operator.\n Above lines will partition CsvParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/csvParserOperator/#dynamic-paritioning",
            "text": "CsvParser can be dynamically partitioned using out-of-the-box partitioner:",
            "title": "Dynamic Paritioning"
        },
        {
            "location": "/operators/csvParserOperator/#throughput-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partition CsvParser:  CsvParser csvParser = dag.addOperator(\"csvParser\", CsvParser.class);\nStatelessThroughputBasedPartitioner<CsvParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(csvParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(csvParser, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition csvParser when the throughput changes.\nIf the overall throughput of csvParser goes beyond 30000 or less than 10000, the platform will repartition CsvParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/csvParserOperator/#example",
            "text": "Example for Csv Parser can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Example"
        },
        {
            "location": "/operators/deduper/",
            "text": "Deduper - Operator Documentation\n\n\nIntroduction\n\n\nAbout this document\n\n\nThis document is intended as a guide for understanding and using\nthe Dedup operator.\n\n\nTerminology\n\n\nWe will refer to this operator as the Deduper or Dedup operator\ninterchangeably.\n\n\nOverview\n\n\nDedup - \u201cWhat\u201d in a Nutshell\n\n\nDedup is actually short for Deduplication. Duplicates are omnipresent and\ncan be found in almost any kind of data. Most of the times it is\nessential to discard, or at the very least separate out the data into\nunique\u00a0and duplicate\u00a0components. The entire purpose of this\noperator is to de-duplicate data. In other words, when data passes\nthrough this operator, it will be segregated into two different data\nsets, one of which contains all unique tuples, and the other which are\noccurring more than once in the original data set.\n\n\n\n\nDedup - \u201cHow\u201d in a Nutshell\n\n\nIn order to quickly decide whether an incoming tuple is duplicate\nor unique, it has to store each incoming tuple (or a signature, like key,\nfor example) to be used for comparison later. A plain in-memory storage\nmay work for small datasets, but will not scale for large ones. Deduper employs a large scale distributed persistent hashing mechanism (known as the Managed State) which allows\nit to identify if a particular tuple is duplicate or unique. Managed state is a layer on HDFS which allows all the stored data to be persisted in a distributed fashion.\nEach time it identifies a tuple as a unique tuple, it also\nstores it into the Managed state for future\nlookup.\n\n\n\n\nFollowing are the different components of the Deduper\n\n\n\n\nDedup Operator\n - This is responsible for the overall\n    functionality of the operator. This in turn makes use of other\n    components to establish the end goal of deciding whether a tuple is\n    a duplicate of some earlier tuple, or is a unique tuple.\n\n\nManaged State\n - Since, all of the data cannot be stored in\n    memory, this component allows us to persist existing unique keys on\n    HDFS in form of buckets. This is also responsible for fetching data as\n    requested by the Deduper. Since, it communicates with the HDFS, data access is slow and so it allows for asynchronous (non-blocking) calls to fetch data. This ensures that the Deduper is not blocked and can continue to process other tuples. It also supports an in-memory cache where it stores the fetched data so that repeated access to the same data is faster. Periodically, based on configuration, this also\n    discards data which is no longer needed.\n\n\n\n\nThis was a very basic introduction to the functioning of the\nDeduper. Following sections will go into more detail on each of the\ncomponents.\n\n\nUse cases - Basic Dedup\n\n\nDedup Key\n\n\nA dedup key is a set of one or more fields in the data tuple which\nacts as the key\u00a0for the tuples.\nThis is used by the deduper to compare tuples to arrive at the\nconclusion on whether two tuples are duplicates.\n\n\nConsider an example schema and two sample tuples\n\n\n{Name, Phone, Email, Date, State, Zip, Country}\n\n\nTuple 1:\n\n\n{\n  Austin U. Saunders,\n  +91-319-340-59385,\n  ausaunders@semperegestasurna.com,\n  2015-11-09 13:38:38,\n  Texas,\n  73301,\n  United States\n}\n\n\n\n\nTuple 2:\n\n\n{\n  Austin U. Saunders,\n  +91-319-340-59385,\n  austin@semperegestasurna.com,\n  2015-11-09 13:39:38,\n  Texas,\n  73301,\n  United States\n}\n\n\n\n\nLet us assume that the Dedup Key\nis \n{Name, Phone}\n. In\nthis case, the two tuples are duplicates because the key fields are same\nin both the tuples. However, if the Dedup Key is {Phone,Email},\nthe two are unique as the email values differ.\n\n\nUse case Details\n\n\nConsider the case of de-duplicating a master data set\nwhich is stored in a file.\u00a0Further also consider the\nfollowing schema for tuples in the data set.\n\n\n{Name, Phone, Email, Date, City, Zip, Country}\n\n\nAlso consider that we need to identify unique customers from the\nmaster data set. So, ultimately the output needed for the use case is\ntwo data sets - Unique Records\u00a0and Duplicate Records.\n\n\nAs part of configuring the operator for this use case, we need to\nset the following parameters:\n\n\n\n\nkeyExpression\n\u00a0- This can be set as\n    the primary key which can be used to uniquely identify a Customer.\n    For example, we can set it to \nName,Email\n\n\n\n\nThe above configuration is sufficient to address this use case.\n\n\nUse case - Dedup with Expiry\n\n\nMotivation\n\n\nThe Basic Dedup use case is the most straightforward and is\nusually applied when the amount of data to be processed is not huge.\nHowever, if the incoming data is huge, or even never-ending, it is\nusually not necessary to keep storing all the data. This is because in\nmost real world use cases, the duplicates occur only a short distance\napart. Hence, after a while, it is usually okay to forget part of\nthe history and consider only limited history for identifying\nduplicates, in the interest of efficiency. In other words, we expire\n(ignore) some tuples which are (or were supposed to be) delivered long\nback. Doing so, reduces the load on the storage mechanism (managed state) which effectively deletes part of the history, thus making the whole process more\nefficient. We call this use case, Dedup with expiry.\n\n\nExpiry Key\n\n\nThe easiest way to understand this use case is to consider\ntime\u00a0as the criterion for expiring\ntuples. Time\u00a0is a natural expiry\nkey and is in line with the concept of expiry. Formally, an expiry field\nis a field in the input tuple which can be used to discard incoming\ntuples as expired. This expiry key\nusually works with another parameter called Expiry Period defined\nnext.\n\n\nExpiry Period\n\n\nThe expiry period is the value supplied by the user to define the\nextent of history which should be considered while expiring\ntuples.\n\n\nUse case Details\n\n\nConsider an incoming stream of system logs. The use case requires\nus to identify duplicate log messages and pass on only the unique ones.\nAnother relaxation in the use case is that the log messages which are\nolder than a day, may not be considered and must be filtered out as\nexpired. The expiry must be measured with respect to the time stamp in\nthe logs. For example, if the timestamp in the incoming message is\n\n30-12-2014 00:00:00\n and the\nlatest message that the system has encountered had the time stamp\n\n31-12-2014 00:00:00\n, then the\nincoming message must be considered as expired. However, if the incoming\nmessage had any timestamp like \n30-12-2014\n00:11:00\n, it must be accepted into the system and be checked for a possible duplicate.\n\n\nThe expiry facet in the use case above gives us an advantage in\nthat we do not have to compare the incoming record with all\u00a0the data to check if it is a duplicate.\nAt the same time, all\u00a0the\nincoming data need not be stored; just a day worth of data is adequate to address the above use case.\n\n\nConfiguring the below parameters will solve the problem for this\nuse case:\n\n\n\n\nkeyExpression\n\u00a0- This is the dedup key for the incoming tuples (similar to the Basic Dedup use case). This can be any key which can uniquely identify a record. For log messages this can be a serial number attached in the log.\n\n\ntimeExpression\n\u00a0- This is the key which can help identify the expired records, as explained above. In this particular use case, it can be a timestamp field which indicates when the log message was generated.\n\n\nexpireBefore\n\u00a0- This is the period of expiry as explained above. In our example use case this will be 24 hour, specified in seconds.\n\n\n\n\nConfiguration of the above parameters is sufficient to address this use\ncase.\n\n\nUse cases - Summary\n\n\n\n\nBasic Dedup\n - Deduplication of\n    bounded datasets. Data is assumed to be bounded. This use case is\n    not meant for never ending streams of data. For example:\n    Deduplication of master data like customer records, product catalogs\n    etc.\n\n\nTime Based Dedup\n\u00a0- Deduplication of\n    unlimited streams of data. This use case handles unbounded streams\n    of data and can run forever. An expiry key and criterion is expected\n    as part of the input which helps avoid storing all the unique data.\n    This helps speed up performance. Any timestamp field in the incoming\n    tuple can be used as a time based expiry key.\n\n\nWith respect to system time\n\u00a0- Time progresses with system time. Any expiry criteria are executed with the notion of system time. This is possible if the incoming tuple does not have a time field, or the user does not specify a \ntimeExpression\n.\n\n\nWith respect to tuple time\n\u00a0- Time progresses based on the time in the incoming tuples. Expiry criteria are executed with the notion of time indicated by the incoming tuple. Specification of the time field (\ntimeExpression\n) is mandatory for this scenario.\n\n\n\n\n\n\n\n\nTechnical Architecture\n\n\nClass Structure\n\n\n\n\n\n\nArchitectural Details\n\n\n\n\nConcepts\n\n\nDedup Key - Specified by \nkeyExpression\n\u00a0parameter\n\n\nA dedup key is a set of one or more fields in the data tuple which\nacts as the key\u00a0for the tuples.\nThis is used by the deduper to compare tuples to arrive at the\nconclusion on whether two tuples are duplicates. If Dedup Key of two\ntuples match, then they are duplicates, else they are unique.\n\n\nExpiry Key - Specified by \ntimeExpression\n\u00a0parameter\n\n\nA tuple may or may not have an Expiry Key. Dedup operator cannot\nkeep storing all the data that is flowing into the operator. At some\npoint it becomes essential to discard some of the historical tuples in\ninterest of memory and efficiency.\n\n\nAt the same time, tuples are expected to arrive at the Dedup\noperator within some time after they are generated. After this time, the\ntuples may be considered as stale or obsolete.\n\n\nIn such cases, the Deduper considers these tuples as\nexpired\u00a0and takes no action other than\nseparating out these tuples on a different port in order to be processed\nby some other operator or stored offline for analysis.\n\n\nIn order to create a criterion for discarding such tuples, we\nintroduce an Expiry Key. Looking at the value of the Expiry Key in each\ntuple, we can decide whether or not to discard this tuple as\nexpired.\n\n\nThe expiry key that we consider in Time Based Dedup is\ntime. This usually works with\nanother parameter called Expiry Period defined next.\n\n\nExpiry Period\n\n\nThe Expiry Period is the value supplied by the user which decides\nwhen a particular tuple expires.\n\n\nTime Points\n\n\nFor every dataset that the deduper processes, a set of time points is maintained:\n\n\n\n\nLatest Point\n\u00a0- This is the maximum\n    time point observed in all the processed tuples.\n\n\nExpiry Point\n\u00a0- This is given by:\n    \nExpiry Point = Latest Point - Expiry Period\n\n\n\n\nThese points help the deduper to make decisions related to expiry\nof a tuple.\n\n\nExample - Expiry\n\n\n\n\n\n\n\n\nTuple Id\n\n\nExpiry Key (Expiry Period = 10)\n\n\nLatest Point\n\n\nExpiry Point\n\n\nDecision for Tuple\n\n\n\n\n\n\n\n\n\n\n1\n\n\n10\n\n\n10\n\n\n1\n\n\nNot Expired\n\n\n\n\n\n\n2\n\n\n20\n\n\n20\n\n\n11\n\n\nNot Expired\n\n\n\n\n\n\n3\n\n\n25\n\n\n25\n\n\n16\n\n\nNot Expired\n\n\n\n\n\n\n4\n\n\n40\n\n\n40\n\n\n31\n\n\nNot Expired\n\n\n\n\n\n\n5\n\n\n21\n\n\n40\n\n\n31\n\n\nExpired\n\n\n\n\n\n\n6\n\n\n35\n\n\n40\n\n\n31\n\n\nNot Expired\n\n\n\n\n\n\n7\n\n\n45\n\n\n45\n\n\n36\n\n\nNot Expired\n\n\n\n\n\n\n8\n\n\n57\n\n\n57\n\n\n48\n\n\nNot Expired\n\n\n\n\n\n\n\n\nTime Buckets (A component of Managed State)\n\n\nOne of the requirements of the Deduper is to store all the unique\ntuples (actually, just the keys of tuples). Keeping an ever growing\ncache in memory is not scalable. So what we need is a limited cache\nbacked by a persistent store. When data is requested to be fetched from managed\nstate, it is also cached in an in-memory cache. Buckets help\nnarrow down the search of duplicates for incoming tuples. A Bucket is an\nabstraction for a collection of tuples all of which share a common hash\nvalue based on some hash function or a range of time, for example: a\nbucket of data for 5 contiguous minutes. A Bucket\u00a0has a span property called Bucket Span.\n\n\nBucket Span\n\n\nBucket span is simply the range of the domain\nthat is covered by the Bucket. This span is specified in\nthe domain of the Expiry key. If the Expiry\nKey is time, \u00a0then the Bucket span\nwill be specified in seconds. It is\nonly defined in case tuples have an Expiry Key.\n\n\nNumber of Buckets\n\n\nThe number of buckets can be given by - \nNum Buckets = Expiry\nPeriod / Bucket Span\n\n\nThis is because at any point of time, we need only store Expiry\nPeriod worth of data.\n\n\nExample - Buckets\n\n\n\n\nAssumptions\n\n\nAssumption 1 \n\n\nThis assumption is only applicable in case of Dedup with\nExpiry.\n\n\nFor any two tuples, t1 and t2 having dedup keys d1 and d2, and\nexpiry keys e1 and e2, respectively, the following holds:\n\n\nIf d1 = d2,\n  then e1 = e2\n\n\n\n\nIn other words, there may never\nbe\u00a0two tuples t1 and t2 such that:\n\n\nTuple 1: d1, e1\nTuple 2: d2, e2\nd1 = d2 and e1 != e2\n\n\n\n\nIn other words, any two tuples with the same dedup key are assumed to have the\nsame expiry key as well.\nThis assumption was made with respect to certain use cases. These\nuse cases follow this assumption in that the records which are\nduplicates are exactly identical. An example use case is when log\nmessages are replayed erroneously, and we want to identify the duplicate\nlog messages. In such cases, we need not worry about two different log\nmessages having the same identifier but different timestamps. Since its\na replay of the same data, the duplicate records are assumed to be\nexactly identical.\n\n\nIn case the duplicate tuple has a different value for expiry key, the behavior of\nthe deduper can be non-deterministic.\n\n\nFlow of a Tuple through Dedup Operator\n\n\nTuples flow through the Dedup operator one by one. Deduper may process a tuple immediately, or store it in some data\nstructure for later processing.\n\n\nWhen a tuple always arrives at the input\nport\u00a0of the Dedup operator, it does\nthe following tasks.\n\n\nCheck if tuple is Expired\n\n\nThis is only done in case of Dedup with expiry. The\nfollowing condition is used to check if the tuple is expired.\n\n\nif ( Latest Point - Expiry Key < Expiry Point )\n  then Expired\n\n\n\n\nIf the tuple is expired, then send it to the expired port.\n\n\nCheck if tuple is a Duplicate or Unique\n\n\nOnce a tuple passes the check of expiry, we proceed to check if\nthe tuple is a duplicate of some earlier tuple. Note that\nif the tuple in question is not expired, the duplicate will also not\nhave expired due to the assumption listed \nhere\n.\nThe Deduper queries the Managed state to fetch the value for the tuple key.\nThis request is processed by the Managed state in a separate asynchronous thread.\nOnce this request is submitted, the Deduper moves on to process other\ntuples. Additionally the Deduper also inserts the tuple being processed\ninto a waiting events\u00a0queue for later processing.\n\n\nProcess pending tuples\n\n\nOnce the Deduper has looked at the all the tuples in the current window,\nit starts to process the tuples in the waiting queue to finalize the decision\n(unique or duplicate) for these tuples.\nOnce the request to Managed state is completed for a tuple and the value is\nfetched from persistent storage, the Deduper can decide if the tuple in\nquestion is a duplicate or a unique.\nDepending on whether there is enough time left in the current window,\nit can do one of the following:\n\n\n\n\nProcess only the tuples for which the managed state has completed processing.\nThe tuples which are still being processed by managed state are skipped only to come back to them when it can no longer postpone it. This is typically done when the operator\nhas idle time as there are no tuples on the input ports and the current window\nhas still not ended.\n\n\nBlock on them to complete their processing. This will happen when the current\nwindow has no time left, and the decision cannot be postponed. Note: An operator can end its window, only when all the tuples have been completely processed.  \n\n\n\n\nPorts, Attributes and Properties\n\n\nPorts\n\n\nThe deduper has a single input port and multiple output\nports.\n\n\n\n\ninput\n - This is the input port through\n    which the tuples arrive at the Deduper.\n\n\nunique\n\u00a0- This is the output port on\n    which unique tuples are sent out by the Deduper.\n\n\nduplicate\n\u00a0- This is the output port on\n    which duplicate tuples are sent out by the Deduper.\n\n\nexpired\n\u00a0- This is the output port on\n    which expired tuples are sent out by the Deduper.\n\n\n\n\nThe user can choose which output ports to connect the down stream operators.\nAll the output ports are optional and can be used as required by the use case.\n\n\nAttributes\n\n\n\n\nInput port Attribute - input.TUPLE_CLASS\n\u00a0- Class or the fully\nqualified class name.\n\n\nMandatory attribute\n\n\nTells the operator about the type of the incoming\ntuple.\n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\nkeyExpression\n\u00a0- String\n\n\n\n\nMandatory parameter.\n\n\nThe java expression to extract the key fields in the incoming tuple (POJO)\n\n\n\n\n\n\n\n\ntimeExpression\n\u00a0- String - (Time Based Deduper only)\n\n\n\n\nThe java expression to extract the time field in the incoming tuple (POJO).\n\n\n\n\n\n\n\n\nexpireBefore\n\u00a0- Long (Seconds) - (Time Based Deduper only)\n\n\n\n\nThis is the total time period during which a tuple stays in the system and blocks any other tuple with the same key.\n\n\n\n\n\n\n\n\nbucketSpan\n\u00a0- Long (Seconds) - (Time Based Deduper only)\n\n\n\n\nMandatory parameter\n\n\nThis is the unit which describes how large a bucket can be. Typically this should be defined depending on the use case. For example, if we have expireBefore set to 1 hour, then typically we would be clubbing data in the order of minutes, so a \nbucketSpan\n of a few minutes would make sense. Note that in this case, the entire data worth the \nbucketSpan\n will expire as a whole. Setting it to 1 minute would make the number of time buckets in the system to be 1 hour / 1 minute = 60 buckets.  Similarly setting bucketSpan to 5 minutes would make number of buckets to be 12.\n\n\nNote that having too many or too few buckets could have a performance impact. If unsure, set the bucketSpan to the square root of \nexpireBefore\n. This way the number of buckets and bucket span are balanced.\n\n\n\n\n\n\n\n\nreferenceInstant\n\u00a0- \u00a0Long (Seconds) - (Time Based Deduper only)\n\n\n\n\nThe reference point from which to start the time which is use for expiry. Setting the referenceInstant to say, r seconds from the epoch, would initialize the start of expiry to be from that \ninstant = r\n. The start and end of the expiry window periodically move by the span of a single bucket.\n\n\n\n\n\n\n\n\nnumBuckets\n\u00a0- \u00a0Integer - (Bounded Deduper only)\n\n\n\n\nOptional parameter, but recommended to be provided by the user.\n\n\nThis is the number of buckets that need to be used for storing the keys of the incoming tuples.\n\n\nUsers can decide upon the proper value for this parameter by guessing the number of distinct keys in the application. A reasonable value is the square root of N, where N is the number of distinct keys. If omitted, the Java MAX_VALUE for integer is used for N.\n\n\n\n\n\n\n\n\nExample\n\n\nPlease refer to \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/dedup\n\u00a0for\nan example on how to use Deduper.\n\n\nPartitioning\n\n\nDeduper can be statically partitioned using the operator\nattribute: PARTITIONER\n\n\nAdd the following property to the properties.xml file:\n\n\n<property>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n</property>\n\n\n\n\nThis will partition the Dedup operator into 2 static partitions. Change the number\nto the required number of partitions.\n\n\nDynamic partitioning is currently not supported in the Deduper.",
            "title": "Deduper"
        },
        {
            "location": "/operators/deduper/#deduper-operator-documentation",
            "text": "",
            "title": "Deduper - Operator Documentation"
        },
        {
            "location": "/operators/deduper/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/operators/deduper/#about-this-document",
            "text": "This document is intended as a guide for understanding and using\nthe Dedup operator.",
            "title": "About this document"
        },
        {
            "location": "/operators/deduper/#terminology",
            "text": "We will refer to this operator as the Deduper or Dedup operator\ninterchangeably.",
            "title": "Terminology"
        },
        {
            "location": "/operators/deduper/#overview",
            "text": "",
            "title": "Overview"
        },
        {
            "location": "/operators/deduper/#dedup-what-in-a-nutshell",
            "text": "Dedup is actually short for Deduplication. Duplicates are omnipresent and\ncan be found in almost any kind of data. Most of the times it is\nessential to discard, or at the very least separate out the data into\nunique\u00a0and duplicate\u00a0components. The entire purpose of this\noperator is to de-duplicate data. In other words, when data passes\nthrough this operator, it will be segregated into two different data\nsets, one of which contains all unique tuples, and the other which are\noccurring more than once in the original data set.",
            "title": "Dedup - \u201cWhat\u201d in a Nutshell"
        },
        {
            "location": "/operators/deduper/#dedup-how-in-a-nutshell",
            "text": "In order to quickly decide whether an incoming tuple is duplicate\nor unique, it has to store each incoming tuple (or a signature, like key,\nfor example) to be used for comparison later. A plain in-memory storage\nmay work for small datasets, but will not scale for large ones. Deduper employs a large scale distributed persistent hashing mechanism (known as the Managed State) which allows\nit to identify if a particular tuple is duplicate or unique. Managed state is a layer on HDFS which allows all the stored data to be persisted in a distributed fashion.\nEach time it identifies a tuple as a unique tuple, it also\nstores it into the Managed state for future\nlookup.",
            "title": "Dedup - \u201cHow\u201d in a Nutshell"
        },
        {
            "location": "/operators/deduper/#use-cases-basic-dedup",
            "text": "",
            "title": "Use cases - Basic Dedup"
        },
        {
            "location": "/operators/deduper/#dedup-key",
            "text": "A dedup key is a set of one or more fields in the data tuple which\nacts as the key\u00a0for the tuples.\nThis is used by the deduper to compare tuples to arrive at the\nconclusion on whether two tuples are duplicates.  Consider an example schema and two sample tuples  {Name, Phone, Email, Date, State, Zip, Country}  Tuple 1:  {\n  Austin U. Saunders,\n  +91-319-340-59385,\n  ausaunders@semperegestasurna.com,\n  2015-11-09 13:38:38,\n  Texas,\n  73301,\n  United States\n}  Tuple 2:  {\n  Austin U. Saunders,\n  +91-319-340-59385,\n  austin@semperegestasurna.com,\n  2015-11-09 13:39:38,\n  Texas,\n  73301,\n  United States\n}  Let us assume that the Dedup Key\nis  {Name, Phone} . In\nthis case, the two tuples are duplicates because the key fields are same\nin both the tuples. However, if the Dedup Key is {Phone,Email},\nthe two are unique as the email values differ.",
            "title": "Dedup Key"
        },
        {
            "location": "/operators/deduper/#use-case-details",
            "text": "Consider the case of de-duplicating a master data set\nwhich is stored in a file.\u00a0Further also consider the\nfollowing schema for tuples in the data set.  {Name, Phone, Email, Date, City, Zip, Country}  Also consider that we need to identify unique customers from the\nmaster data set. So, ultimately the output needed for the use case is\ntwo data sets - Unique Records\u00a0and Duplicate Records.  As part of configuring the operator for this use case, we need to\nset the following parameters:   keyExpression \u00a0- This can be set as\n    the primary key which can be used to uniquely identify a Customer.\n    For example, we can set it to  Name,Email   The above configuration is sufficient to address this use case.",
            "title": "Use case Details"
        },
        {
            "location": "/operators/deduper/#use-case-dedup-with-expiry",
            "text": "",
            "title": "Use case - Dedup with Expiry"
        },
        {
            "location": "/operators/deduper/#motivation",
            "text": "The Basic Dedup use case is the most straightforward and is\nusually applied when the amount of data to be processed is not huge.\nHowever, if the incoming data is huge, or even never-ending, it is\nusually not necessary to keep storing all the data. This is because in\nmost real world use cases, the duplicates occur only a short distance\napart. Hence, after a while, it is usually okay to forget part of\nthe history and consider only limited history for identifying\nduplicates, in the interest of efficiency. In other words, we expire\n(ignore) some tuples which are (or were supposed to be) delivered long\nback. Doing so, reduces the load on the storage mechanism (managed state) which effectively deletes part of the history, thus making the whole process more\nefficient. We call this use case, Dedup with expiry.",
            "title": "Motivation"
        },
        {
            "location": "/operators/deduper/#expiry-key",
            "text": "The easiest way to understand this use case is to consider\ntime\u00a0as the criterion for expiring\ntuples. Time\u00a0is a natural expiry\nkey and is in line with the concept of expiry. Formally, an expiry field\nis a field in the input tuple which can be used to discard incoming\ntuples as expired. This expiry key\nusually works with another parameter called Expiry Period defined\nnext.",
            "title": "Expiry Key"
        },
        {
            "location": "/operators/deduper/#expiry-period",
            "text": "The expiry period is the value supplied by the user to define the\nextent of history which should be considered while expiring\ntuples.",
            "title": "Expiry Period"
        },
        {
            "location": "/operators/deduper/#use-case-details_1",
            "text": "Consider an incoming stream of system logs. The use case requires\nus to identify duplicate log messages and pass on only the unique ones.\nAnother relaxation in the use case is that the log messages which are\nolder than a day, may not be considered and must be filtered out as\nexpired. The expiry must be measured with respect to the time stamp in\nthe logs. For example, if the timestamp in the incoming message is 30-12-2014 00:00:00  and the\nlatest message that the system has encountered had the time stamp 31-12-2014 00:00:00 , then the\nincoming message must be considered as expired. However, if the incoming\nmessage had any timestamp like  30-12-2014\n00:11:00 , it must be accepted into the system and be checked for a possible duplicate.  The expiry facet in the use case above gives us an advantage in\nthat we do not have to compare the incoming record with all\u00a0the data to check if it is a duplicate.\nAt the same time, all\u00a0the\nincoming data need not be stored; just a day worth of data is adequate to address the above use case.  Configuring the below parameters will solve the problem for this\nuse case:   keyExpression \u00a0- This is the dedup key for the incoming tuples (similar to the Basic Dedup use case). This can be any key which can uniquely identify a record. For log messages this can be a serial number attached in the log.  timeExpression \u00a0- This is the key which can help identify the expired records, as explained above. In this particular use case, it can be a timestamp field which indicates when the log message was generated.  expireBefore \u00a0- This is the period of expiry as explained above. In our example use case this will be 24 hour, specified in seconds.   Configuration of the above parameters is sufficient to address this use\ncase.",
            "title": "Use case Details"
        },
        {
            "location": "/operators/deduper/#use-cases-summary",
            "text": "Basic Dedup  - Deduplication of\n    bounded datasets. Data is assumed to be bounded. This use case is\n    not meant for never ending streams of data. For example:\n    Deduplication of master data like customer records, product catalogs\n    etc.  Time Based Dedup \u00a0- Deduplication of\n    unlimited streams of data. This use case handles unbounded streams\n    of data and can run forever. An expiry key and criterion is expected\n    as part of the input which helps avoid storing all the unique data.\n    This helps speed up performance. Any timestamp field in the incoming\n    tuple can be used as a time based expiry key.  With respect to system time \u00a0- Time progresses with system time. Any expiry criteria are executed with the notion of system time. This is possible if the incoming tuple does not have a time field, or the user does not specify a  timeExpression .  With respect to tuple time \u00a0- Time progresses based on the time in the incoming tuples. Expiry criteria are executed with the notion of time indicated by the incoming tuple. Specification of the time field ( timeExpression ) is mandatory for this scenario.",
            "title": "Use cases - Summary"
        },
        {
            "location": "/operators/deduper/#technical-architecture",
            "text": "",
            "title": "Technical Architecture"
        },
        {
            "location": "/operators/deduper/#class-structure",
            "text": "",
            "title": "Class Structure"
        },
        {
            "location": "/operators/deduper/#architectural-details",
            "text": "",
            "title": "Architectural Details"
        },
        {
            "location": "/operators/deduper/#concepts",
            "text": "",
            "title": "Concepts"
        },
        {
            "location": "/operators/deduper/#dedup-key-specified-by-keyexpression-parameter",
            "text": "A dedup key is a set of one or more fields in the data tuple which\nacts as the key\u00a0for the tuples.\nThis is used by the deduper to compare tuples to arrive at the\nconclusion on whether two tuples are duplicates. If Dedup Key of two\ntuples match, then they are duplicates, else they are unique.",
            "title": "Dedup Key - Specified by keyExpression\u00a0parameter"
        },
        {
            "location": "/operators/deduper/#expiry-key-specified-by-timeexpression-parameter",
            "text": "A tuple may or may not have an Expiry Key. Dedup operator cannot\nkeep storing all the data that is flowing into the operator. At some\npoint it becomes essential to discard some of the historical tuples in\ninterest of memory and efficiency.  At the same time, tuples are expected to arrive at the Dedup\noperator within some time after they are generated. After this time, the\ntuples may be considered as stale or obsolete.  In such cases, the Deduper considers these tuples as\nexpired\u00a0and takes no action other than\nseparating out these tuples on a different port in order to be processed\nby some other operator or stored offline for analysis.  In order to create a criterion for discarding such tuples, we\nintroduce an Expiry Key. Looking at the value of the Expiry Key in each\ntuple, we can decide whether or not to discard this tuple as\nexpired.  The expiry key that we consider in Time Based Dedup is\ntime. This usually works with\nanother parameter called Expiry Period defined next.",
            "title": "Expiry Key - Specified by timeExpression\u00a0parameter"
        },
        {
            "location": "/operators/deduper/#expiry-period_1",
            "text": "The Expiry Period is the value supplied by the user which decides\nwhen a particular tuple expires.",
            "title": "Expiry Period"
        },
        {
            "location": "/operators/deduper/#time-points",
            "text": "For every dataset that the deduper processes, a set of time points is maintained:   Latest Point \u00a0- This is the maximum\n    time point observed in all the processed tuples.  Expiry Point \u00a0- This is given by:\n     Expiry Point = Latest Point - Expiry Period   These points help the deduper to make decisions related to expiry\nof a tuple.",
            "title": "Time Points"
        },
        {
            "location": "/operators/deduper/#example-expiry",
            "text": "Tuple Id  Expiry Key (Expiry Period = 10)  Latest Point  Expiry Point  Decision for Tuple      1  10  10  1  Not Expired    2  20  20  11  Not Expired    3  25  25  16  Not Expired    4  40  40  31  Not Expired    5  21  40  31  Expired    6  35  40  31  Not Expired    7  45  45  36  Not Expired    8  57  57  48  Not Expired",
            "title": "Example - Expiry"
        },
        {
            "location": "/operators/deduper/#time-buckets-a-component-of-managed-state",
            "text": "One of the requirements of the Deduper is to store all the unique\ntuples (actually, just the keys of tuples). Keeping an ever growing\ncache in memory is not scalable. So what we need is a limited cache\nbacked by a persistent store. When data is requested to be fetched from managed\nstate, it is also cached in an in-memory cache. Buckets help\nnarrow down the search of duplicates for incoming tuples. A Bucket is an\nabstraction for a collection of tuples all of which share a common hash\nvalue based on some hash function or a range of time, for example: a\nbucket of data for 5 contiguous minutes. A Bucket\u00a0has a span property called Bucket Span.",
            "title": "Time Buckets (A component of Managed State)"
        },
        {
            "location": "/operators/deduper/#bucket-span",
            "text": "Bucket span is simply the range of the domain\nthat is covered by the Bucket. This span is specified in\nthe domain of the Expiry key. If the Expiry\nKey is time, \u00a0then the Bucket span\nwill be specified in seconds. It is\nonly defined in case tuples have an Expiry Key.",
            "title": "Bucket Span"
        },
        {
            "location": "/operators/deduper/#number-of-buckets",
            "text": "The number of buckets can be given by -  Num Buckets = Expiry\nPeriod / Bucket Span  This is because at any point of time, we need only store Expiry\nPeriod worth of data.",
            "title": "Number of Buckets"
        },
        {
            "location": "/operators/deduper/#example-buckets",
            "text": "",
            "title": "Example - Buckets"
        },
        {
            "location": "/operators/deduper/#assumptions",
            "text": "",
            "title": "Assumptions"
        },
        {
            "location": "/operators/deduper/#assumption-1",
            "text": "This assumption is only applicable in case of Dedup with\nExpiry.  For any two tuples, t1 and t2 having dedup keys d1 and d2, and\nexpiry keys e1 and e2, respectively, the following holds:  If d1 = d2,\n  then e1 = e2  In other words, there may never\nbe\u00a0two tuples t1 and t2 such that:  Tuple 1: d1, e1\nTuple 2: d2, e2\nd1 = d2 and e1 != e2  In other words, any two tuples with the same dedup key are assumed to have the\nsame expiry key as well.\nThis assumption was made with respect to certain use cases. These\nuse cases follow this assumption in that the records which are\nduplicates are exactly identical. An example use case is when log\nmessages are replayed erroneously, and we want to identify the duplicate\nlog messages. In such cases, we need not worry about two different log\nmessages having the same identifier but different timestamps. Since its\na replay of the same data, the duplicate records are assumed to be\nexactly identical.  In case the duplicate tuple has a different value for expiry key, the behavior of\nthe deduper can be non-deterministic.",
            "title": "Assumption 1 "
        },
        {
            "location": "/operators/deduper/#flow-of-a-tuple-through-dedup-operator",
            "text": "Tuples flow through the Dedup operator one by one. Deduper may process a tuple immediately, or store it in some data\nstructure for later processing.  When a tuple always arrives at the input\nport\u00a0of the Dedup operator, it does\nthe following tasks.",
            "title": "Flow of a Tuple through Dedup Operator"
        },
        {
            "location": "/operators/deduper/#check-if-tuple-is-expired",
            "text": "This is only done in case of Dedup with expiry. The\nfollowing condition is used to check if the tuple is expired.  if ( Latest Point - Expiry Key < Expiry Point )\n  then Expired  If the tuple is expired, then send it to the expired port.",
            "title": "Check if tuple is Expired"
        },
        {
            "location": "/operators/deduper/#check-if-tuple-is-a-duplicate-or-unique",
            "text": "Once a tuple passes the check of expiry, we proceed to check if\nthe tuple is a duplicate of some earlier tuple. Note that\nif the tuple in question is not expired, the duplicate will also not\nhave expired due to the assumption listed  here .\nThe Deduper queries the Managed state to fetch the value for the tuple key.\nThis request is processed by the Managed state in a separate asynchronous thread.\nOnce this request is submitted, the Deduper moves on to process other\ntuples. Additionally the Deduper also inserts the tuple being processed\ninto a waiting events\u00a0queue for later processing.",
            "title": "Check if tuple is a Duplicate or Unique"
        },
        {
            "location": "/operators/deduper/#process-pending-tuples",
            "text": "Once the Deduper has looked at the all the tuples in the current window,\nit starts to process the tuples in the waiting queue to finalize the decision\n(unique or duplicate) for these tuples.\nOnce the request to Managed state is completed for a tuple and the value is\nfetched from persistent storage, the Deduper can decide if the tuple in\nquestion is a duplicate or a unique.\nDepending on whether there is enough time left in the current window,\nit can do one of the following:   Process only the tuples for which the managed state has completed processing.\nThe tuples which are still being processed by managed state are skipped only to come back to them when it can no longer postpone it. This is typically done when the operator\nhas idle time as there are no tuples on the input ports and the current window\nhas still not ended.  Block on them to complete their processing. This will happen when the current\nwindow has no time left, and the decision cannot be postponed. Note: An operator can end its window, only when all the tuples have been completely processed.",
            "title": "Process pending tuples"
        },
        {
            "location": "/operators/deduper/#ports-attributes-and-properties",
            "text": "",
            "title": "Ports, Attributes and Properties"
        },
        {
            "location": "/operators/deduper/#ports",
            "text": "The deduper has a single input port and multiple output\nports.   input  - This is the input port through\n    which the tuples arrive at the Deduper.  unique \u00a0- This is the output port on\n    which unique tuples are sent out by the Deduper.  duplicate \u00a0- This is the output port on\n    which duplicate tuples are sent out by the Deduper.  expired \u00a0- This is the output port on\n    which expired tuples are sent out by the Deduper.   The user can choose which output ports to connect the down stream operators.\nAll the output ports are optional and can be used as required by the use case.",
            "title": "Ports"
        },
        {
            "location": "/operators/deduper/#attributes",
            "text": "Input port Attribute - input.TUPLE_CLASS \u00a0- Class or the fully\nqualified class name.  Mandatory attribute  Tells the operator about the type of the incoming\ntuple.",
            "title": "Attributes"
        },
        {
            "location": "/operators/deduper/#properties",
            "text": "keyExpression \u00a0- String   Mandatory parameter.  The java expression to extract the key fields in the incoming tuple (POJO)     timeExpression \u00a0- String - (Time Based Deduper only)   The java expression to extract the time field in the incoming tuple (POJO).     expireBefore \u00a0- Long (Seconds) - (Time Based Deduper only)   This is the total time period during which a tuple stays in the system and blocks any other tuple with the same key.     bucketSpan \u00a0- Long (Seconds) - (Time Based Deduper only)   Mandatory parameter  This is the unit which describes how large a bucket can be. Typically this should be defined depending on the use case. For example, if we have expireBefore set to 1 hour, then typically we would be clubbing data in the order of minutes, so a  bucketSpan  of a few minutes would make sense. Note that in this case, the entire data worth the  bucketSpan  will expire as a whole. Setting it to 1 minute would make the number of time buckets in the system to be 1 hour / 1 minute = 60 buckets.  Similarly setting bucketSpan to 5 minutes would make number of buckets to be 12.  Note that having too many or too few buckets could have a performance impact. If unsure, set the bucketSpan to the square root of  expireBefore . This way the number of buckets and bucket span are balanced.     referenceInstant \u00a0- \u00a0Long (Seconds) - (Time Based Deduper only)   The reference point from which to start the time which is use for expiry. Setting the referenceInstant to say, r seconds from the epoch, would initialize the start of expiry to be from that  instant = r . The start and end of the expiry window periodically move by the span of a single bucket.     numBuckets \u00a0- \u00a0Integer - (Bounded Deduper only)   Optional parameter, but recommended to be provided by the user.  This is the number of buckets that need to be used for storing the keys of the incoming tuples.  Users can decide upon the proper value for this parameter by guessing the number of distinct keys in the application. A reasonable value is the square root of N, where N is the number of distinct keys. If omitted, the Java MAX_VALUE for integer is used for N.",
            "title": "Properties"
        },
        {
            "location": "/operators/deduper/#example",
            "text": "Please refer to  https://github.com/DataTorrent/examples/tree/master/tutorials/dedup \u00a0for\nan example on how to use Deduper.",
            "title": "Example"
        },
        {
            "location": "/operators/deduper/#partitioning",
            "text": "Deduper can be statically partitioned using the operator\nattribute: PARTITIONER  Add the following property to the properties.xml file:  <property>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n</property>  This will partition the Dedup operator into 2 static partitions. Change the number\nto the required number of partitions.  Dynamic partitioning is currently not supported in the Deduper.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/enricher/",
            "text": "POJO Enricher\n\n\nOperator Objective\n\n\nThis operator receives an POJO (\nPlain Old Java Object\n) as an incoming tuple and uses an external source to enrich the data in \nthe incoming tuple and finally emits the enriched data as a new enriched POJO.\n\n\nPOJOEnricher supports enrichment from following external sources:\n\n\n\n\nJSON File Based\n - Reads the file in memory having content stored in JSON format and use that to enrich the data. This can be done using FSLoader implementation.\n\n\nJDBC Based\n - Any JDBC store can act as an external entity to which enricher can request data for enriching incoming tuples. This can be done using JDBCLoader implementation.\n\n\n\n\nPOJO Enricher does not hold any state and is \nidempotent\n, \nfault-tolerant\n and \nstatically/dynamically partitionable\n.\n\n\nOperator Usecase\n\n\n\n\nBank \ntransaction records\n usually contains customerId. For further analysis of transaction one wants the customer name and other customer related information. \nSuch information is present in another database. One could enrich the transaction's record with customer information using POJOEnricher.\n\n\nCall Data Record (CDR)\n contains only mobile/telephone numbers of the customer. Customer information is missing in CDR. POJO Enricher can be used to enrich \nCDR with customer data for further analysis.\n\n\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-contrib\n\n\nAvailable since: \n3.4.0\n\n\nOperator state: \nEvolving\n\n\nJava Packages:\n\n\nOperator: \ncom.datatorrent.contrib.enrich.POJOEnricher\n\n\nFSLoader: \ncom.datatorrent.contrib.enrich.FSLoader\n\n\nJDBCLoader: \ncom.datatorrent.contrib.enrich.JDBCLoader\n\n\n\n\n\n\n\n\nProperties, Attributes and Ports\n\n\nProperties of POJOEnricher\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nincludeFields\n\n\nList of fields from database that needs to be added to output POJO.\n\n\nList<String>\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nlookupFields\n\n\nList of fields from input POJO which will form a \nunique composite\n key for querying to store\n\n\nList<String>\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nstore\n\n\nBackend Store from which data should be queried for enrichment\n\n\nBackendStore\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ncacheExpirationInterval\n\n\nCache entry expiry in ms. After this time, the lookup to store will be done again for given key\n\n\nint\n\n\nNo\n\n\n1 * 60 * 60 * 1000 (1 hour)\n\n\n\n\n\n\ncacheCleanupInterval\n\n\nInterval in ms after which cache will be removed for any stale entries.\n\n\nint\n\n\nNo\n\n\n1 * 60 * 60 * 1000 (1 hour)\n\n\n\n\n\n\ncacheSize\n\n\nNumber of entry in cache after which eviction will start on each addition based on LRU\n\n\nint\n\n\nNo\n\n\n1000\n\n\n\n\n\n\n\n\nProperties of FSLoader (BackendStore)\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nfileName\n\n\nPath of the file, the data from which will be used for enrichment. See \nhere\n for JSON File format.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nProperties of JDBCLoader (BackendStore)\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ndatabaseUrl\n\n\nConnection string for connecting to JDBC\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ndatabaseDriver\n\n\nJDBC Driver class for connection to JDBC Store. This driver should be there in classpath\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ntableName\n\n\nName of the table from which data needs to be retrieved\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nconnectionProperties\n\n\nCommand seperated list of advanced connection properties that need to be passed to JDBC Driver. For eg. \nprop1:val1,prop2:val2\n\n\nString\n\n\nNo\n\n\nnull\n\n\n\n\n\n\nqueryStmt\n\n\nSelect statement which will be used to query the data. This is optional parameter in case of advanced query.\n\n\nString\n\n\nNo\n\n\nnull\n\n\n\n\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\ninput.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on input port which tells operator the class of POJO which will be incoming\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\noutput.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nTuple which needs to be enriched are received on this port\n\n\nObject (POJO)\n\n\nYes\n\n\n\n\n\n\noutput\n\n\nTuples that are enriched from external source are emitted from on this port\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\n\n\nLimitations\n\n\nCurrent POJOEnricher contains following limitation:\n\n\n\n\nFSLoader loads the file content in memory. Though it loads only the composite key and composite value in memory, a very large amount of data would bloat the memory and make the operator go OOM. In case the filesize is large, allocate sufficient memory to the POJOEnricher.\n\n\nIncoming POJO should be a subset of outgoing POJO.\n\n\nincludeFields\n property should contains fields having same name in database column as well as outgoing POJO. For eg. If name of the database column is \"customerName\", then outgoing POJO should contains a field with the same name and same should be added to includeFields.\n\n\nlookupFields\n property should contains fields having same name in database column as well as incoming POJO. For eg. If name of the database column is \"customerId\", then incoming POJO should contains a field with the same name and same should be added to lookupFields.\n\n\n\n\nExample\n\n\nExample for POJOEnricher can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/enricher\n\n\nAdvanced\n\n\n File format for JSON based FSLoader\n\n\nFSLoader expects file to be in specific format:\n\n\n\n\nEach line makes on record which becomes part of the store\n\n\nEach line is a valid JSON Object where \nkey\n is name of the field name and \nvalue\n is the field value.\n\n\n\n\nExample for the format look like following:\n\n\n{\"circleId\":0, \"circleName\":\"A\"}\n{\"circleId\":1, \"circleName\":\"B\"}\n{\"circleId\":2, \"circleName\":\"C\"}\n{\"circleId\":3, \"circleName\":\"D\"}\n{\"circleId\":4, \"circleName\":\"E\"}\n{\"circleId\":5, \"circleName\":\"F\"}\n{\"circleId\":6, \"circleName\":\"G\"}\n{\"circleId\":7, \"circleName\":\"H\"}\n{\"circleId\":8, \"circleName\":\"I\"}\n{\"circleId\":9, \"circleName\":\"J\"}\n\n\n\n\nCaching mechanism in POJOEnricher\n\n\nPOJOEnricher contains an cache which makes the lookup for keys more efficient. This is specially useful when data in external store is not changing much. \nHowever, one should carefully tune the \ncacheExpirationInterval\n property for desirable results.\n\n\nOn every incoming tuple, POJOEnricher first queries the cache. If the cache contains desired record and is within expiration interval, then it uses that to\nenrich the tuple, otherwise does a lookup to configured store and the return value is used to enrich the tuple. The return value is then cached for composite key and composite value.\n\n\nPOJOEnricher only caches the required fields for enrichment mechanism and not all fields returned by external store. This ensures optimal use of memory.\n\n\nPartitioning of POJOEnricher\n\n\nBeing stateless operator, POJOEnricher will ensure built-in partitioners present in Malhar library can be directly simply by setting few properties as follows:\n\n\nStateless partioning of POJOEnricher\n\n\nStateless partitioning will ensure that POJOEnricher will will be partitioned right at the starting of the application and will remain partitioned throughout the lifetime of the DAG.\nPOJOEnricher can be stateless partitioned by adding following lines to properties.xml:\n\n\n  <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>\n\n\n\n\nwhere {OperatorName} is the name of the POJOEnricher operator.\nAbove lines will partition POJOEnricher statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partitioning of POJOEnricher\n\n\nDynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain condition.\nPOJOEnricher can be dynamically partitioned using 2 out-of-the-box partitioners:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partitioning POJOEnricher:\n\n\n    StatelessThroughputBasedPartitioner<POJOEnricher> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition POJOEnricher when the throughput changes.\nIf the overall throughput of POJOEnricher goes beyond 30000 or less than 10000, the platform will repartition POJOEnricher \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughout change is observed.\n\n\nLatency based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partitioning POJOEnricher:\n\n\n    StatelessLatencyBasedPartitioner<POJOEnricher> partitioner = new StatelessLatencyBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumLatency(conf.getLong(MAX_THROUGHPUT, 10));\n    partitioner.setMinimumLatency(conf.getLong(MIN_THROUGHPUT, 3));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition POJOEnricher when the overall latency of POJOEnricher changes.\nIf the overall latency of POJOEnricher goes beyond 10 ms or less than 3 ms, the platform will repartition POJOEnricher \nto balance latency of a single partition to be between 3 ms and 10 ms.\nCooldownMillis of 10000 will be used as the threshold time for which the latency change is observed.",
            "title": "Enricher"
        },
        {
            "location": "/operators/enricher/#pojo-enricher",
            "text": "",
            "title": "POJO Enricher"
        },
        {
            "location": "/operators/enricher/#operator-objective",
            "text": "This operator receives an POJO ( Plain Old Java Object ) as an incoming tuple and uses an external source to enrich the data in \nthe incoming tuple and finally emits the enriched data as a new enriched POJO.  POJOEnricher supports enrichment from following external sources:   JSON File Based  - Reads the file in memory having content stored in JSON format and use that to enrich the data. This can be done using FSLoader implementation.  JDBC Based  - Any JDBC store can act as an external entity to which enricher can request data for enriching incoming tuples. This can be done using JDBCLoader implementation.   POJO Enricher does not hold any state and is  idempotent ,  fault-tolerant  and  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/enricher/#operator-usecase",
            "text": "Bank  transaction records  usually contains customerId. For further analysis of transaction one wants the customer name and other customer related information. \nSuch information is present in another database. One could enrich the transaction's record with customer information using POJOEnricher.  Call Data Record (CDR)  contains only mobile/telephone numbers of the customer. Customer information is missing in CDR. POJO Enricher can be used to enrich \nCDR with customer data for further analysis.",
            "title": "Operator Usecase"
        },
        {
            "location": "/operators/enricher/#operator-information",
            "text": "Operator location:  malhar-contrib  Available since:  3.4.0  Operator state:  Evolving  Java Packages:  Operator:  com.datatorrent.contrib.enrich.POJOEnricher  FSLoader:  com.datatorrent.contrib.enrich.FSLoader  JDBCLoader:  com.datatorrent.contrib.enrich.JDBCLoader",
            "title": "Operator Information"
        },
        {
            "location": "/operators/enricher/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/enricher/#properties-of-jdbcloader-backendstore",
            "text": "Property  Description  Type  Mandatory  Default Value      databaseUrl  Connection string for connecting to JDBC  String  Yes  N/A    databaseDriver  JDBC Driver class for connection to JDBC Store. This driver should be there in classpath  String  Yes  N/A    tableName  Name of the table from which data needs to be retrieved  String  Yes  N/A    connectionProperties  Command seperated list of advanced connection properties that need to be passed to JDBC Driver. For eg.  prop1:val1,prop2:val2  String  No  null    queryStmt  Select statement which will be used to query the data. This is optional parameter in case of advanced query.  String  No  null",
            "title": "Properties of JDBCLoader (BackendStore)"
        },
        {
            "location": "/operators/enricher/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      input.TUPLE_CLASS  TUPLE_CLASS attribute on input port which tells operator the class of POJO which will be incoming  Class or FQCN  Yes    output.TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted  Class or FQCN  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/enricher/#ports",
            "text": "Port  Description  Type  Mandatory      input  Tuple which needs to be enriched are received on this port  Object (POJO)  Yes    output  Tuples that are enriched from external source are emitted from on this port  Object (POJO)  No",
            "title": "Ports"
        },
        {
            "location": "/operators/enricher/#limitations",
            "text": "Current POJOEnricher contains following limitation:   FSLoader loads the file content in memory. Though it loads only the composite key and composite value in memory, a very large amount of data would bloat the memory and make the operator go OOM. In case the filesize is large, allocate sufficient memory to the POJOEnricher.  Incoming POJO should be a subset of outgoing POJO.  includeFields  property should contains fields having same name in database column as well as outgoing POJO. For eg. If name of the database column is \"customerName\", then outgoing POJO should contains a field with the same name and same should be added to includeFields.  lookupFields  property should contains fields having same name in database column as well as incoming POJO. For eg. If name of the database column is \"customerId\", then incoming POJO should contains a field with the same name and same should be added to lookupFields.",
            "title": "Limitations"
        },
        {
            "location": "/operators/enricher/#example",
            "text": "Example for POJOEnricher can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/enricher",
            "title": "Example"
        },
        {
            "location": "/operators/enricher/#advanced",
            "text": "",
            "title": "Advanced"
        },
        {
            "location": "/operators/enricher/#caching-mechanism-in-pojoenricher",
            "text": "POJOEnricher contains an cache which makes the lookup for keys more efficient. This is specially useful when data in external store is not changing much. \nHowever, one should carefully tune the  cacheExpirationInterval  property for desirable results.  On every incoming tuple, POJOEnricher first queries the cache. If the cache contains desired record and is within expiration interval, then it uses that to\nenrich the tuple, otherwise does a lookup to configured store and the return value is used to enrich the tuple. The return value is then cached for composite key and composite value.  POJOEnricher only caches the required fields for enrichment mechanism and not all fields returned by external store. This ensures optimal use of memory.",
            "title": "Caching mechanism in POJOEnricher"
        },
        {
            "location": "/operators/enricher/#partitioning-of-pojoenricher",
            "text": "Being stateless operator, POJOEnricher will ensure built-in partitioners present in Malhar library can be directly simply by setting few properties as follows:",
            "title": "Partitioning of POJOEnricher"
        },
        {
            "location": "/operators/enricher/#stateless-partioning-of-pojoenricher",
            "text": "Stateless partitioning will ensure that POJOEnricher will will be partitioned right at the starting of the application and will remain partitioned throughout the lifetime of the DAG.\nPOJOEnricher can be stateless partitioned by adding following lines to properties.xml:    <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>  where {OperatorName} is the name of the POJOEnricher operator.\nAbove lines will partition POJOEnricher statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Stateless partioning of POJOEnricher"
        },
        {
            "location": "/operators/enricher/#dynamic-partitioning-of-pojoenricher",
            "text": "Dynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain condition.\nPOJOEnricher can be dynamically partitioned using 2 out-of-the-box partitioners:",
            "title": "Dynamic Partitioning of POJOEnricher"
        },
        {
            "location": "/operators/enricher/#throughput-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partitioning POJOEnricher:      StatelessThroughputBasedPartitioner<POJOEnricher> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition POJOEnricher when the throughput changes.\nIf the overall throughput of POJOEnricher goes beyond 30000 or less than 10000, the platform will repartition POJOEnricher \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughout change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/enricher/#latency-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partitioning POJOEnricher:      StatelessLatencyBasedPartitioner<POJOEnricher> partitioner = new StatelessLatencyBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumLatency(conf.getLong(MAX_THROUGHPUT, 10));\n    partitioner.setMinimumLatency(conf.getLong(MIN_THROUGHPUT, 3));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(pojoEnricherObj, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition POJOEnricher when the overall latency of POJOEnricher changes.\nIf the overall latency of POJOEnricher goes beyond 10 ms or less than 3 ms, the platform will repartition POJOEnricher \nto balance latency of a single partition to be between 3 ms and 10 ms.\nCooldownMillis of 10000 will be used as the threshold time for which the latency change is observed.",
            "title": "Latency based"
        },
        {
            "location": "/operators/fsInputOperator/",
            "text": "File Input Operator\n\n\nOperator Objective\n\n\nThis operator is designed to scan a directory for files, read and split file content into tuples\nsuch as lines or a block of bytes, and finally emit them on output ports defined in concrete\nsubclasses for further processing by downstream operators.\nIt can be used with any filesystem supported by Hadoop like HDFS, S3, ftp, NFS etc.\n\n\nOverview\n\n\nThe operator is \nidempotent\n, \nfault-tolerant\n and \npartitionable\n.\n\n\nLogic for directory scanning is encapsulated in the \nDirectoryScanner\n static inner class\nwhich provides functions such as matching file names against a regular expression, tracking files\nthat have already been processed (so that they are not processed again), filtering files based\non the hashcode of the file names in the presence of partitioning so that each file is\nprocessed by a unique partition. This class can be extended if necessary to provide\nadditional capabilities such as scanning multiple directories.\n\n\nIt tracks the current file offset as part of checkpoint state. It it fails and is restarted\nby the platform, it will seek to the saved offset to avoid duplicate processing. Exactly once processing\nfor fault tolerance is handled using window data manager. For more details check the blog about \nFault-Tolerant File Processing\n.\nIt supports both static and dynamic partitioning.\n\n\nUse Cases\n\n\nThis operator is suitable for use in an environment where small to medium sized files are\ndeposited in a specific directory on a regular basis. For very large files a better alternative\nis the \nFileSplitter\n and \nBlockReader\n combination since they allow such files to be processed\nby multiple partitions to achieve higher throughput. Additionally, files which are continually\nmodified by other processes are not suitable for processing with this operator since they may\nyield unpredictable results.\n\n\nHow to Use?\n\n\nThe tuple type in the abstract class is a generic parameter.\nConcrete subclasses need to choose an appropriate class (such as \nString\n or \nbyte[]\n) for the\ngeneric parameter and also implement a couple of abstract methods: \nreadEntity()\n to read\nthe next tuple from the currently open file and \nemit()\n to process the next tuple.\n\n\nIn principle, no ports need be defined in the rare case that the operator simply writes\ntuples to some external sink or merely maintains aggregated statistics. But in most common\nscenarios, the tuples need to be sent to one or more downstream operators for additional\nprocessing such as parsing, enrichment or aggregation; in such cases, appropriate\noutput ports are defined and the \nemit()\n implementation dispatches tuples to the\ndesired output ports.\n\n\nA simple concrete implementation is provided in Malhar: \nLineByLineFileInputOperator\n.\nIt uses \nString\n for the generic parameter, defines a single output port and processes each\nline of the input file as a tuple. It is discussed further below.\n\n\nPartitioning\n\n\nStatic Partitioning\n\n\nConfigure parameter \npartitionCount\n to define the desired number of initial partitions\n(4 in this example).\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.partitionCount</name>\n  <value>4</value>\n</property>\n\n\n\n\nwhere \n{OperatorName}\n is the name of the input operator.\n\n\nDynamic Partitioning\n\n\nDynamic partitioning -- changing the number of partitions of one or more operators\nin a running application -- can be achieved in multiple ways:\n- Use the command line tool \napex\n or the UI console to change the value of the\n  \npartitionCount\n property of the running operator. This change is detected in\n  \nprocessStats()\n (which is invoked periodically by the platform) where, if the\n  current partition count (\ncurrentPartitions\n) and the desired partition count\n  (\npartitionCount\n) differ, the \nrepartitionRequired\n flag in the response is set.\n  This causes the platform to invoke \ndefinePartitions()\n to create a new set of\n  partitions with the desired count.\n- Override \nprocessStats()\n and within it, based on the statistics in the\n  incoming parameter or any other factors, define a new desired value of\n  \npartitionCount\n and finally, if this value differs from the current partition\n  count, set the \nrepartitionRequired\n flag in the response.\n\n\nThe details of actually creating the new set of partitions can be customized by overriding\nthe \ndefinePartitions()\n method. There are a couple of things to keep in mind when doing this.\nThe first is that repartitioning needs some care when the operator has state (as is the\ncase here): Existing state from current operator partitions needs to redistributed to the\nnew partitions in a logically consistent way. The second is that some or all of the\ncurrent set of partitions, which is an input parameter to \ndefinePartitions()\n, can be\ncopied over to the new set; such partitions will continue running and will not be\nrestarted. Any existing partitions that are not present in the new set will be shutdown.\nThe current re-partitioning logic does not preserve any existing partitions, so upon\na repartition event, all existing partitions are shutdown and the new ones started.\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-library\n\n\nAvailable since: \n1.0.2\n\n\nOperator state: \nStable\n\n\nJava Packages:\n\n\nOperator: \ncom.datatorrent.lib.io.fs.AbstractFileInputOperator\n\n\n\n\n\n\n\n\nAbstractFileInputOperator\n\n\nThis is the abstract implementation that, as noted above, scans a single directory.\nIt can be extended to modify functionality or add new capabilities. For example, the\ndirectory scanner can be overriden to monitor multiple directories. \nThis\n example demonstrates how to do that.\nAs noted in the overview above, this class has no ports, so concrete subclasses will need to\nprovide them if necessary.\n\n\n\n\nProperties of AbstractFileInputOperator\n\n\nSeveral properties are available to configure the behavior of this operator and they are\nsummarized in the table below. Of these, only \ndirectory\n is required: it specifies\nthe path of the monitored directory. It can be set like this:\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.directory</name>\n  <value>/tmp/fileInput</value>\n</property>\n\n\n\n\nIf new files appear with high frequency in this directory\nand they need to be processed as soon as they appear, reduce the value of \nscanIntervalMillis\n;\nif they appear rarely or if some delay in processing a new file is acceptable, increase it.\nObviously, smaller values will result in greater IO activity for the corresponding filesystem.\n\n\nThe platform invokes the \nemitTuples()\n callback multiple time in each streaming window; within\na single such call, if a large number of tuples are emitted, there is some risk that they\nmay overwhelm the downstream operators especially if they are performing some compute intensive\noperation. For such cases, output can be throttled by reducing the value of the\n\nemitBatchSize\n property. Conversely, if the downstream operators can handle the load, increase\nthe value to enhance throughput.\n\n\nThe \npartitionCount\n parameter has already been discussed above.\n\n\nOccasionally, some files get into a bad state and cause errors when an attempt is made to\nread from them. The causes vary depending on the filesystem type ranging from corrupted\nfilesystems to network issues. In such cases, the operator will retry reading from such\nfiles a limited number of times before blacklisting those files. This retry count is\ndefined by the \nmaxRetryCount\n property.\n\n\nFinally, the specific scanner class used to monitor the input directories can be configured\nby setting the \nscanner\n property.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ndirectory\n\n\nabsolute path of directory to be scanned\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nscanIntervalMillis\n\n\nInterval in milliseconds after which directory should be scanned for new files\n\n\nint\n\n\nNo\n\n\n5000\n\n\n\n\n\n\nemitBatchSize\n\n\nMaximum number of tuples to emit in a single call to the \nemitTuples()\n callback (see explanation above).\n\n\nint\n\n\nNo\n\n\n1000\n\n\n\n\n\n\npartitionCount\n\n\nDesired number of partitions\n\n\nint\n\n\nNo\n\n\n1\n\n\n\n\n\n\nmaxRetryCount\n\n\nMaximum number of times the operator will attempt to process a file\n\n\nint\n\n\nNo\n\n\n5\n\n\n\n\n\n\nscanner\n\n\nScanner to scan new files in directory\n\n\nDirectoryScanner\n\n\nNo\n\n\nDirectoryScanner\n\n\n\n\n\n\n\n\nProperties of DirectoryScanner\n\n\nThe directory scanner has one optional property: a regular expression to filter files\nof interest. If absent, all files in the source directory are processed. It can be\nset like this:\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.scanner.filePatternRegexp</name>\n  <value>/tmp/fileInput</value>\n</property>\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nfilePatternRegexp\n\n\nregex to select files from input directory\n\n\nString\n\n\nNo\n\n\nN/A\n\n\n\n\n\n\n\n\nPorts\n\n\nThis operator has no ports.\n\n\nAbstract Methods\n\n\nAs described above, concrete subclasses need to provide implementations for these two\nmethods:\n\n\nvoid emit(T tuple);\nT readEntity();\n\n\n\n\nExamples of implementations are in the \nLineByLineFileInputOperator\n operator and also in\nthe example at the end of this guide.\n\n\nDerived Classes\n\n\n1. AbstractFTPInputOperator\n\n\nThe class is used to read files from FTP file system. As for the above abstract class, concrete\nsubclasses need to implement the\n\nreadEntity\n and\n\nemit\n methods.\n\n\nProperties\n\n\nThis operator defines following additional properties beyond those defined in the\n\nparent class\n.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nHostname of ftp server.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nport\n\n\nPort of ftp server.\n\n\nint\n\n\nNo\n\n\n21 (default ftp port)\n\n\n\n\n\n\nuserName\n\n\nUsername which is used for login to the server.\n\n\nString\n\n\nNo\n\n\nanonymous\n\n\n\n\n\n\npassword\n\n\nPassword which is used for login to the server.\n\n\nString\n\n\nNo\n\n\ngues\n\n\n\n\n\n\n\n\nPorts\n\n\nThis operator has no ports.\n\n\n2. FTPStringInputOperator\n\n\nThis class extends AbstractFTPInputOperator and  implements abstract methods to read files available on FTP file system line by line.\n\n\nProperties\n\n\nThis operator defines no additional properties beyond those defined in the\n\nparent class\n.\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutput\n\n\nTuples that are read from file are emitted on this port\n\n\nString\n\n\nYes\n\n\n\n\n\n\n\n\n3. AbstractParquetFileReader\n\n\nReads Parquet files from input directory using GroupReadSupport. Derived classes need to implement \nconvertGroup(Group)\n method to convert Group to other type. Also it should implement  \nreadEntity()\n and \nemit(T)\n methods.\n\n\nProperties of AbstractParquetFileReader\n\n\nThis operator defines following additional properties beyond those defined in the\n\nparent class\n.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nparquetSchema\n\n\nParquet Schema to parse record.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nPorts\n\n\nThis operator has no ports.\n\n\n4. AbstractThroughputFileInputOperator\n\n\nThis operator extends \nAbstractFileInputOperator\n by providing the capability to partition\ndynamically based the file backlog. The user can set the preferred number of pending files per operator as well as the maximum number of operators and define a re-partition interval. If a physical operator runs out of files to process and an amount of time greater than or equal to the repartition interval has passed then a new number of operators are created to accommodate the remaining pending files. Derived classes need to implement \nreadEntity()\n and \nemit(T)\n methods.\n\n\nProperties of AbstractThroughputFileInputOperator\n\n\nThis operator defines following additional properties beyond those defined in the\n\nparent class\n.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nrepartitionInterval\n\n\nThe minimum amount of time that must pass in milliseconds before the operator can be repartitioned.\n\n\nlong\n\n\nNo\n\n\n5 minutes\n\n\n\n\n\n\npreferredMaxPendingFilesPerOperator\n\n\nthe preferred number of pending files per operator.\n\n\nint\n\n\nNo\n\n\n10\n\n\n\n\n\n\npartitionCount\n\n\nthe maximum number of partitions for the operator.\n\n\nint\n\n\nNo\n\n\n1\n\n\n\n\n\n\n\n\nPorts\n\n\nThis operator has no ports.\n\n\n5. LineByLineFileInputOperator\n\n\nAs mentioned in the overview above, this operator defines a single output port; it reads files\nas lines and emits them as Java Strings on the output port. The output port \nmust\n be connected.\nLines are extracted using the Java \nBufferedReader\n class and the default character encoding.\nAn example illustrating the use of a custom encoding (such as UTF_8) is provided below\n\n\nProperties\n\n\nThis operator defines no additional properties beyond those defined in the\n\nparent class\n.\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutput\n\n\nTuples that are read from file are emitted on this port\n\n\nString\n\n\nYes\n\n\n\n\n\n\n\n\nExample Implementation Using a Custom Character Encoding\n\n\nThis example demonstrates how to extend the \nAbstractFileInputOperator\n to read\nUTF-8 encoded data.\n\n\npublic class EncodedDataReader extends AbstractFileInputOperator<String>\n{\n  public final transient DefaultOutputPort<String> output = new DefaultOutputPort<>();\n  protected transient BufferedReader br;\n\n  protected InputStream openFile(Path path) throws IOException\n  {\n    InputStream is = super.openFile(path);\n    br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n    return is;\n  }\n\n  @Override\n  protected void closeFile(InputStream is) throws IOException\n  {\n    super.closeFile(is);\n    br.close();\n    br = null;\n  }\n\n  @Override\n  protected String readEntity() throws IOException\n  {\n    return br.readLine();\n  }\n\n  @Override\n  protected void emit(String tuple)\n  {\n    output.emit(tuple);\n  }\n}\n\n\n\n\n\nCommon Implementation Scenarios\n\n\nSometimes, downstream operators need to know which file each tuple came from; there are a\nnumber of ways of achieving this, each with its own tradeoffs. Some alternatives:\n\n\n\n\nIf the generic tuple type is a String, each tuple can be prefixed with the file name\n  with a suitable separator, for example: \nfoo.txt: first line\n. This works but\n  has obvious additional costs in both processing (to parse out the two pieces of each\n  tuple) and network bandwidth utilization.\n\n\nDefine a custom tuple class with two fields: one for the file name and one for tuple data.\n  The costs are similar to the previous approach though the code is simpler since\n  parsing is handled behind the scenes by the serialization process.\n\n\nDefine the tuple type to be \nObject\n and emit either a custom \nTuple\n object for actual\n  tuple data or \nBOF\n/\nEOF\n objects with the name of the file when a new file begins\n  or the current file ends. Here, the additional bandwidth consumed is\n  minimal (just 2 additional tuples at file boundaries) but the type of each tuple needs\n  to be checked using \ninstanceof\n in the downstream operators which has some runtime cost.\n\n\nSimilar to the previous approach but define an additional control port dedicated to\n  the BOF/EOF control tuples. This approach eliminates the runtime cost of using \ninstanceof\n\n  but some care is needed because (a) the order of tuples arriving at multiple input ports\n  in downstream operators cannot be guaranteed -- for example, the BOF/EOF control tuples\n  may arrive before some of the actual data tuples; and (b) since the operator may read\n  more than one file in a single streaming window, the downstream operator may not be\n  able to tell which tuples belong to which file. One way of dealing with this is to\n  stop emitting data tuples until the next \nendWindow()\n callback when an EOF is detected\n  for the current file; that way, if the downstream operator receives an EOF control tuple,\n  it has the guarantee that all the data tuples received in the same window belong to the\n  current file.\n\n\n\n\nOf course, other strategies are possible depending on the needs of the particular situation.\n\n\nWhen used in a long-running application where a very large number of files are are processed\nover time, the internal state (consisting of properties like \nprocessedFiles\n) may grow\ncorrespondingly and this may have some performance impact since each checkpoint saves the\nentire operator state. In such situations, it is useful to explore options such as moving\nprocessed files to another directory and trimming operator state variables suitably.",
            "title": "File Input"
        },
        {
            "location": "/operators/fsInputOperator/#file-input-operator",
            "text": "",
            "title": "File Input Operator"
        },
        {
            "location": "/operators/fsInputOperator/#operator-objective",
            "text": "This operator is designed to scan a directory for files, read and split file content into tuples\nsuch as lines or a block of bytes, and finally emit them on output ports defined in concrete\nsubclasses for further processing by downstream operators.\nIt can be used with any filesystem supported by Hadoop like HDFS, S3, ftp, NFS etc.",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/fsInputOperator/#overview",
            "text": "The operator is  idempotent ,  fault-tolerant  and  partitionable .  Logic for directory scanning is encapsulated in the  DirectoryScanner  static inner class\nwhich provides functions such as matching file names against a regular expression, tracking files\nthat have already been processed (so that they are not processed again), filtering files based\non the hashcode of the file names in the presence of partitioning so that each file is\nprocessed by a unique partition. This class can be extended if necessary to provide\nadditional capabilities such as scanning multiple directories.  It tracks the current file offset as part of checkpoint state. It it fails and is restarted\nby the platform, it will seek to the saved offset to avoid duplicate processing. Exactly once processing\nfor fault tolerance is handled using window data manager. For more details check the blog about  Fault-Tolerant File Processing .\nIt supports both static and dynamic partitioning.",
            "title": "Overview"
        },
        {
            "location": "/operators/fsInputOperator/#use-cases",
            "text": "This operator is suitable for use in an environment where small to medium sized files are\ndeposited in a specific directory on a regular basis. For very large files a better alternative\nis the  FileSplitter  and  BlockReader  combination since they allow such files to be processed\nby multiple partitions to achieve higher throughput. Additionally, files which are continually\nmodified by other processes are not suitable for processing with this operator since they may\nyield unpredictable results.",
            "title": "Use Cases"
        },
        {
            "location": "/operators/fsInputOperator/#how-to-use",
            "text": "The tuple type in the abstract class is a generic parameter.\nConcrete subclasses need to choose an appropriate class (such as  String  or  byte[] ) for the\ngeneric parameter and also implement a couple of abstract methods:  readEntity()  to read\nthe next tuple from the currently open file and  emit()  to process the next tuple.  In principle, no ports need be defined in the rare case that the operator simply writes\ntuples to some external sink or merely maintains aggregated statistics. But in most common\nscenarios, the tuples need to be sent to one or more downstream operators for additional\nprocessing such as parsing, enrichment or aggregation; in such cases, appropriate\noutput ports are defined and the  emit()  implementation dispatches tuples to the\ndesired output ports.  A simple concrete implementation is provided in Malhar:  LineByLineFileInputOperator .\nIt uses  String  for the generic parameter, defines a single output port and processes each\nline of the input file as a tuple. It is discussed further below.",
            "title": "How to Use?"
        },
        {
            "location": "/operators/fsInputOperator/#partitioning",
            "text": "",
            "title": "Partitioning"
        },
        {
            "location": "/operators/fsInputOperator/#static-partitioning",
            "text": "Configure parameter  partitionCount  to define the desired number of initial partitions\n(4 in this example).  <property>\n  <name>dt.operator.{OperatorName}.prop.partitionCount</name>\n  <value>4</value>\n</property>  where  {OperatorName}  is the name of the input operator.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/fsInputOperator/#dynamic-partitioning",
            "text": "Dynamic partitioning -- changing the number of partitions of one or more operators\nin a running application -- can be achieved in multiple ways:\n- Use the command line tool  apex  or the UI console to change the value of the\n   partitionCount  property of the running operator. This change is detected in\n   processStats()  (which is invoked periodically by the platform) where, if the\n  current partition count ( currentPartitions ) and the desired partition count\n  ( partitionCount ) differ, the  repartitionRequired  flag in the response is set.\n  This causes the platform to invoke  definePartitions()  to create a new set of\n  partitions with the desired count.\n- Override  processStats()  and within it, based on the statistics in the\n  incoming parameter or any other factors, define a new desired value of\n   partitionCount  and finally, if this value differs from the current partition\n  count, set the  repartitionRequired  flag in the response.  The details of actually creating the new set of partitions can be customized by overriding\nthe  definePartitions()  method. There are a couple of things to keep in mind when doing this.\nThe first is that repartitioning needs some care when the operator has state (as is the\ncase here): Existing state from current operator partitions needs to redistributed to the\nnew partitions in a logically consistent way. The second is that some or all of the\ncurrent set of partitions, which is an input parameter to  definePartitions() , can be\ncopied over to the new set; such partitions will continue running and will not be\nrestarted. Any existing partitions that are not present in the new set will be shutdown.\nThe current re-partitioning logic does not preserve any existing partitions, so upon\na repartition event, all existing partitions are shutdown and the new ones started.",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/fsInputOperator/#operator-information",
            "text": "Operator location:  malhar-library  Available since:  1.0.2  Operator state:  Stable  Java Packages:  Operator:  com.datatorrent.lib.io.fs.AbstractFileInputOperator",
            "title": "Operator Information"
        },
        {
            "location": "/operators/fsInputOperator/#abstractfileinputoperator",
            "text": "This is the abstract implementation that, as noted above, scans a single directory.\nIt can be extended to modify functionality or add new capabilities. For example, the\ndirectory scanner can be overriden to monitor multiple directories.  This  example demonstrates how to do that.\nAs noted in the overview above, this class has no ports, so concrete subclasses will need to\nprovide them if necessary.",
            "title": "AbstractFileInputOperator"
        },
        {
            "location": "/operators/fsInputOperator/#ports",
            "text": "This operator has no ports.",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#abstract-methods",
            "text": "As described above, concrete subclasses need to provide implementations for these two\nmethods:  void emit(T tuple);\nT readEntity();  Examples of implementations are in the  LineByLineFileInputOperator  operator and also in\nthe example at the end of this guide.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/fsInputOperator/#derived-classes",
            "text": "",
            "title": "Derived Classes"
        },
        {
            "location": "/operators/fsInputOperator/#1-abstractftpinputoperator",
            "text": "The class is used to read files from FTP file system. As for the above abstract class, concrete\nsubclasses need to implement the readEntity  and emit  methods.",
            "title": "1. AbstractFTPInputOperator"
        },
        {
            "location": "/operators/fsInputOperator/#ports_1",
            "text": "This operator has no ports.",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#2-ftpstringinputoperator",
            "text": "This class extends AbstractFTPInputOperator and  implements abstract methods to read files available on FTP file system line by line.",
            "title": "2. FTPStringInputOperator"
        },
        {
            "location": "/operators/fsInputOperator/#ports_2",
            "text": "Port  Description  Type  Mandatory      output  Tuples that are read from file are emitted on this port  String  Yes",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#3-abstractparquetfilereader",
            "text": "Reads Parquet files from input directory using GroupReadSupport. Derived classes need to implement  convertGroup(Group)  method to convert Group to other type. Also it should implement   readEntity()  and  emit(T)  methods.",
            "title": "3. AbstractParquetFileReader"
        },
        {
            "location": "/operators/fsInputOperator/#ports_3",
            "text": "This operator has no ports.",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#4-abstractthroughputfileinputoperator",
            "text": "This operator extends  AbstractFileInputOperator  by providing the capability to partition\ndynamically based the file backlog. The user can set the preferred number of pending files per operator as well as the maximum number of operators and define a re-partition interval. If a physical operator runs out of files to process and an amount of time greater than or equal to the repartition interval has passed then a new number of operators are created to accommodate the remaining pending files. Derived classes need to implement  readEntity()  and  emit(T)  methods.",
            "title": "4. AbstractThroughputFileInputOperator"
        },
        {
            "location": "/operators/fsInputOperator/#ports_4",
            "text": "This operator has no ports.",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#5-linebylinefileinputoperator",
            "text": "As mentioned in the overview above, this operator defines a single output port; it reads files\nas lines and emits them as Java Strings on the output port. The output port  must  be connected.\nLines are extracted using the Java  BufferedReader  class and the default character encoding.\nAn example illustrating the use of a custom encoding (such as UTF_8) is provided below",
            "title": "5. LineByLineFileInputOperator"
        },
        {
            "location": "/operators/fsInputOperator/#properties_2",
            "text": "This operator defines no additional properties beyond those defined in the parent class .",
            "title": "Properties"
        },
        {
            "location": "/operators/fsInputOperator/#ports_5",
            "text": "Port  Description  Type  Mandatory      output  Tuples that are read from file are emitted on this port  String  Yes",
            "title": "Ports"
        },
        {
            "location": "/operators/fsInputOperator/#example-implementation-using-a-custom-character-encoding",
            "text": "This example demonstrates how to extend the  AbstractFileInputOperator  to read\nUTF-8 encoded data.  public class EncodedDataReader extends AbstractFileInputOperator<String>\n{\n  public final transient DefaultOutputPort<String> output = new DefaultOutputPort<>();\n  protected transient BufferedReader br;\n\n  protected InputStream openFile(Path path) throws IOException\n  {\n    InputStream is = super.openFile(path);\n    br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n    return is;\n  }\n\n  @Override\n  protected void closeFile(InputStream is) throws IOException\n  {\n    super.closeFile(is);\n    br.close();\n    br = null;\n  }\n\n  @Override\n  protected String readEntity() throws IOException\n  {\n    return br.readLine();\n  }\n\n  @Override\n  protected void emit(String tuple)\n  {\n    output.emit(tuple);\n  }\n}",
            "title": "Example Implementation Using a Custom Character Encoding"
        },
        {
            "location": "/operators/fsInputOperator/#common-implementation-scenarios",
            "text": "Sometimes, downstream operators need to know which file each tuple came from; there are a\nnumber of ways of achieving this, each with its own tradeoffs. Some alternatives:   If the generic tuple type is a String, each tuple can be prefixed with the file name\n  with a suitable separator, for example:  foo.txt: first line . This works but\n  has obvious additional costs in both processing (to parse out the two pieces of each\n  tuple) and network bandwidth utilization.  Define a custom tuple class with two fields: one for the file name and one for tuple data.\n  The costs are similar to the previous approach though the code is simpler since\n  parsing is handled behind the scenes by the serialization process.  Define the tuple type to be  Object  and emit either a custom  Tuple  object for actual\n  tuple data or  BOF / EOF  objects with the name of the file when a new file begins\n  or the current file ends. Here, the additional bandwidth consumed is\n  minimal (just 2 additional tuples at file boundaries) but the type of each tuple needs\n  to be checked using  instanceof  in the downstream operators which has some runtime cost.  Similar to the previous approach but define an additional control port dedicated to\n  the BOF/EOF control tuples. This approach eliminates the runtime cost of using  instanceof \n  but some care is needed because (a) the order of tuples arriving at multiple input ports\n  in downstream operators cannot be guaranteed -- for example, the BOF/EOF control tuples\n  may arrive before some of the actual data tuples; and (b) since the operator may read\n  more than one file in a single streaming window, the downstream operator may not be\n  able to tell which tuples belong to which file. One way of dealing with this is to\n  stop emitting data tuples until the next  endWindow()  callback when an EOF is detected\n  for the current file; that way, if the downstream operator receives an EOF control tuple,\n  it has the guarantee that all the data tuples received in the same window belong to the\n  current file.   Of course, other strategies are possible depending on the needs of the particular situation.  When used in a long-running application where a very large number of files are are processed\nover time, the internal state (consisting of properties like  processedFiles ) may grow\ncorrespondingly and this may have some performance impact since each checkpoint saves the\nentire operator state. In such situations, it is useful to explore options such as moving\nprocessed files to another directory and trimming operator state variables suitably.",
            "title": "Common Implementation Scenarios"
        },
        {
            "location": "/operators/file_output/",
            "text": "AbstractFileOutputOperator\n\n\nThe abstract file output operator in Apache Apex Malhar library \u2014 \nAbstractFileOutputOperator\n writes streaming data to files. The main features of this operator are:\n\n\n\n\nPersisting data to files.\n\n\nAutomatic rotation of files based on:\n\n  a. maximum length of a file.\n\n  b. time-based rotation where time is specified using a count of application windows.\n\n\nFault-tolerance.\n\n\nCompression and encryption of data before it is persisted.\n\n\n\n\nIn this tutorial we will cover the details of the basic structure and implementation of all the above features in \nAbstractFileOutputOperator\n. Configuration items related to each feature are discussed as they are introduced in the section of that feature.\n\n\nPersisting data to files\n\n\nThe principal function of this operator is to persist tuples to files efficiently. These files are created under a specific directory on the file system. The relevant configuration item is:\n\n\nfilePath\n: path specifying the directory where files are written.\n\n\nDifferent types of file system that are implementations of \norg.apache.hadoop.fs.FileSystem\n are supported. The file system instance which is used for creating streams is constructed from the \nfilePath\n URI.\n\n\nFileSystem.newInstance(new Path(filePath).toUri(), new Configuration())\n\n\n\n\nTuples may belong to different files therefore expensive IO operations like creating multiple output streams, flushing of data to disk, and closing streams are handled carefully.\n\n\nPorts\n\n\n\n\ninput\n: the input port on which tuples to be persisted are received.\n\n\n\n\nstreamsCache\n\n\nThis transient state caches output streams per file in memory. The file to which the data is appended may change with incoming tuples. It will be highly inefficient to keep re-opening streams for a file just because tuples for that file are interleaved with tuples for another file. Therefore, the operator maintains a cache of limited size with open output streams.\n\n\nstreamsCache\n is of type \ncom.google.common.cache.LoadingCache\n. A \nLoadingCache\n has an attached \nCacheLoader\n which is responsible to load value of a key when the key is not present in the cache. Details are explained here- \nCachesExplained\n.\n\n\nThe operator constructs this cache in \nsetup(...)\n. It is built with the following configuration items:\n\n\n\n\nmaxOpenFiles\n: maximum size of the cache. The cache evicts entries that haven't been used recently when the cache size is approaching this limit. \nDefault\n: 100\n\n\nexpireStreamAfterAcessMillis\n: expires streams after the specified duration has passed since the stream was last accessed. \nDefault\n: value of attribute- \nOperatorContext.SPIN_MILLIS\n.\n\n\n\n\nAn important point to note here is that the guava cache does not perform cleanup and evict values asynchronously, that is, instantly after a value expires. Instead, it performs small amounts of maintenance during write operations, or during occasional read operations if writes are rare.\n\n\nCacheLoader\n\n\nstreamsCache\n is created with a \nCacheLoader\n that opens an \nFSDataOutputStream\n for a file which is not in the cache. The output stream is opened in either \nappend\n or \ncreate\n mode and the basic logic to determine this is explained by the simple diagram below.\n\n\n\n\nThis process gets complicated when fault-tolerance (writing to temporary files)  and rotation is added.\n\n\nFollowing are few configuration items used for opening the streams:\n\n\n\n\nreplication\n: specifies the replication factor of the output files. \nDefault\n: \nfs.getDefaultReplication(new Path(filePath))\n\n\nfilePermission\n: specifies the permission of the output files. The permission is an octal number similar to that used by the Unix chmod command. \nDefault\n: 0777\n\n\n\n\nRemovalListener\n\n\nA \nGuava\n cache also allows specification of removal listener which can perform some operation when an entry is removed from the cache. Since \nstreamsCache\n is of limited size and also has time-based expiry enabled, it is imperative that when a stream is evicted from the cache it is closed properly. Therefore, we attach a removal listener to \nstreamsCache\n which closes the stream when it is evicted.\n\n\nsetup(OperatorContext context)\n\n\nDuring setup the following main tasks are performed:\n\n\n\n\nFileSystem instance is created.\n\n\nThe cache of streams is created.\n\n\nFiles are recovered (see Fault-tolerance section).\n\n\nStray part files are cleaned (see Automatic rotation section).\n\n\n\n\nprocessTuple(INPUT tuple)\n\n\nThe code snippet below highlights the basic steps of processing a tuple.\n\n\nprotected void processTuple(INPUT tuple)\n{  \n  //which file to write to is derived from the tuple.\n  String fileName = getFileName(tuple);  \n\n  //streamsCache is queried for the output stream. If the stream is already opened then it is returned immediately otherwise the cache loader creates one.\n  FilterOutputStream fsOutput = streamsCache.get(fileName).getFilterStream();\n\n  byte[] tupleBytes = getBytesForTuple(tuple);\n\n  fsOutput.write(tupleBytes);\n}\n\n\n\n\nendWindow()\n\n\nIt should be noted that while processing a tuple we do not flush the stream after every write. Since flushing is expensive it is done periodically for all the open streams in the operator's \nendWindow()\n.\n\n\nMap<String, FSFilterStreamContext> openStreams = streamsCache.asMap();\nfor (FSFilterStreamContext streamContext: openStreams.values()) {\n  ...\n  //this flushes the stream\n  streamContext.finalizeContext();\n  ...\n}\n\n\n\n\nFSFilterStreamContext\n will be explained with compression and encryption.\n\n\nteardown()\n\n\nWhen any operator in a DAG fails then the application master invokes \nteardown()\n for that operator and its downstream operators. In \nAbstractFileOutputOperator\n we have a bunch of open streams in the cache and the operator (acting as HDFS client) holds leases for all the corresponding files. It is important to release these leases for clean re-deployment. Therefore, we try to close all the open streams in \nteardown()\n.\n\n\nAutomatic rotation\n\n\nIn a streaming application where data is being continuously processed, when this output operator is used, data will be continuously written to an output file. The users may want to be able to take the data from time to time to use it, copy it out of Hadoop or do some other processing. Having all the data in a single file makes it difficult as the user needs to keep track of how much data has been read from the file each time so that the same data is not read again. Also users may already have processes and scripts in place that work with full files and not partial data from a file.\n\n\nTo help solve these problems the operator supports creating many smaller files instead of writing to just one big file. Data is written to a file and when some condition is met the file is finalized and data is written to a new file. This is called file rotation. The user can determine when the file gets rotated. Each of these files is called a part file as they contain portion of the data.\n\n\nPart filename\n\n\nThe filename for a part file is formed by using the original file name and the part number. The part number starts from 0 and is incremented each time a new part file created. The default filename has the format, assuming origfile represents the original filename and partnum represents the part number,\n\n\norigfile.partnum\n\n\nThis naming scheme can be changed by the user. It can be done so by overriding the following method\n\n\nprotected String getPartFileName(String fileName, int part)\n\n\n\n\nThis method is passed the original filename and part number as arguments and should return the part filename.\n\n\nMechanisms\n\n\nThe user has a couple of ways to specify when a file gets rotated. First is based on size and second on time. In the first case the files are limited by size and in the second they are rotated by time.\n\n\nSize Based\n\n\nWith size based rotation the user specifies a size limit. Once the size of the currently file reaches this limit the file is rotated. The size limit can be specified by setting the following property\n\n\nmaxLength\n\n\nLike any other property this can be set in Java application code or in the property file.\n\n\nTime Based\n\n\nIn time based rotation user specifies a time interval. This interval is specified as number of application windows. The files are rotated periodically once the specified number of application windows have elapsed. Since the interval is application window based it is not always exactly constant time. The interval can be specified using the following property\n\n\nrotationWindows\n\n\nsetup(OperatorContext context)\n\n\nWhen an operator is being started there may be stray part files and they need to be cleaned up. One common scenario, when these could be present, is in the case of failure, where a node running the operator failed and a previous instance of the operator was killed. This cleanup and other initial processing for the part files happens in the operator setup. The following diagram describes this process\n\n\n\n\nFault-tolerance\n\n\nThere are two issues that should be addressed in order to make the operator fault-tolerant:\n\n\n\n\n\n\nThe operator flushes data to the filesystem every application window. This implies that after a failure when the operator is re-deployed and tuples of a window are replayed, then duplicate data will be saved to the files. This is handled by recording how much the operator has written to each file every window in a state that is checkpointed and truncating files back to the recovery checkpoint after re-deployment.\n\n\n\n\n\n\nWhile writing to HDFS, if the operator gets killed and didn't have the opportunity to close a file, then later when it is redeployed it will attempt to truncate/restore that file. Restoring a file may fail because the lease that the previous process (operator instance before failure) had acquired from namenode to write to a file may still linger and therefore there can be exceptions in acquiring the lease again by the new process (operator instance after failure). This is handled by always writing data to temporary files and renaming these files to actual files when a file is finalized (closed) for writing, that is, we are sure that no more data will be written to it. The relevant configuration item is:  \n\n\n\n\nalwaysWriteToTmp\n: enables/disables writing to a temporary file. \nDefault\n: true.\n\n\n\n\nMost of the complexity in the code comes from making this operator fault-tolerant.\n\n\nCheckpointed states needed for fault-tolerance\n\n\n\n\n\n\nendOffsets\n: contains the size of each file as it is being updated by the operator. It helps the operator to restore a file during recovery in operator \nsetup(...)\n and is also used while loading a stream to find out if the operator has seen a file before.\n\n\n\n\n\n\nfileNameToTmpName\n: contains the name of the temporary file per actual file. It is needed because the name of a temporary file is random. They are named based on the timestamp when the stream is created. During recovery the operator needs to know the temp file which it was writing to and if it needs restoration then it creates a new temp file and updates this mapping.\n\n\n\n\n\n\nfinalizedFiles\n: contains set of files which were requested to be finalized per window id.\n\n\n\n\n\n\nfinalizedPart\n: contains the latest \npart\n of each file which was requested to be finalized.\n\n\n\n\n\n\nThe use of \nfinalizedFiles\n and \nfinalizedPart\n are explained in detail under \nrequestFinalize(...)\n method.\n\n\nRecovering files\n\n\nWhen the operator is re-deployed, it checks in its \nsetup(...)\n method if the state of a file which it has seen before the failure is consistent with the file's state on the file system, that is, the size of the file on the file system should match the size in the \nendOffsets\n. When it doesn't the operator truncates the file.\n\n\nFor example, let's say the operator wrote 100 bytes to test1.txt by the end of window 10. It wrote another 20 bytes by the end of window 12 but failed in window 13. When the operator gets re-deployed it is restored with window 10 (recovery checkpoint) state. In the previous run, by the end of window 10, the size of file on the filesystem was 100 bytes but now it is 120 bytes. Tuples for windows 11 and 12 are going to be replayed. Therefore, in order to avoid writing duplicates to test1.txt, the operator truncates the file to 100 bytes (size at the end of window 10) discarding the last 20 bytes.\n\n\nrequestFinalize(String fileName)\n\n\nWhen the operator is always writing to temporary files (in order to avoid HDFS Lease exceptions), then it is necessary to rename the temporary files to the actual files once it has been determined that the files are closed. This is refered to as \nfinalization\n of files and the method allows the user code to specify when a file is ready for finalization.\n\n\nIn this method, the requested file (or in the case of rotation \u2014 all the file parts including the latest open part which have not yet been requested for finalization) are registered for finalization. Registration is basically adding the file names to \nfinalizedFiles\n state and updating \nfinalizedPart\n.\n\n\nThe process of \nfinalization\n of all the files which were requested till the window \nw\n is deferred till window \nw\n is committed. This is because until a window is committed it can be replayed after a failure which means that a file can be open for writing even after it was requested for finalization.\n\n\nWhen rotation is enabled, part files as and when they get completed are requested for finalization. However, when rotation is not enabled user code needs to invoke this method as the knowledge that when a file is closed is unknown to this abstract operator.",
            "title": "File Output"
        },
        {
            "location": "/operators/file_output/#abstractfileoutputoperator",
            "text": "The abstract file output operator in Apache Apex Malhar library \u2014  AbstractFileOutputOperator  writes streaming data to files. The main features of this operator are:   Persisting data to files.  Automatic rotation of files based on: \n  a. maximum length of a file. \n  b. time-based rotation where time is specified using a count of application windows.  Fault-tolerance.  Compression and encryption of data before it is persisted.   In this tutorial we will cover the details of the basic structure and implementation of all the above features in  AbstractFileOutputOperator . Configuration items related to each feature are discussed as they are introduced in the section of that feature.",
            "title": "AbstractFileOutputOperator"
        },
        {
            "location": "/operators/file_output/#persisting-data-to-files",
            "text": "The principal function of this operator is to persist tuples to files efficiently. These files are created under a specific directory on the file system. The relevant configuration item is:  filePath : path specifying the directory where files are written.  Different types of file system that are implementations of  org.apache.hadoop.fs.FileSystem  are supported. The file system instance which is used for creating streams is constructed from the  filePath  URI.  FileSystem.newInstance(new Path(filePath).toUri(), new Configuration())  Tuples may belong to different files therefore expensive IO operations like creating multiple output streams, flushing of data to disk, and closing streams are handled carefully.",
            "title": "Persisting data to files"
        },
        {
            "location": "/operators/file_output/#ports",
            "text": "input : the input port on which tuples to be persisted are received.",
            "title": "Ports"
        },
        {
            "location": "/operators/file_output/#streamscache",
            "text": "This transient state caches output streams per file in memory. The file to which the data is appended may change with incoming tuples. It will be highly inefficient to keep re-opening streams for a file just because tuples for that file are interleaved with tuples for another file. Therefore, the operator maintains a cache of limited size with open output streams.  streamsCache  is of type  com.google.common.cache.LoadingCache . A  LoadingCache  has an attached  CacheLoader  which is responsible to load value of a key when the key is not present in the cache. Details are explained here-  CachesExplained .  The operator constructs this cache in  setup(...) . It is built with the following configuration items:   maxOpenFiles : maximum size of the cache. The cache evicts entries that haven't been used recently when the cache size is approaching this limit.  Default : 100  expireStreamAfterAcessMillis : expires streams after the specified duration has passed since the stream was last accessed.  Default : value of attribute-  OperatorContext.SPIN_MILLIS .   An important point to note here is that the guava cache does not perform cleanup and evict values asynchronously, that is, instantly after a value expires. Instead, it performs small amounts of maintenance during write operations, or during occasional read operations if writes are rare.",
            "title": "streamsCache"
        },
        {
            "location": "/operators/file_output/#cacheloader",
            "text": "streamsCache  is created with a  CacheLoader  that opens an  FSDataOutputStream  for a file which is not in the cache. The output stream is opened in either  append  or  create  mode and the basic logic to determine this is explained by the simple diagram below.   This process gets complicated when fault-tolerance (writing to temporary files)  and rotation is added.  Following are few configuration items used for opening the streams:   replication : specifies the replication factor of the output files.  Default :  fs.getDefaultReplication(new Path(filePath))  filePermission : specifies the permission of the output files. The permission is an octal number similar to that used by the Unix chmod command.  Default : 0777",
            "title": "CacheLoader"
        },
        {
            "location": "/operators/file_output/#removallistener",
            "text": "A  Guava  cache also allows specification of removal listener which can perform some operation when an entry is removed from the cache. Since  streamsCache  is of limited size and also has time-based expiry enabled, it is imperative that when a stream is evicted from the cache it is closed properly. Therefore, we attach a removal listener to  streamsCache  which closes the stream when it is evicted.",
            "title": "RemovalListener"
        },
        {
            "location": "/operators/file_output/#setupoperatorcontext-context",
            "text": "During setup the following main tasks are performed:   FileSystem instance is created.  The cache of streams is created.  Files are recovered (see Fault-tolerance section).  Stray part files are cleaned (see Automatic rotation section).",
            "title": "setup(OperatorContext context)"
        },
        {
            "location": "/operators/file_output/#automatic-rotation",
            "text": "In a streaming application where data is being continuously processed, when this output operator is used, data will be continuously written to an output file. The users may want to be able to take the data from time to time to use it, copy it out of Hadoop or do some other processing. Having all the data in a single file makes it difficult as the user needs to keep track of how much data has been read from the file each time so that the same data is not read again. Also users may already have processes and scripts in place that work with full files and not partial data from a file.  To help solve these problems the operator supports creating many smaller files instead of writing to just one big file. Data is written to a file and when some condition is met the file is finalized and data is written to a new file. This is called file rotation. The user can determine when the file gets rotated. Each of these files is called a part file as they contain portion of the data.",
            "title": "Automatic rotation"
        },
        {
            "location": "/operators/file_output/#part-filename",
            "text": "The filename for a part file is formed by using the original file name and the part number. The part number starts from 0 and is incremented each time a new part file created. The default filename has the format, assuming origfile represents the original filename and partnum represents the part number,  origfile.partnum  This naming scheme can be changed by the user. It can be done so by overriding the following method  protected String getPartFileName(String fileName, int part)  This method is passed the original filename and part number as arguments and should return the part filename.",
            "title": "Part filename"
        },
        {
            "location": "/operators/file_output/#mechanisms",
            "text": "The user has a couple of ways to specify when a file gets rotated. First is based on size and second on time. In the first case the files are limited by size and in the second they are rotated by time.",
            "title": "Mechanisms"
        },
        {
            "location": "/operators/file_output/#size-based",
            "text": "With size based rotation the user specifies a size limit. Once the size of the currently file reaches this limit the file is rotated. The size limit can be specified by setting the following property  maxLength  Like any other property this can be set in Java application code or in the property file.",
            "title": "Size Based"
        },
        {
            "location": "/operators/file_output/#time-based",
            "text": "In time based rotation user specifies a time interval. This interval is specified as number of application windows. The files are rotated periodically once the specified number of application windows have elapsed. Since the interval is application window based it is not always exactly constant time. The interval can be specified using the following property  rotationWindows",
            "title": "Time Based"
        },
        {
            "location": "/operators/file_output/#setupoperatorcontext-context_1",
            "text": "When an operator is being started there may be stray part files and they need to be cleaned up. One common scenario, when these could be present, is in the case of failure, where a node running the operator failed and a previous instance of the operator was killed. This cleanup and other initial processing for the part files happens in the operator setup. The following diagram describes this process",
            "title": "setup(OperatorContext context)"
        },
        {
            "location": "/operators/file_output/#fault-tolerance",
            "text": "There are two issues that should be addressed in order to make the operator fault-tolerant:    The operator flushes data to the filesystem every application window. This implies that after a failure when the operator is re-deployed and tuples of a window are replayed, then duplicate data will be saved to the files. This is handled by recording how much the operator has written to each file every window in a state that is checkpointed and truncating files back to the recovery checkpoint after re-deployment.    While writing to HDFS, if the operator gets killed and didn't have the opportunity to close a file, then later when it is redeployed it will attempt to truncate/restore that file. Restoring a file may fail because the lease that the previous process (operator instance before failure) had acquired from namenode to write to a file may still linger and therefore there can be exceptions in acquiring the lease again by the new process (operator instance after failure). This is handled by always writing data to temporary files and renaming these files to actual files when a file is finalized (closed) for writing, that is, we are sure that no more data will be written to it. The relevant configuration item is:     alwaysWriteToTmp : enables/disables writing to a temporary file.  Default : true.   Most of the complexity in the code comes from making this operator fault-tolerant.",
            "title": "Fault-tolerance"
        },
        {
            "location": "/operators/file_output/#checkpointed-states-needed-for-fault-tolerance",
            "text": "endOffsets : contains the size of each file as it is being updated by the operator. It helps the operator to restore a file during recovery in operator  setup(...)  and is also used while loading a stream to find out if the operator has seen a file before.    fileNameToTmpName : contains the name of the temporary file per actual file. It is needed because the name of a temporary file is random. They are named based on the timestamp when the stream is created. During recovery the operator needs to know the temp file which it was writing to and if it needs restoration then it creates a new temp file and updates this mapping.    finalizedFiles : contains set of files which were requested to be finalized per window id.    finalizedPart : contains the latest  part  of each file which was requested to be finalized.    The use of  finalizedFiles  and  finalizedPart  are explained in detail under  requestFinalize(...)  method.",
            "title": "Checkpointed states needed for fault-tolerance"
        },
        {
            "location": "/operators/file_output/#recovering-files",
            "text": "When the operator is re-deployed, it checks in its  setup(...)  method if the state of a file which it has seen before the failure is consistent with the file's state on the file system, that is, the size of the file on the file system should match the size in the  endOffsets . When it doesn't the operator truncates the file.  For example, let's say the operator wrote 100 bytes to test1.txt by the end of window 10. It wrote another 20 bytes by the end of window 12 but failed in window 13. When the operator gets re-deployed it is restored with window 10 (recovery checkpoint) state. In the previous run, by the end of window 10, the size of file on the filesystem was 100 bytes but now it is 120 bytes. Tuples for windows 11 and 12 are going to be replayed. Therefore, in order to avoid writing duplicates to test1.txt, the operator truncates the file to 100 bytes (size at the end of window 10) discarding the last 20 bytes.",
            "title": "Recovering files"
        },
        {
            "location": "/operators/file_splitter/",
            "text": "File Splitter\n\n\nThis is a simple operator whose main function is to split a file virtually and create metadata describing the files and the splits. \n\n\nWhy is it needed?\n\n\nIt is a common operation to read a file and parse it. This operation can be parallelized by having multiple partitions of such operators and each partition operating on different files. However, at times when a file is large then a single partition reading it can become a bottleneck.\nIn these cases, throughput can be increased if instances of the partitioned operator can read and parse non-overlapping sets of file blocks. This is where file splitter comes in handy. It creates metadata of blocks of file which serves as tasks handed out to downstream operator partitions. \nThe downstream partitions can read/parse the block without the need of interacting with other partitions.\n\n\nClass Diagram\n\n\n\n\nAbstractFileSplitter\n\n\nThe abstract implementation defines the logic of processing \nFileInfo\n. This comprises the following tasks -  \n\n\n\n\n\n\nbuilding \nFileMetadata\n per file and emitting it. This metadata contains the file information such as filepath, no. of blocks in it, length of the file, all the block ids, etc.\n\n\n\n\n\n\ncreating \nBlockMetadataIterator\n from \nFileMetadata\n. The iterator lazy-loads the block metadata when needed. We use an iterator because the no. of blocks in a file can be huge if the block size is small and loading all of them at once in memory may cause out of memory errors.\n\n\n\n\n\n\nretrieving \nBlockMetadata.FileBlockMetadata\n from the block metadata iterator and emitting it. The FileBlockMetadata contains the block id, start offset of the block, length of file in the block, etc. The number of block metadata emitted per window are controlled by \nblocksThreshold\n setting which by default is 1.  \n\n\n\n\n\n\nThe main utility method that performs all the above tasks is the \nprocess()\n method. Concrete implementations can invoke this method whenever they have data to process.\n\n\nPorts\n\n\nDeclares only output ports on which file metadata and block metadata are emitted.\n\n\n\n\nfilesMetadataOutput: metadata for each file is emitted on this port. \n\n\nblocksMetadataOutput: metadata for each block is emitted on this port. \n\n\n\n\nprocess()\n method\n\n\nWhen process() is invoked, any pending blocks from the current file are emitted on the 'blocksMetadataOutput' port. If the threshold for blocks per window is still not met then a new input file is processed - corresponding metadata is emitted on 'filesMetadataOutput' and more of its blocks are emitted. This operation is repeated until the \nblocksThreshold\n is reached or there are no more new files.\n\n\n  protected void process()\n  {\n    if (blockMetadataIterator != null && blockCount < blocksThreshold) {\n      emitBlockMetadata();\n    }\n\n    FileInfo fileInfo;\n    while (blockCount < blocksThreshold && (fileInfo = getFileInfo()) != null) {\n      if (!processFileInfo(fileInfo)) {\n        break;\n      }\n    }\n  }\n\n\n\n\nAbstract methods\n\n\n\n\n\n\nFileInfo getFileInfo()\n: called from within the \nprocess()\n and provides the next file to process.\n\n\n\n\n\n\nlong getDefaultBlockSize()\n: provides the block size which is used when user hasn't configured the size.\n\n\n\n\n\n\nFileStatus getFileStatus(Path path)\n: provides the \norg.apache.hadoop.fs.FileStatus\n instance for a path.   \n\n\n\n\n\n\nConfiguration\n\n\n\n\nblockSize\n: size of a block.\n\n\nblocksThreshold\n: threshold on the number of blocks emitted by file splitter every window. This setting is used for throttling the work for downstream operators.\n\n\n\n\nFileSplitterBase\n\n\nSimple operator that receives tuples of type \nFileInfo\n on its \ninput\n port. \nFileInfo\n contains the information (currently just the file path) about the file which this operator uses to create file metadata and block metadata.\n\n\nExample application\n\n\nThis is a simple sub-dag that demonstrates how FileSplitterBase can be plugged into an application.\n\n\n\nThe upstream operator emits tuples of type \nFileInfo\n on its output port which is connected to splitter input port. The downstream receives tuples of type \nBlockMetadata.FileBlockMetadata\n from the splitter's block metadata output port.\n\n\npublic class ApplicationWithBaseSplitter implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    JMSInput input = dag.addOperator(\"Input\", new JMSInput());\n    FileSplitterBase splitter = dag.addOperator(\"Splitter\", new FileSplitterBase());\n    FSSliceReader blockReader = dag.addOperator(\"BlockReader\", new FSSliceReader());\n    ...\n    dag.addStream(\"file-info\", input.output, splitter.input);\n    dag.addStream(\"block-metadata\", splitter.blocksMetadataOutput, blockReader.blocksMetadataInput);\n    ...\n  }\n\n  public static class JMSInput extends AbstractJMSInputOperator<AbstractFileSplitter.FileInfo>\n  {\n\n    public final transient DefaultOutputPort<AbstractFileSplitter.FileInfo> output = new DefaultOutputPort<>();\n\n    @Override\n    protected AbstractFileSplitter.FileInfo convert(Message message) throws JMSException\n    {\n      //assuming the message is a text message containing the absolute path of the file.\n      return new AbstractFileSplitter.FileInfo(null, ((TextMessage)message).getText());\n    }\n\n    @Override\n    protected void emit(AbstractFileSplitter.FileInfo payload)\n    {\n      output.emit(payload);\n    }\n  }\n}\n\n\n\n\nPorts\n\n\nDeclares an input port on which it receives tuples from the upstream operator. Output ports are inherited from AbstractFileSplitter.\n\n\n\n\ninput: non optional port on which tuples of type \nFileInfo\n are received.\n\n\n\n\nConfiguration\n\n\n\n\nfile\n: path of the file from which the filesystem is inferred. FileSplitter creates an instance of \norg.apache.hadoop.fs.FileSystem\n which is why this path is needed.  \n\n\n\n\nFileSystem.newInstance(new Path(file).toUri(), new Configuration());\n\n\n\n\nThe fs instance is then used to fetch the default block size and \norg.apache.hadoop.fs.FileStatus\n for each file path.\n\n\nFileSplitterInput\n\n\nThis is an input operator that discovers files itself. The scanning of the directories for new files is asynchronous which is handled by \nTimeBasedDirectoryScanner\n. The function of TimeBasedDirectoryScanner is to periodically scan specified directories and find files which were newly added or modified. The interaction between the operator and the scanner is depicted in the diagram below.\n\n\n\n\nExample application\n\n\nThis is a simple sub-dag that demonstrates how FileSplitterInput can be plugged into an application.\n\n\n\n\nSplitter is the input operator here that sends block metadata to the downstream BlockReader.\n\n\n  @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    FileSplitterInput input = dag.addOperator(\"Input\", new FileSplitterInput());\n    FSSliceReader reader = dag.addOperator(\"Block Reader\", new FSSliceReader());\n    ...\n    dag.addStream(\"block-metadata\", input.blocksMetadataOutput, reader.blocksMetadataInput);\n    ...\n  }\n\n\n\n\n\nPorts\n\n\nSince it is an input operator there are no input ports and output ports are inherited from AbstractFileSplitter.\n\n\nConfiguration\n\n\n\n\nscanner\n: the component that scans directories asynchronously. It is of type \ncom.datatorrent.lib.io.fs.FileSplitter.TimeBasedDirectoryScanner\n. The basic implementation of TimeBasedDirectoryScanner can be customized by users.  \n\n\n\n\na. \nfiles\n: comma separated list of directories to scan.  \n\n\nb. \nrecursive\n: flag that controls whether the directories should be scanned recursively.  \n\n\nc. \nscanIntervalMillis\n: interval specified in milliseconds after which another scan iteration is triggered.  \n\n\nd. \nfilePatternRegularExp\n: regular expression for accepted file names.  \n\n\ne. \ntrigger\n: a flag that triggers a scan iteration instantly. If the scanner thread is idling then it will initiate a scan immediately otherwise if a scan is in progress, then the new iteration will be triggered immediately after the completion of current one.\n2. \nidempotentStorageManager\n: by default FileSplitterInput is idempotent. \nIdempotency ensures that the operator will process the same set of files/blocks in a window if it has seen that window previously, i.e., before a failure. For example, let's say the operator completed window 10 and failed somewhere between window 11. If the operator gets restored at window 10 then it will process the same file/block again in window 10 which it did in the previous run before the failure. Idempotency is important but comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window. Therefore, if one doesn't care about idempotency then they can set this property to be an instance of \ncom.datatorrent.lib.io.IdempotentStorageManager.NoopIdempotentStorageManager\n.\n\n\nHandling of split records\n\n\nSplitting of files to create tasks for downstream operator needs to be a simple operation that doesn't consume a lot of resources and is fast. This is why the file splitter doesn't open files to read. The downside of that is if the file contains records then a record may split across adjacent blocks. Handling of this is left to the downstream operator.\n\n\nWe have created Block readers in Apex-malhar library that handle line splits efficiently. The 2 line readers- \nAbstractFSLineReader\n and \nAbstractFSReadAheadLineReader\n can be found here \nAbstractFSBlockReader\n.",
            "title": "File Splitter"
        },
        {
            "location": "/operators/file_splitter/#file-splitter",
            "text": "This is a simple operator whose main function is to split a file virtually and create metadata describing the files and the splits.",
            "title": "File Splitter"
        },
        {
            "location": "/operators/file_splitter/#why-is-it-needed",
            "text": "It is a common operation to read a file and parse it. This operation can be parallelized by having multiple partitions of such operators and each partition operating on different files. However, at times when a file is large then a single partition reading it can become a bottleneck.\nIn these cases, throughput can be increased if instances of the partitioned operator can read and parse non-overlapping sets of file blocks. This is where file splitter comes in handy. It creates metadata of blocks of file which serves as tasks handed out to downstream operator partitions. \nThe downstream partitions can read/parse the block without the need of interacting with other partitions.",
            "title": "Why is it needed?"
        },
        {
            "location": "/operators/file_splitter/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/file_splitter/#abstractfilesplitter",
            "text": "The abstract implementation defines the logic of processing  FileInfo . This comprises the following tasks -      building  FileMetadata  per file and emitting it. This metadata contains the file information such as filepath, no. of blocks in it, length of the file, all the block ids, etc.    creating  BlockMetadataIterator  from  FileMetadata . The iterator lazy-loads the block metadata when needed. We use an iterator because the no. of blocks in a file can be huge if the block size is small and loading all of them at once in memory may cause out of memory errors.    retrieving  BlockMetadata.FileBlockMetadata  from the block metadata iterator and emitting it. The FileBlockMetadata contains the block id, start offset of the block, length of file in the block, etc. The number of block metadata emitted per window are controlled by  blocksThreshold  setting which by default is 1.      The main utility method that performs all the above tasks is the  process()  method. Concrete implementations can invoke this method whenever they have data to process.",
            "title": "AbstractFileSplitter"
        },
        {
            "location": "/operators/file_splitter/#ports",
            "text": "Declares only output ports on which file metadata and block metadata are emitted.   filesMetadataOutput: metadata for each file is emitted on this port.   blocksMetadataOutput: metadata for each block is emitted on this port.",
            "title": "Ports"
        },
        {
            "location": "/operators/file_splitter/#abstract-methods",
            "text": "FileInfo getFileInfo() : called from within the  process()  and provides the next file to process.    long getDefaultBlockSize() : provides the block size which is used when user hasn't configured the size.    FileStatus getFileStatus(Path path) : provides the  org.apache.hadoop.fs.FileStatus  instance for a path.",
            "title": "Abstract methods"
        },
        {
            "location": "/operators/file_splitter/#configuration",
            "text": "blockSize : size of a block.  blocksThreshold : threshold on the number of blocks emitted by file splitter every window. This setting is used for throttling the work for downstream operators.",
            "title": "Configuration"
        },
        {
            "location": "/operators/file_splitter/#filesplitterbase",
            "text": "Simple operator that receives tuples of type  FileInfo  on its  input  port.  FileInfo  contains the information (currently just the file path) about the file which this operator uses to create file metadata and block metadata.",
            "title": "FileSplitterBase"
        },
        {
            "location": "/operators/file_splitter/#example-application",
            "text": "This is a simple sub-dag that demonstrates how FileSplitterBase can be plugged into an application.  The upstream operator emits tuples of type  FileInfo  on its output port which is connected to splitter input port. The downstream receives tuples of type  BlockMetadata.FileBlockMetadata  from the splitter's block metadata output port.  public class ApplicationWithBaseSplitter implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    JMSInput input = dag.addOperator(\"Input\", new JMSInput());\n    FileSplitterBase splitter = dag.addOperator(\"Splitter\", new FileSplitterBase());\n    FSSliceReader blockReader = dag.addOperator(\"BlockReader\", new FSSliceReader());\n    ...\n    dag.addStream(\"file-info\", input.output, splitter.input);\n    dag.addStream(\"block-metadata\", splitter.blocksMetadataOutput, blockReader.blocksMetadataInput);\n    ...\n  }\n\n  public static class JMSInput extends AbstractJMSInputOperator<AbstractFileSplitter.FileInfo>\n  {\n\n    public final transient DefaultOutputPort<AbstractFileSplitter.FileInfo> output = new DefaultOutputPort<>();\n\n    @Override\n    protected AbstractFileSplitter.FileInfo convert(Message message) throws JMSException\n    {\n      //assuming the message is a text message containing the absolute path of the file.\n      return new AbstractFileSplitter.FileInfo(null, ((TextMessage)message).getText());\n    }\n\n    @Override\n    protected void emit(AbstractFileSplitter.FileInfo payload)\n    {\n      output.emit(payload);\n    }\n  }\n}",
            "title": "Example application"
        },
        {
            "location": "/operators/file_splitter/#ports_1",
            "text": "Declares an input port on which it receives tuples from the upstream operator. Output ports are inherited from AbstractFileSplitter.   input: non optional port on which tuples of type  FileInfo  are received.",
            "title": "Ports"
        },
        {
            "location": "/operators/file_splitter/#configuration_1",
            "text": "file : path of the file from which the filesystem is inferred. FileSplitter creates an instance of  org.apache.hadoop.fs.FileSystem  which is why this path is needed.     FileSystem.newInstance(new Path(file).toUri(), new Configuration());  The fs instance is then used to fetch the default block size and  org.apache.hadoop.fs.FileStatus  for each file path.",
            "title": "Configuration"
        },
        {
            "location": "/operators/file_splitter/#filesplitterinput",
            "text": "This is an input operator that discovers files itself. The scanning of the directories for new files is asynchronous which is handled by  TimeBasedDirectoryScanner . The function of TimeBasedDirectoryScanner is to periodically scan specified directories and find files which were newly added or modified. The interaction between the operator and the scanner is depicted in the diagram below.",
            "title": "FileSplitterInput"
        },
        {
            "location": "/operators/file_splitter/#example-application_1",
            "text": "This is a simple sub-dag that demonstrates how FileSplitterInput can be plugged into an application.   Splitter is the input operator here that sends block metadata to the downstream BlockReader.    @Override\n  public void populateDAG(DAG dag, Configuration configuration)\n  {\n    FileSplitterInput input = dag.addOperator(\"Input\", new FileSplitterInput());\n    FSSliceReader reader = dag.addOperator(\"Block Reader\", new FSSliceReader());\n    ...\n    dag.addStream(\"block-metadata\", input.blocksMetadataOutput, reader.blocksMetadataInput);\n    ...\n  }",
            "title": "Example application"
        },
        {
            "location": "/operators/file_splitter/#ports_2",
            "text": "Since it is an input operator there are no input ports and output ports are inherited from AbstractFileSplitter.",
            "title": "Ports"
        },
        {
            "location": "/operators/file_splitter/#configuration_2",
            "text": "scanner : the component that scans directories asynchronously. It is of type  com.datatorrent.lib.io.fs.FileSplitter.TimeBasedDirectoryScanner . The basic implementation of TimeBasedDirectoryScanner can be customized by users.     a.  files : comma separated list of directories to scan.    b.  recursive : flag that controls whether the directories should be scanned recursively.    c.  scanIntervalMillis : interval specified in milliseconds after which another scan iteration is triggered.    d.  filePatternRegularExp : regular expression for accepted file names.    e.  trigger : a flag that triggers a scan iteration instantly. If the scanner thread is idling then it will initiate a scan immediately otherwise if a scan is in progress, then the new iteration will be triggered immediately after the completion of current one.\n2.  idempotentStorageManager : by default FileSplitterInput is idempotent. \nIdempotency ensures that the operator will process the same set of files/blocks in a window if it has seen that window previously, i.e., before a failure. For example, let's say the operator completed window 10 and failed somewhere between window 11. If the operator gets restored at window 10 then it will process the same file/block again in window 10 which it did in the previous run before the failure. Idempotency is important but comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window. Therefore, if one doesn't care about idempotency then they can set this property to be an instance of  com.datatorrent.lib.io.IdempotentStorageManager.NoopIdempotentStorageManager .",
            "title": "Configuration"
        },
        {
            "location": "/operators/file_splitter/#handling-of-split-records",
            "text": "Splitting of files to create tasks for downstream operator needs to be a simple operation that doesn't consume a lot of resources and is fast. This is why the file splitter doesn't open files to read. The downside of that is if the file contains records then a record may split across adjacent blocks. Handling of this is left to the downstream operator.  We have created Block readers in Apex-malhar library that handle line splits efficiently. The 2 line readers-  AbstractFSLineReader  and  AbstractFSReadAheadLineReader  can be found here  AbstractFSBlockReader .",
            "title": "Handling of split records"
        },
        {
            "location": "/operators/filter/",
            "text": "Filter\n\n\nOperator Objective\n\n\nThis operator receives an POJO (\nPlain Old Java Object\n) as an incoming tuple\nand based on the filter condition it emits filtered tuples on one output port and rest on another output port.\n\n\nFilter operator supports quasi Java expressions to specify filter rule.\n\n\nFilter operator does not hold any state and is \nidempotent\n, \nfault-tolerant\n and \nstatically/dynamically partitionable\n.\n\n\nOperator Usecase\n\n\n\n\nCustomer data\n usually contains a field customer category/segment. One wants some analysis to be done for specific customer segment. One could use this filter operator to filter the records based on segment for some analysis for specific customer segment. \n\n\nLog data\n processing pipeline may want to filter logs from specific machine/router/switch.\n\n\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-library\n\n\nAvailable since: \n3.5.0\n\n\nOperator state: \nEvolving\n\n\nJava Packages:\n\n\nOperator: \ncom.datatorrent.lib.filter.FilterOperator\n\n\n\n\n\n\n\n\nProperties, Attributes and Ports\n\n\nProperties of FilterOperator\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\ncondition/expression with which Filtering is done.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nadditionalExpressionFunctions\n\n\nList of import classes/method that should be made statically available to expression to use.\n\n\nList<String>\n\n\nNo\n\n\nEmpty List\n\n\n\n\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nport.input.attr.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on input port indicates the class of POJO which incoming tuple\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nConnection Required\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nTuple which needs to be filtered are received on this port\n\n\nObject (POJO)\n\n\nYes\n\n\n\n\n\n\ntruePort\n\n\nTuples which satisfies \ncondition\n are emitted on this port\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nfalsePort\n\n\nTuples which does not satisfy \ncondition\n are emitted on this port\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\n\n\nLimitations\n\n\nCurrent \nFilterOperator\n has following limitation:\n\n\n\n\nAPEXMALHAR-2175\n : Filter condition is not able to correctly handle java reserved words.\n\n\n\n\nExample\n\n\nExample for \nFilterOperator\n can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/filter",
            "title": "Filter"
        },
        {
            "location": "/operators/filter/#filter",
            "text": "",
            "title": "Filter"
        },
        {
            "location": "/operators/filter/#operator-objective",
            "text": "This operator receives an POJO ( Plain Old Java Object ) as an incoming tuple\nand based on the filter condition it emits filtered tuples on one output port and rest on another output port.  Filter operator supports quasi Java expressions to specify filter rule.  Filter operator does not hold any state and is  idempotent ,  fault-tolerant  and  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/filter/#operator-usecase",
            "text": "Customer data  usually contains a field customer category/segment. One wants some analysis to be done for specific customer segment. One could use this filter operator to filter the records based on segment for some analysis for specific customer segment.   Log data  processing pipeline may want to filter logs from specific machine/router/switch.",
            "title": "Operator Usecase"
        },
        {
            "location": "/operators/filter/#operator-information",
            "text": "Operator location:  malhar-library  Available since:  3.5.0  Operator state:  Evolving  Java Packages:  Operator:  com.datatorrent.lib.filter.FilterOperator",
            "title": "Operator Information"
        },
        {
            "location": "/operators/filter/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/filter/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      port.input.attr.TUPLE_CLASS  TUPLE_CLASS attribute on input port indicates the class of POJO which incoming tuple  Class or FQCN  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/filter/#ports",
            "text": "Port  Description  Type  Connection Required      input  Tuple which needs to be filtered are received on this port  Object (POJO)  Yes    truePort  Tuples which satisfies  condition  are emitted on this port  Object (POJO)  No    falsePort  Tuples which does not satisfy  condition  are emitted on this port  Object (POJO)  No",
            "title": "Ports"
        },
        {
            "location": "/operators/filter/#limitations",
            "text": "Current  FilterOperator  has following limitation:   APEXMALHAR-2175  : Filter condition is not able to correctly handle java reserved words.",
            "title": "Limitations"
        },
        {
            "location": "/operators/filter/#example",
            "text": "Example for  FilterOperator  can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/filter",
            "title": "Example"
        },
        {
            "location": "/operators/fixedWidthParserOperator/",
            "text": "Fixed Width Parser Operator\n\n\nOperator Objective\n\n\nThis operator is designed to parse fixed width records and construct a map or concrete java class also known as \n\"POJO\"\n out of it. User needs to provide the schema to describe the fixed width data. The incoming records will be parsed according to the schema and either a map or a POJO (or both) is emitted.\nInvalid records will be emitted on the error port along with an error message.\n\n\nNote\n: field names in the schema must match field names of the POJO and must be in the same order as it appears in the incoming data.\n\n\nFixedWidthParser is \nidempotent\n, \nfault-tolerant\n and \nstatically/dynamically partitionable\n.\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location:\nmalhar-contrib\n\n\nAvailable since:\n3.8.0\n\n\nOperator state:\nEvolving\n\n\nJava Package:\ncom.datatorrent.contrib.parser.FixedWidthParser\n\n\n\n\nProperties of FixedWidthParser\n\n\nData in a fixed-width text file is arranged in rows and columns, with one entry per row. Fixed width record is one row in a fixed-width file.  Each column has a fixed width, specified in characters, which determines the maximum amount of data it can contain.  No delimiters are used to separate the fields in the file.  Instead, the data is left- or right- justified in its column as specified by the \nalignment\n value of the schema and the remaining space is filled by the padding character also specified in the schema, such that the start of a given column can always be specified as an offset from the beginning of a line.\n\n\nUser needs to set the schema which describes fixed width data.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\njsonSchema\n\n\nSchema\n  describing fixed width data. Based on schema definition the operator will parse the incoming record to object map and POJO. Valid records will be emitted as POJO / map while invalid ones are emitted on error port with error message.\n\n\nString\n\n\nYES\n\n\nN/A\n\n\n\n\n\n\n\n\nUser can set this property in \nproperties.xml\n in the following way:\n\n\n<property>\n    <name>\n      dt.application.{ApplicationName}.operator.{OperatorName}.prop.jsonSchema\n    </name>\n    <value>\n    {\n      \"padding\": \"_\",\n      \"alignment\": \"left\",\n      \"fields\":\n      [\n        {\n          \"name\": \"adId\",\n          \"type\": \"Integer\",\n          \"length\": \"3\",\n          \"padding\": \"0\"\n        },\n        {\n          \"name\": \"campaignId\",\n          \"type\": \"Integer\",\n          \"length\": \"3\",\n          \"padding\": \" \"\n        },\n        {\n          \"name\": \"adName\",\n          \"type\": \"String\",\n          \"length\": \"10\",\n          \"alignment\":\"right\"\n        },\n        {\n          \"name\": \"bidPrice\",\n          \"type\": \"Double\",\n          \"length\": \"3\"\n        },\n        {\n          \"name\": \"startDate\",\n          \"type\": \"Date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss\",\n          \"length\": \"19\"\n        },\n        {\n          \"name\": \"endDate\",\n          \"type\": \"Date\",\n          \"format\": \"dd/MM/yyyy\",\n          \"length\": \"10\"\n        },\n        {\n          \"name\": \"securityCode\",\n          \"type\": \"Long\",\n          \"length\": \"5\"\n        },\n        {\n          \"name\": \"active\",\n          \"type\": \"Boolean\",\n          \"length\": \"5\",\n          \"trueValue\": \"true\",\n          \"falseValue\": \"false\"\n        },\n        {\n          \"name\": \"optimized\",\n          \"type\": \"Boolean\",\n          \"length\": \"1\",\n          \"trueValue\": \"y\",\n          \"falseValue\": \"n\"\n        },\n        {\n          \"name\": \"parentCampaign\",\n          \"type\": \"String\",\n          \"length\": \"10\"\n        },\n        {\n          \"name\": \"weatherTargeted\",\n          \"type\": \"Character\",\n          \"length\": \"1\"\n        }\n      ]\n    }\n    </value>\n</property>\n\n\n\n\nWhere {OperatorName} is the name of the Operator and {ApplicationName} is the name of the application.\nAs explained earlier padding is a character used to specify padding used in the incoming records to fill the fixed width if required. User has the flexibility to specify a single padding character for the entire file or the user can choose to provide separate padding character for separate fields (columns of the record). The padding value for separate fields (if specified) over rides the padding value (global) (if specified) for the entire file.\nSimilar to padding character user also has the flexibility to define the alignment of the incoming records, user can choose whether the record is left,centre or right aligned. Note that currently only British spelling for 'centre' is accepted.\n\n\nThe sample json schema for records having 3 fields 'Occupation', 'Age' and 'Gender' with field widths 20,2 and 6, padding characters '#','$' and '@' and alignments 'left', 'centre' and 'right' will be as follows:\n\n\n{\n  \"fields\":\n  [\n    {\n      \"name\": \"Occupation\",\n      \"type\": \"String\",\n      \"length\": \"20\",\n      \"padding\": \"#\",\n      \"alignment\":\"left\"\n    },\n    {\n      \"name\": \"Age\",\n      \"type\": \"Integer\",\n      \"length\": \"2\",\n      \"padding\": \"$\",\n      \"alignment\":\"centre\"\n    },\n    {\n      \"name\": \"Gender\",\n      \"type\": \"String\",\n      \"length\": \"6\",\n      \"padding\": \"@\",\n      \"alignment\":\"right\"\n    }\n}\n\n\n\n\nThe corresponding record with values for 'Occupation' as Engineer, 'Age' as 30 and 'Gender' as Male would be as follows:\n\n\nEngineer############30@@Male\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nTUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted\n\n\nClass\n\n\nYes\n\n\n\n\n\n\n\n\nUser can set this property in \nproperties.xml\n in the following way:\nIn the examples below, {OperatorName} is the name of the Operator, {ApplicationName} is the name of the application and \"com.datatorrent.tutorial.fixedwidthparser.Ad\" is the fully qualified name of the Tuple class\n\n\n<property>\n    <name>dt.application.{ApplicationName}.operator.{OperatorName}.port.out.attr.TUPLE_CLASS</name>\n    <value>com.datatorrent.tutorial.fixedwidthparser.Ad</value>\n</property>\n\n\n\n\nFollowing code can be added to \npopulateDAG()\n method of application to set Tuple Class:\n\n\ndag.setOutputPortAttribute({OperatorName}.out, Context.PortContext.TUPLE_CLASS, com.datatorrent.tutorial.fixedwidthparser.Ad.class);\n\n\n\n\nSupported DataTypes in Schema\n\n\n\n\nInteger\n\n\nLong\n\n\nDouble\n\n\nCharacter\n\n\nString\n\n\nBoolean\n\n\nDate\n\n\nFloat\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be parsed are received on this port\n\n\nbyte[]\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid Tuples that are emitted as pojo\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nparsedOutput\n\n\nValid Tuples that are emitted as maps\n\n\nMap\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid Tuples are emitted with error message\n\n\nKeyValPair <String, String>\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nFixed Width Parser is both statically and dynamically partitionable.\n\n\nStatic Partitioning\n\n\nStatic partitioning can be achieved by specifying the partitioner and number of partitions in the populateDAG() method.\n\n\nFixedWidthParser fixedWidthParser = dag.addOperator(\"fixedWidthParser\", FixedWidthParser.class);\nStatelessPartitioner<FixedWidthParser> partitioner1 = new StatelessPartitioner<FixedWidthParser>(2);\ndag.setAttribute(fixedWidthParser, Context.OperatorContext.PARTITIONER, partitioner1);\n\n\n\n\nStatic partitioning can also be achieved by specifying the partitioner in properties file.\n\n\n<property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n</property>\n\n\n\n\nwhere {OperatorName} is the name of the FixedWidthParser operator. Above lines will partition FixedWidthParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partioning\n\n\nFixedWidthParser can be dynamically partitioned using out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to \npopulateDAG()\n method of application to dynamically partition FixedWidthParser:\n\n\nFixedWidthParser fixedWidthParser = dag.addOperator(\"fixedWidthParser\", FixedWidthParser.class);\nStatelessThroughputBasedPartitioner<FixedWidthParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(\"dt.cooldown\", 10000));\npartitioner.setMaximumEvents(conf.getLong(\"dt.maxThroughput\", 30000));\npartitioner.setMinimumEvents(conf.getLong(\"dt.minThroughput\", 10000));\ndag.setAttribute(fixedWidthParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(fixedWidthParser, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition FixedWidthParser when the throughput changes.\nIf the overall throughput of FixedWidthParser goes beyond 30000 or less than 10000, the platform will repartition FixedWidthParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nExample for Fixed Width Parser can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Fixed Width Parser"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#fixed-width-parser-operator",
            "text": "",
            "title": "Fixed Width Parser Operator"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#operator-objective",
            "text": "This operator is designed to parse fixed width records and construct a map or concrete java class also known as  \"POJO\"  out of it. User needs to provide the schema to describe the fixed width data. The incoming records will be parsed according to the schema and either a map or a POJO (or both) is emitted.\nInvalid records will be emitted on the error port along with an error message.  Note : field names in the schema must match field names of the POJO and must be in the same order as it appears in the incoming data.  FixedWidthParser is  idempotent ,  fault-tolerant  and  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#operator-information",
            "text": "Operator location: malhar-contrib  Available since: 3.8.0  Operator state: Evolving  Java Package: com.datatorrent.contrib.parser.FixedWidthParser",
            "title": "Operator Information"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted  Class  Yes     User can set this property in  properties.xml  in the following way:\nIn the examples below, {OperatorName} is the name of the Operator, {ApplicationName} is the name of the application and \"com.datatorrent.tutorial.fixedwidthparser.Ad\" is the fully qualified name of the Tuple class  <property>\n    <name>dt.application.{ApplicationName}.operator.{OperatorName}.port.out.attr.TUPLE_CLASS</name>\n    <value>com.datatorrent.tutorial.fixedwidthparser.Ad</value>\n</property>  Following code can be added to  populateDAG()  method of application to set Tuple Class:  dag.setOutputPortAttribute({OperatorName}.out, Context.PortContext.TUPLE_CLASS, com.datatorrent.tutorial.fixedwidthparser.Ad.class);",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be parsed are received on this port  byte[]  Yes    out  Valid Tuples that are emitted as pojo  Object (POJO)  No    parsedOutput  Valid Tuples that are emitted as maps  Map  No    err  Invalid Tuples are emitted with error message  KeyValPair <String, String>  No",
            "title": "Ports"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#partitioning",
            "text": "Fixed Width Parser is both statically and dynamically partitionable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#static-partitioning",
            "text": "Static partitioning can be achieved by specifying the partitioner and number of partitions in the populateDAG() method.  FixedWidthParser fixedWidthParser = dag.addOperator(\"fixedWidthParser\", FixedWidthParser.class);\nStatelessPartitioner<FixedWidthParser> partitioner1 = new StatelessPartitioner<FixedWidthParser>(2);\ndag.setAttribute(fixedWidthParser, Context.OperatorContext.PARTITIONER, partitioner1);  Static partitioning can also be achieved by specifying the partitioner in properties file.  <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n</property>  where {OperatorName} is the name of the FixedWidthParser operator. Above lines will partition FixedWidthParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#dynamic-partioning",
            "text": "FixedWidthParser can be dynamically partitioned using out-of-the-box partitioner:",
            "title": "Dynamic Partioning"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#throughput-based",
            "text": "Following code can be added to  populateDAG()  method of application to dynamically partition FixedWidthParser:  FixedWidthParser fixedWidthParser = dag.addOperator(\"fixedWidthParser\", FixedWidthParser.class);\nStatelessThroughputBasedPartitioner<FixedWidthParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(\"dt.cooldown\", 10000));\npartitioner.setMaximumEvents(conf.getLong(\"dt.maxThroughput\", 30000));\npartitioner.setMinimumEvents(conf.getLong(\"dt.minThroughput\", 10000));\ndag.setAttribute(fixedWidthParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(fixedWidthParser, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition FixedWidthParser when the throughput changes.\nIf the overall throughput of FixedWidthParser goes beyond 30000 or less than 10000, the platform will repartition FixedWidthParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/fixedWidthParserOperator/#example",
            "text": "Example for Fixed Width Parser can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Example"
        },
        {
            "location": "/operators/ftpInputOperator/",
            "text": "FTP Input Operator\n\n\nOperator Objective\n\n\nThis operator(\nAbstractFTPInputOperator\n) is designed to scan a directory from an FTP server for files, read\nand split file content into tuples such as lines or blocks of bytes, and finally\nemit them on the output port for further processing by downstream operators.\nThe operator extends the \nAbstractFileInputOperator\n. It overrides the\ngetFSInstance() method and returns an instance of the FTPFileSystem\n(\norg.apache.hadoop.fs.ftp.FTPFileSystem\n)\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location : \nmalhar-lib\n\n\nAvailable since : \n2.0.0\n\n\nJava Package : \ncom.datatorrent.lib.io\n\n\n\n\nPorts\n\n\nBecause this is an input operator, there are no input ports.\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutput\n\n\noutput port on which data is emitted\n\n\nString\n\n\nYes\n\n\n\n\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nthe hostname of the FTP Server\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nsource\n\n\nthe directory path from where to scan and read files\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nusername\n\n\nthe username for authenticating against the FTP server. This is an optional property and can be skipped when anonymous FTP is enabled\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\npassword\n\n\nthe password to be used in conjunction with the above username\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nPartitioning\n\n\nStatic Partitioning\n\n\nConfigure parameter \npartitionCount\n to define the desired number of initial partitions\n(4 in this example).\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.partitionCount</name>\n  <value>4</value>\n</property>\n\n\n\n\nAlternatively, this can be changed in the application code by setting the operator property \npartitionCount\n to the desired number of partitions:\n\n\nFTPStringInputOperator reader = dag.addOperator(\"Reader\", new FTPStringInputOperator());\nreader.setPartitionCount(4);\n\n\n\n\nDynamic Partitioning\n\n\nDynamic partitioning -- changing the number of partitions of one or more operators\nin a running application -- can be achieved in multiple ways:\n- Use the command line tool \napex\n or the UI console to change the value of the\n  \npartitionCount\n property of the running operator. This change is detected in\n  \nprocessStats()\n (which is invoked periodically by the platform) where, if the\n  current partition count (\ncurrentPartitions\n) and the desired partition count\n  (\npartitionCount\n) differ, the \nrepartitionRequired\n flag in the response is set.\n  This causes the platform to invoke \ndefinePartitions()\n to create a new set of\n  partitions with the desired count.\n- Override \nprocessStats()\n and within it, based on the statistics in the\n  incoming parameter or any other factors, define a new desired value of\n  \npartitionCount\n and finally, if this value differs from the current partition\n  count, set the \nrepartitionRequired\n flag in the response.\n\n\nExample application\n\n\nAn example application for the FTP input operator can be found at \nhttps://github.com/apache/apex-malhar/tree/master/examples/ftp",
            "title": "FTP Input Operator"
        },
        {
            "location": "/operators/ftpInputOperator/#ftp-input-operator",
            "text": "",
            "title": "FTP Input Operator"
        },
        {
            "location": "/operators/ftpInputOperator/#operator-objective",
            "text": "This operator( AbstractFTPInputOperator ) is designed to scan a directory from an FTP server for files, read\nand split file content into tuples such as lines or blocks of bytes, and finally\nemit them on the output port for further processing by downstream operators.\nThe operator extends the  AbstractFileInputOperator . It overrides the\ngetFSInstance() method and returns an instance of the FTPFileSystem\n( org.apache.hadoop.fs.ftp.FTPFileSystem )",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/ftpInputOperator/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/ftpInputOperator/#operator-information",
            "text": "Operator location :  malhar-lib  Available since :  2.0.0  Java Package :  com.datatorrent.lib.io",
            "title": "Operator Information"
        },
        {
            "location": "/operators/ftpInputOperator/#ports",
            "text": "Because this is an input operator, there are no input ports.     Port  Description  Type  Mandatory      output  output port on which data is emitted  String  Yes",
            "title": "Ports"
        },
        {
            "location": "/operators/ftpInputOperator/#configuration",
            "text": "Property  Description  Type  Mandatory  Default Value      host  the hostname of the FTP Server  String  Yes  N/A    source  the directory path from where to scan and read files  String  Yes  N/A    username  the username for authenticating against the FTP server. This is an optional property and can be skipped when anonymous FTP is enabled  String  Yes  N/A    password  the password to be used in conjunction with the above username  String  Yes  N/A",
            "title": "Configuration"
        },
        {
            "location": "/operators/ftpInputOperator/#partitioning",
            "text": "",
            "title": "Partitioning"
        },
        {
            "location": "/operators/ftpInputOperator/#static-partitioning",
            "text": "Configure parameter  partitionCount  to define the desired number of initial partitions\n(4 in this example).  <property>\n  <name>dt.operator.{OperatorName}.prop.partitionCount</name>\n  <value>4</value>\n</property>  Alternatively, this can be changed in the application code by setting the operator property  partitionCount  to the desired number of partitions:  FTPStringInputOperator reader = dag.addOperator(\"Reader\", new FTPStringInputOperator());\nreader.setPartitionCount(4);",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/ftpInputOperator/#dynamic-partitioning",
            "text": "Dynamic partitioning -- changing the number of partitions of one or more operators\nin a running application -- can be achieved in multiple ways:\n- Use the command line tool  apex  or the UI console to change the value of the\n   partitionCount  property of the running operator. This change is detected in\n   processStats()  (which is invoked periodically by the platform) where, if the\n  current partition count ( currentPartitions ) and the desired partition count\n  ( partitionCount ) differ, the  repartitionRequired  flag in the response is set.\n  This causes the platform to invoke  definePartitions()  to create a new set of\n  partitions with the desired count.\n- Override  processStats()  and within it, based on the statistics in the\n  incoming parameter or any other factors, define a new desired value of\n   partitionCount  and finally, if this value differs from the current partition\n  count, set the  repartitionRequired  flag in the response.",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/ftpInputOperator/#example-application",
            "text": "An example application for the FTP input operator can be found at  https://github.com/apache/apex-malhar/tree/master/examples/ftp",
            "title": "Example application"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/",
            "text": "JDBC Transactional POJO Output Operator\n\n\nOperator Objective\n\n\nThis operator receives an input stream of POJOs and inserts them as rows in a database table in a fault-tolerant way.\n\n\nOverview\n\n\nThe main features of this operator (\nAbstractJdbcTransactionableOutputOperator\n) are persisting data to the database table and fault tolerance. This operator creates a transaction at the start of each window, executes batches of SQL updates, and closes the transaction at the end of the window. Each tuple corresponds to an SQL update statement. The operator groups the updates in a batch and submits them with one call to the database. Batch processing improves performance considerably. The size of a batch is configured by \nbatchSize\n property. The tuples in a window are stored in a check-pointed collection which is cleared in each \nendWindow()\n call. The operator writes a tuple exactly once in the database.\n\n\nAn (indirect) base class for this operator is \nAbstractPassThruTransactionableStoreOutputOperator\n which implements a pass-through output adapter for a transactional store; it guarantees exactly-once semantics. \"Pass-through\" means it does not wait for end window to write to the store. It will begin transaction at \nbeginWindow\n and write to the store as the tuples come and commit the transaction at \nendWindow\n.\n\n\nThe overall heirarchy is described in the the following diagram:\n\n\n\n\nAbstractTransactionableStoreOutputOperator\n: A skeleton implementation of an output operator that writes to a transactional store; the tuple type and store type are generic parameters. Defines an input port whose process method invokes the processTuple() abstract method. Exactly-once semantics are not guaranteed and must be provided by subclasses if needed.\n\n\nAbstractPassThruTransactionableStoreOutputOperator\n: Simple extension of the above base class which adds exactly-once semantics by starting a transaction in \nbeginWindow()\n and committing it in \nendWindow()\n.\n\n\nAbstractJdbcTransactionableOutputOperator\n: (focus of this document) Adds support for JDBC by using an instance of JdbcTransactionalStore as the store. Also adds support for processing tuples in batches and provides an implementation of the \nproessTuple()\n abstract method mentioned above.\n\n\nAbstractJdbcPOJOOutputOperator\n: Serves as base class for inserting rows in a table using a JDBC store.\n\n\nNote\n: For enforcing exactly once semantics a table named \ndt_meta\n must exist in the database. The sample SQL to create the same is as follows\n\n\n\"CREATE TABLE IF NOT EXISTS dt_meta (dt_app_id VARCHAR(100) NOT NULL, dt_operator_id INT NOT NULL, dt_window BIGINT NOT NULL, UNIQUE(dt_app_id,dt_operator_id,dt_window))\".\n\n\n\n\nNote\n: Additionally this operator assumes that the underlying database/table in which records are to be added supports transactions. If the database/table does not support transactions then a tuple may be inserted in a table more than once in case of auto recovery from a failure (violation of exactly once semantics).\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-library\n\n\nAvailable since: \n0.9.4\n\n\nJava Packages:\n\n\nOperator: \ncom.datatorrent.lib.db.jdbc.AbstractJdbcTransactionableOutputOperator\n\n\n\n\n\n\n\n\nHow to Use?\n\n\nConcrete subclasses need to implement a couple of abstract methods (if not using AbstractJdbcPOJOOutputOperator): \nsetStatementParameters(PreparedStatement statement, T tuple)\n to set the parameter of the insert/update statement (which is a PreparedStatement) with values from the tuple and \ngetUpdateCommand()\n to return the SQL statement to update a tuple in the database.  Note that subclasses of AbstractJdbcPOJOOutputOperator need not define these methods since they are already defined in that class.\n\n\nSeveral properties are available to configure the behavior of this operator and they are summarized in the table below.\n\n\nProperties of AbstractJdbcTransactionableOutputOperator\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nbatchSize\n\n\nMaximum number of tuples to insert in a single call (see explanation above).\n\n\nint\n\n\nNo\n\n\n1000\n\n\n\n\n\n\n\n\nProperties of JDBC Store\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ndatabaseDriver\n\n\nJDBC Driver class for connection to JDBC Store. This driver should be present in the class path\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ndatabaseUrl\n\n\n\"Database URL\"\n of the form jdbc:subprotocol:subname\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nuserName\n\n\nName of the user configured in the database\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\npassword\n\n\nPassword of the user configured in the database\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nThose attributes can be set like this:\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.batchSize</name>\n  <value>500</value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.store.databaseDriver</name>\n  <value>com.mysql.jdbc.Driver</value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.store.databaseUrl</name>\n  <value>jdbc:mysql://localhost:3306/mydb</value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.store.userName</name>\n  <value>myuser</value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.store.password</name>\n  <value>mypassword</value>\n</property>\n\n\n\n\nAbstract Methods\n\n\nThese methods are defined as abstract in AbstractJdbcTransactionableOutputOperator \nvoid setStatementParameters(PreparedStatement statement, T tuple)\n:Sets the parameter of the insert/update statement with values from the tuple.\n\nString getUpdateCommand()\n:Gets the statement which insert/update the table in the database.\n\n\nAbstractJdbcPOJOOutputOperator\n\n\nThis is the abstract implementation extending the functionality of AbstractJdbcTransactionableOutputOperator that serves as base class for inserting rows in a table using a JDBC store. It has the definition for the abstract methods in AbstractJdbcTransactionableOutputOperator. It can be further extended to modify functionality or add new capabilities. This class has an input port to recieve the records in the form of tuples, so concrete subclasses won't need to provide the same, and processes/inserts each input tuple as a database table record. You need to set the input port attribute TUPLE_CLASS to define your \nPOJO\n class name to define Object type.\n\n\nProperties of AbstractJdbcPOJOOutputOperator\n\n\nSeveral properties are available to configure the behavior of this operator and they are summarized in the table below.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ntablename\n\n\nName of the table where data is to be inserted\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nfieldInfos\n\n\nJdbcFieldInfo maps a store column to a POJO field name\n\n\nList\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nThose attributes can be set like this:\n\n\n<property>\n  <name>dt.operator.{OperatorName}.prop.tablename</name>\n  <value>ResultTable</value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.fieldInfosItem[0]</name>\n  <value>\n  {\n    \"sqlType\": 0,\n    \"columnName\":\"ID\",\n    \"pojoFieldExpression\": \"id\",\n    \"type\":\"INTEGER\"\n  }\n  </value>\n</property>\n\n<property>\n  <name>dt.operator.{OperatorName}.fieldInfosItem[1]</name>\n  <value>\n  {\n    \"sqlType\": 4,\n    \"columnName\":\"NAME\",\n    \"pojoFieldExpression\": \"name\",\n    \"type\":\"STRING\"\n  }\n  </value>\n</property>\n\n\n\n\nPlatform Attributes that influence operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nTUPLE_CLASS\n\n\nTUPLE_CLASS attribute on input port which tells operator the class of POJO which is being received\n\n\nClass\n\n\nYes\n\n\n\n\n\n\n\n\nThose attributes can be set like this:\n\n\n<property>\n  <name>dt.operator.{OperatorName}.port.input.attr.TUPLE_CLASS</name>    \n  <value>com.example.mydtapp.PojoEvent</value>\n</property>\n\n\n\n\nA concrete implementation is provided in Malhar as \nJdbcPOJOInsertOutputOperator\n.  The incoming tuples will be inserted in the table using PreparedStatement of the base class,  which is formed in \nactivate()\n method of this operator.\n\n\nFeatures\n\n\nThe operator is \nidempotent\n, \nfault-tolerant\n and \nstatically partitionable\n.\n\n\nPartitioning of JDBC Output Operator\n\n\nStatic Partitioning\n\n\nOnly static partitioning is supported for this operator.\n\n\nStatic partitioning can be achieved by specifying the partitioner and number of partitions in the populateDAG() method\n\n\n  JdbcPOJOInsertOutputOperator jdbcPOJOInsertOutputOperator = dag.addOperator(\"jdbcPOJOInsertOutputOperator\", JdbcPOJOInsertOutputOperator.class);\n  StatelessPartitioner<JdbcPOJOInsertOutputOperator> partitioner1 = new StatelessPartitioner<JdbcPOJOInsertOutputOperator>(2);\n  dag.setAttribute(jdbcPOJOInsertOutputOperator, Context.OperatorContext.PARTITIONER, partitioner1);\n\n\n\n\nStatic partitioning can also be achieved by specifying the partitioner in properties file.\n\n\n  <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>\n\n\n\n\nwhere {OperatorName} is the name of the JdbcPOJOInsertOutputOperator operator.\nAbove lines will partition JdbcPOJOInsertOutputOperator statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partitioning\n\n\nNot supported.\n\n\nExample\n\n\nAn example application using this operator can be found \nhere\n. This example shows how to read files from HDFS, parse into POJOs and then insert into a table in MySQL.",
            "title": "Jdbc Output Operator"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#jdbc-transactional-pojo-output-operator",
            "text": "",
            "title": "JDBC Transactional POJO Output Operator"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#operator-objective",
            "text": "This operator receives an input stream of POJOs and inserts them as rows in a database table in a fault-tolerant way.",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#overview",
            "text": "The main features of this operator ( AbstractJdbcTransactionableOutputOperator ) are persisting data to the database table and fault tolerance. This operator creates a transaction at the start of each window, executes batches of SQL updates, and closes the transaction at the end of the window. Each tuple corresponds to an SQL update statement. The operator groups the updates in a batch and submits them with one call to the database. Batch processing improves performance considerably. The size of a batch is configured by  batchSize  property. The tuples in a window are stored in a check-pointed collection which is cleared in each  endWindow()  call. The operator writes a tuple exactly once in the database.  An (indirect) base class for this operator is  AbstractPassThruTransactionableStoreOutputOperator  which implements a pass-through output adapter for a transactional store; it guarantees exactly-once semantics. \"Pass-through\" means it does not wait for end window to write to the store. It will begin transaction at  beginWindow  and write to the store as the tuples come and commit the transaction at  endWindow .  The overall heirarchy is described in the the following diagram:   AbstractTransactionableStoreOutputOperator : A skeleton implementation of an output operator that writes to a transactional store; the tuple type and store type are generic parameters. Defines an input port whose process method invokes the processTuple() abstract method. Exactly-once semantics are not guaranteed and must be provided by subclasses if needed.  AbstractPassThruTransactionableStoreOutputOperator : Simple extension of the above base class which adds exactly-once semantics by starting a transaction in  beginWindow()  and committing it in  endWindow() .  AbstractJdbcTransactionableOutputOperator : (focus of this document) Adds support for JDBC by using an instance of JdbcTransactionalStore as the store. Also adds support for processing tuples in batches and provides an implementation of the  proessTuple()  abstract method mentioned above.  AbstractJdbcPOJOOutputOperator : Serves as base class for inserting rows in a table using a JDBC store.  Note : For enforcing exactly once semantics a table named  dt_meta  must exist in the database. The sample SQL to create the same is as follows  \"CREATE TABLE IF NOT EXISTS dt_meta (dt_app_id VARCHAR(100) NOT NULL, dt_operator_id INT NOT NULL, dt_window BIGINT NOT NULL, UNIQUE(dt_app_id,dt_operator_id,dt_window))\".  Note : Additionally this operator assumes that the underlying database/table in which records are to be added supports transactions. If the database/table does not support transactions then a tuple may be inserted in a table more than once in case of auto recovery from a failure (violation of exactly once semantics).",
            "title": "Overview"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#operator-information",
            "text": "Operator location:  malhar-library  Available since:  0.9.4  Java Packages:  Operator:  com.datatorrent.lib.db.jdbc.AbstractJdbcTransactionableOutputOperator",
            "title": "Operator Information"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#how-to-use",
            "text": "Concrete subclasses need to implement a couple of abstract methods (if not using AbstractJdbcPOJOOutputOperator):  setStatementParameters(PreparedStatement statement, T tuple)  to set the parameter of the insert/update statement (which is a PreparedStatement) with values from the tuple and  getUpdateCommand()  to return the SQL statement to update a tuple in the database.  Note that subclasses of AbstractJdbcPOJOOutputOperator need not define these methods since they are already defined in that class.  Several properties are available to configure the behavior of this operator and they are summarized in the table below.",
            "title": "How to Use?"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#abstract-methods",
            "text": "These methods are defined as abstract in AbstractJdbcTransactionableOutputOperator  void setStatementParameters(PreparedStatement statement, T tuple) :Sets the parameter of the insert/update statement with values from the tuple. String getUpdateCommand() :Gets the statement which insert/update the table in the database.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#abstractjdbcpojooutputoperator",
            "text": "This is the abstract implementation extending the functionality of AbstractJdbcTransactionableOutputOperator that serves as base class for inserting rows in a table using a JDBC store. It has the definition for the abstract methods in AbstractJdbcTransactionableOutputOperator. It can be further extended to modify functionality or add new capabilities. This class has an input port to recieve the records in the form of tuples, so concrete subclasses won't need to provide the same, and processes/inserts each input tuple as a database table record. You need to set the input port attribute TUPLE_CLASS to define your  POJO  class name to define Object type.",
            "title": "AbstractJdbcPOJOOutputOperator"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#platform-attributes-that-influence-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      TUPLE_CLASS  TUPLE_CLASS attribute on input port which tells operator the class of POJO which is being received  Class  Yes     Those attributes can be set like this:  <property>\n  <name>dt.operator.{OperatorName}.port.input.attr.TUPLE_CLASS</name>    \n  <value>com.example.mydtapp.PojoEvent</value>\n</property>  A concrete implementation is provided in Malhar as  JdbcPOJOInsertOutputOperator .  The incoming tuples will be inserted in the table using PreparedStatement of the base class,  which is formed in  activate()  method of this operator.",
            "title": "Platform Attributes that influence operator behavior"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#features",
            "text": "The operator is  idempotent ,  fault-tolerant  and  statically partitionable .",
            "title": "Features"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#partitioning-of-jdbc-output-operator",
            "text": "",
            "title": "Partitioning of JDBC Output Operator"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#static-partitioning",
            "text": "Only static partitioning is supported for this operator.  Static partitioning can be achieved by specifying the partitioner and number of partitions in the populateDAG() method    JdbcPOJOInsertOutputOperator jdbcPOJOInsertOutputOperator = dag.addOperator(\"jdbcPOJOInsertOutputOperator\", JdbcPOJOInsertOutputOperator.class);\n  StatelessPartitioner<JdbcPOJOInsertOutputOperator> partitioner1 = new StatelessPartitioner<JdbcPOJOInsertOutputOperator>(2);\n  dag.setAttribute(jdbcPOJOInsertOutputOperator, Context.OperatorContext.PARTITIONER, partitioner1);  Static partitioning can also be achieved by specifying the partitioner in properties file.    <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n  </property>  where {OperatorName} is the name of the JdbcPOJOInsertOutputOperator operator.\nAbove lines will partition JdbcPOJOInsertOutputOperator statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#dynamic-partitioning",
            "text": "Not supported.",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/AbstractJdbcTransactionableOutputOperator/#example",
            "text": "An example application using this operator can be found  here . This example shows how to read files from HDFS, parse into POJOs and then insert into a table in MySQL.",
            "title": "Example"
        },
        {
            "location": "/operators/jdbcPollInputOperator/",
            "text": "JDBC Poller Input Operator\n\n\nOperator Objective\n\n\nThis operator scans JDBC database table in parallel fashion. This operator is added to address common input operator problems like,\n\n\n\n\n\n\nAs discussed in \nDevelopment Best Practices\n,\n    the operator callbacks such as \nbeginWindow()\n, \nendWindow()\n, \nemitTuples()\n, etc.\n    (which are invoked by the main operator thread)\n    are required to return quickly, well within the default streaming window duration of\n    500ms. This requirement can be an issue when retrieving data from slow external systems\n    such as databases or object stores: if the call takes too long, the platform will deem\n    the operator blocked and restart it. Restarting will often run into the same issue\n    causing an unbroken sequence of restarts.\n\n\n\n\n\n\nWhen a large volume of data is available from a single store that allows reading from\n   arbitrary locations (such as a file or a database table), reading the data sequentially\n   can be throughput limiting: Having multiple readers read from non-overlapping sections\n   of the store allows any downstream parallelism in the DAG to be exploited better to\n   enhance throughput. For files, this approach is used by the file splitter and block\n   reader operators in the Malhar library.\n\n\n\n\n\n\nJDBC Poller Input operator addresses the first issue with an asynchronous worker thread which retrieves the data and adds it to an in-memory queue; the main operator thread dequeue tuples very quickly if data is available or simply returns if not. The second is addressed in a way that parallels the approach to files by having multiple partitions read records from non-overlapping areas of the table. Additional details of how this is done are described below.\n\n\nAssumption\n\n\nAssumption is that there is an ordered column using which range queries can be formed. That means database has a column or combination of columns which has unique constraint as well as every newly inserted record should have column value more than max value in that column, as we poll only appended records.\n\n\nUse cases\n\n\n\n\nIngest large database tables. An example application that copies database contents to HDFS is available \nhere\n.\n\n\n\n\nHow to Use?\n\n\nThe tuple type in the abstract class is a generic parameter. Concrete subclasses need to choose an appropriate class (such as String or an appropriate concrete java class, having no-argument constructor so that it can be serialized using Kryo). Also implement a couple of abstract methods: \ngetTuple(ResultSet)\n to convert database rows to objects of concrete class and \nemitTuple(T)\n to emit the tuple.\n\n\nIn principle, no ports need be defined in the rare case that the operator simply writes tuples to some external sink or merely maintains aggregated statistics. But in most common scenarios, the tuples need to be sent to one or more downstream operators for additional processing such as parsing, enrichment or aggregation; in such cases, appropriate output ports are defined and the emitTuple(T) implementation dispatches tuples to the desired output ports.\n\n\nCouple of concrete implementations are provided in Malhar:\n\n\n\n\n\n\nJdbcPOJOPollInputOperator\n: It uses java Object for the generic parameter. This operator defines a single output port and processes each database table record one by one as a tuple object. You need to set the output port attribute TUPLE_CLASS to define your \nPOJO\n class name to define Object type. The record fetched from the database table will be parsed, using the \ngetTuple\n method mentioned above, as an object of the configured class. Details are discussed below.\n\n\n\n\n\n\nJdbcPollInputOperator\n: It uses String for the generic parameter. This operator defines a single port and processes each database table record one by one as String tuple. Details are discussed below.\n\n\n\n\n\n\nPartitioning of JDBC Poller\n\n\nStatic Partitioning\n\n\nOnly static partitioning is supported for JDBC Poller Input Operator. Configure parameter \npartitionCount\n to define the desired number of initial partitions (4 in this example).\n\nNote\n: An additional partition will be created to poll newly added records, so the total number of partitions will always be 1 + partitionCount.\n\n\n  <property>\n    <name>apex.operator.{OperatorName}.prop.partitionCount</name>\n    <value>4</value>\n  </property>\n\n\n\n\nwhere {OperatorName} is the name of the JDBC Poller operator.\n\n\nThis will create 5 operator instances in all. Four of these will fetch the data which is currently in the table. We call these static non-polling partitions. The partitions will be idle after they fetch the portion of the data. An additional partition will be created which will read any newly added data. We call such a partition as a polling partition, as it \"polls\" for newly added data. There will be only one polling partition.\n\n\nDynamic Partitioning\n\n\nNot supported.\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-library\n\n\nAvailable since: \n3.5.0\n\n\nOperator state: \nEvolving\n\n\nJava Packages: \nAbstractJdbcPollInputOperator\n\n\n\n\nJDBC Poller is \nidempotent\n, \nfault-tolerant\n and \nstatically partitionable\n.\n\n\nAbstractJdbcPollInputOperator\n\n\nThis is the abstract implementation that serves as base class for polling messages from JDBC store. It can be extended to modify functionality or add new capabilities. This class doesn\u2019t have any ports, so concrete subclasses will need to provide them if necessary.\n\n\n\n\nProperties of AbstractJdbcPollInputOperator\n\n\nSeveral properties are available to configure the behavior of this operator and they are summarized in the table below.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nstore\n\n\nJDBC Store for connection\n\n\nJDBCStore\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ntableName\n\n\ntable name to be scanned\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ncolumnsExpression\n\n\nComma separated list of columns to select from the given table.\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nkey\n\n\nPrimary key column name\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\npartitionCount\n\n\nStatic partitions count\n\n\nint\n\n\nNo\n\n\n1\n\n\n\n\n\n\nwhereCondition\n\n\nWhere condition for JDBC query\n\n\nString\n\n\nNo\n\n\nN/A\n\n\n\n\n\n\nfetchSize\n\n\nHint limiting the number of rows to fetch in a single call\n\n\nint\n\n\nNo\n\n\n20000\n\n\n\n\n\n\npollInterval\n\n\nInterval in milliseconds to poll the database table\n\n\nint\n\n\nNo\n\n\n10000\n\n\n\n\n\n\nqueueCapacity\n\n\nCapacity of queue which holds DB data before emiting\n\n\nint\n\n\nNo\n\n\n4096\n\n\n\n\n\n\nbatchSize\n\n\nMaximum number of tuples to emit in a single call to the \nemitTuples()\n callback (see explanation above).\n\n\nint\n\n\nNo\n\n\n2000\n\n\n\n\n\n\n\n\nProperties of JDBC Store (BackendStore)\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\ndatabaseDriver\n\n\nJDBC Driver class for connection to JDBC Store. This driver should be there in class path\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\ndatabaseUrl\n\n\nDatabase url of the form jdbc:subprotocol:subname\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\nconnectionProps\n\n\nComma separated connection properties e.g. user:xyz,password:ijk\n\n\nString\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nOf these only \nstore\n properties, \ntableName\n, \ncolumnsExpression\n and \nkey\n are mandatory. Those properties can be set like this:\n\n\n<property>\n  <name>apex.operator.{OperatorName}.prop.tableName</name>\n  <value>mytable</value>\n</property>\n<property>\n  <name>apex.operator.{OperatorName}.prop.columnsExpression</name>\n  <value>column1,column2,column4</value>\n</property>\n<property>\n  <name>apex.operator.{OperatorName}.prop.key</name>\n  <value>keycolumn</value>\n</property>\n<property>\n  <name>apex.operator.{OperatorName}.prop.store.databaseDriver</name>\n  <value>com.mysql.jdbc.Driver</value>\n</property>\n<property>\n  <name>apex.operator.{OperatorName}.prop.store.databaseUrl</name>\n  <value>jdbc:mysql://localhost:3306/mydb</value>\n</property>\n<property>\n  <name>apex.operator.{OperatorName}.prop.store.connectionProps</name>\n  <value>user:myuser,password:mypassword</value>\n</property>\n\n\n\n\n\n\nIf you need to filter the table records, set \nwhereCondition\n which will be added to the generated SQL query.\n\n\nIf you have a table with a very large number or rows to scan set \npartitionsCount\n to a higher number to increase read parallelism.\n\n\nThe operator uses PreparedStatement, a precompiled SQL statement to fetch records from database table. You can set \nfetchSize\n as a hint to the database driver to restrict number of rows to fetch in one call. The remaining rows will be fetched in subsequent calls. Please note, some of the database drivers may not honor this hint. Please refer to database driver documentation to know recommended value.\n\n\nThe platform invokes the \nemitTuples()\n callback multiple time in each streaming window; within a single such call, if a large number of tuples are emitted, there is some risk that they may overwhelm the downstream operators especially if they are performing some compute intensive operation. For such cases, output can be throttled by reducing the value of the \nbatchSize\n property. Conversely, if the downstream operators can handle the load, increase the value to enhance throughput.\n\n\nIf there is high rate of incoming records in your table and you want to process them as soon as they appear, use lower value of \npollInterval\n; if they appear rarely or if some delay in processing new records is acceptable, increase it.\n\n\nAfter reading the records from the table they are held in memory for some time till they are emitted to next operator. The records are kept in a blocking queue. The capacity of this blocking queue can be changed using parameter \nqueueCapacity\n. You can use larger size of queue when your reader thread is very fast and you want to read more data in memory to keep it ready for emission.\n\n\n\n\nNote\n: Please set right store object instance to JDBC Poller Input Operator using your application code. It's recommended to use \nJdbcStore\n for this operator.\n\n\nAbstract Methods\n\n\nvoid emitTuple(T tuple)\n: Abstract method that emits tuple extracted from JDBC store.\n\n\nT getTuple(ResultSet result)\n: Abstract method to extract the tuple from the JDBC ResultSet object and convert it to the required type (T).\n\n\nConcrete Classes\n\n\n1. JdbcPOJOPollInputOperator\n\n\nThis implementation converts JDBC store records to \nPOJO\n and emits POJO on output port.\n\n\nProperties of JdbcPOJOPollInputOperator\n\n\nThis operator defines following additional properties beyond those defined in the \nparent class\n.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nfieldInfos\n\n\nMaps columns to POJO field names.\n\n\nList\n\n\nYes\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influence operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutputPort.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted\n\n\nClass or FQCN (Fully Qualified Class Name)\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutputPort\n\n\nTuples that are read from JDBC store are emitted from on this port\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\n\n\n2. JdbcPollInputOperator\n\n\nThis implementation converts JDBC store records to comma separated CSV records. This operator is normally used when you just want to copy the data from database to somewhere else and don't want to do much of processing.\n\n\nProperties of JdbcPollInputOperator\n\n\nThis operator defines no additional properties beyond those defined in the \nparent class\n.\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noutputPort\n\n\nTuples that are read from JDBC store are emitted on this port\n\n\nString\n\n\nNo\n\n\n\n\n\n\n\n\nLimitations\n\n\nOut of order insertion/deletion won't be supported.",
            "title": "JDBC Poller Input"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#jdbc-poller-input-operator",
            "text": "",
            "title": "JDBC Poller Input Operator"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#operator-objective",
            "text": "This operator scans JDBC database table in parallel fashion. This operator is added to address common input operator problems like,    As discussed in  Development Best Practices ,\n    the operator callbacks such as  beginWindow() ,  endWindow() ,  emitTuples() , etc.\n    (which are invoked by the main operator thread)\n    are required to return quickly, well within the default streaming window duration of\n    500ms. This requirement can be an issue when retrieving data from slow external systems\n    such as databases or object stores: if the call takes too long, the platform will deem\n    the operator blocked and restart it. Restarting will often run into the same issue\n    causing an unbroken sequence of restarts.    When a large volume of data is available from a single store that allows reading from\n   arbitrary locations (such as a file or a database table), reading the data sequentially\n   can be throughput limiting: Having multiple readers read from non-overlapping sections\n   of the store allows any downstream parallelism in the DAG to be exploited better to\n   enhance throughput. For files, this approach is used by the file splitter and block\n   reader operators in the Malhar library.    JDBC Poller Input operator addresses the first issue with an asynchronous worker thread which retrieves the data and adds it to an in-memory queue; the main operator thread dequeue tuples very quickly if data is available or simply returns if not. The second is addressed in a way that parallels the approach to files by having multiple partitions read records from non-overlapping areas of the table. Additional details of how this is done are described below.",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#assumption",
            "text": "Assumption is that there is an ordered column using which range queries can be formed. That means database has a column or combination of columns which has unique constraint as well as every newly inserted record should have column value more than max value in that column, as we poll only appended records.",
            "title": "Assumption"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#use-cases",
            "text": "Ingest large database tables. An example application that copies database contents to HDFS is available  here .",
            "title": "Use cases"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#how-to-use",
            "text": "The tuple type in the abstract class is a generic parameter. Concrete subclasses need to choose an appropriate class (such as String or an appropriate concrete java class, having no-argument constructor so that it can be serialized using Kryo). Also implement a couple of abstract methods:  getTuple(ResultSet)  to convert database rows to objects of concrete class and  emitTuple(T)  to emit the tuple.  In principle, no ports need be defined in the rare case that the operator simply writes tuples to some external sink or merely maintains aggregated statistics. But in most common scenarios, the tuples need to be sent to one or more downstream operators for additional processing such as parsing, enrichment or aggregation; in such cases, appropriate output ports are defined and the emitTuple(T) implementation dispatches tuples to the desired output ports.  Couple of concrete implementations are provided in Malhar:    JdbcPOJOPollInputOperator : It uses java Object for the generic parameter. This operator defines a single output port and processes each database table record one by one as a tuple object. You need to set the output port attribute TUPLE_CLASS to define your  POJO  class name to define Object type. The record fetched from the database table will be parsed, using the  getTuple  method mentioned above, as an object of the configured class. Details are discussed below.    JdbcPollInputOperator : It uses String for the generic parameter. This operator defines a single port and processes each database table record one by one as String tuple. Details are discussed below.",
            "title": "How to Use?"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#partitioning-of-jdbc-poller",
            "text": "",
            "title": "Partitioning of JDBC Poller"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#static-partitioning",
            "text": "Only static partitioning is supported for JDBC Poller Input Operator. Configure parameter  partitionCount  to define the desired number of initial partitions (4 in this example). Note : An additional partition will be created to poll newly added records, so the total number of partitions will always be 1 + partitionCount.    <property>\n    <name>apex.operator.{OperatorName}.prop.partitionCount</name>\n    <value>4</value>\n  </property>  where {OperatorName} is the name of the JDBC Poller operator.  This will create 5 operator instances in all. Four of these will fetch the data which is currently in the table. We call these static non-polling partitions. The partitions will be idle after they fetch the portion of the data. An additional partition will be created which will read any newly added data. We call such a partition as a polling partition, as it \"polls\" for newly added data. There will be only one polling partition.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#dynamic-partitioning",
            "text": "Not supported.",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#operator-information",
            "text": "Operator location:  malhar-library  Available since:  3.5.0  Operator state:  Evolving  Java Packages:  AbstractJdbcPollInputOperator   JDBC Poller is  idempotent ,  fault-tolerant  and  statically partitionable .",
            "title": "Operator Information"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#abstractjdbcpollinputoperator",
            "text": "This is the abstract implementation that serves as base class for polling messages from JDBC store. It can be extended to modify functionality or add new capabilities. This class doesn\u2019t have any ports, so concrete subclasses will need to provide them if necessary.",
            "title": "AbstractJdbcPollInputOperator"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#abstract-methods",
            "text": "void emitTuple(T tuple) : Abstract method that emits tuple extracted from JDBC store.  T getTuple(ResultSet result) : Abstract method to extract the tuple from the JDBC ResultSet object and convert it to the required type (T).",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#concrete-classes",
            "text": "",
            "title": "Concrete Classes"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#1-jdbcpojopollinputoperator",
            "text": "This implementation converts JDBC store records to  POJO  and emits POJO on output port.",
            "title": "1. JdbcPOJOPollInputOperator"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#platform-attributes-that-influence-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      outputPort.TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted  Class or FQCN (Fully Qualified Class Name)  Yes",
            "title": "Platform Attributes that influence operator behavior"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#ports",
            "text": "Port  Description  Type  Mandatory      outputPort  Tuples that are read from JDBC store are emitted from on this port  Object (POJO)  No",
            "title": "Ports"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#2-jdbcpollinputoperator",
            "text": "This implementation converts JDBC store records to comma separated CSV records. This operator is normally used when you just want to copy the data from database to somewhere else and don't want to do much of processing.",
            "title": "2. JdbcPollInputOperator"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#ports_1",
            "text": "Port  Description  Type  Mandatory      outputPort  Tuples that are read from JDBC store are emitted on this port  String  No",
            "title": "Ports"
        },
        {
            "location": "/operators/jdbcPollInputOperator/#limitations",
            "text": "Out of order insertion/deletion won't be supported.",
            "title": "Limitations"
        },
        {
            "location": "/operators/jmsInputOperator/",
            "text": "JMS INPUT OPERATOR\n\n\nIntroduction: About the JMS Input Operator\n\n\nThe JMS input operator consumes data from a messaging system using the JMS client API. JMS not being a communication protocol, the operator needs an underlying JMS client API library to talk to a messaging system. Currently the operator has been tested with the Amazon SQS and Apache ActiveMQ System brokers via their respective JMS client API libraries.\n\n\nWhy is it needed ?\n\n\nYou will need the operator to read data from a messaging system (e.g. Apache ActiveMQ) via the JMS client API. The operator supports both the publish-subscribe (topics) and point-to-point (queues) modes. The operator currently does not support partitioning and dynamic scalability.\n\n\nJMSBase\n\n\nThis class encapsulates various JMS properties and behaviors and maintains connections with the JMS broker. This is the base class for JMS input and output adaptor operators. Operators should not directly subclass JMSBase but one of the JMS input or output operators.\n\n\nAbstractJMSInputOperator\n\n\nThis abstract implementation serves as the base class for consuming generic messages from an external messaging system. Concrete subclasses implement conversion and emit methods to emit tuples for a concrete type. JMSStringInputOperator is one such subclass in the library used for String messages. JMSObjectInputOperator is another one used for multiple message types where the user has the ability to get String, byte array, Map or POJO messages on the respective output ports.\n\n\nConfiguration Parameters\n\n\nCommon configuration parameters are described here.\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\nwindowDataManager\n\n\nThis is an instance of \nWindowDataManager\n that implements idempotency. Idempotency ensures that an operator will process the same set of messages in a window before and after a failure. For example, say the operator completed window 10 and failed before or during window 11. If the operator gets restored at window 10, it will replay the messages of window 10 which were saved from the previous run before the failure. Although important, idempotency comes at a price because an operator needs to persist some state at the end of each window. Default Value = \norg.apache.apex.malhar.lib.wal.FSWindowDataManager\n\n\n\n\n\n\nconnectionFactoryBuilder\n\n\nThe operator uses the builder pattern that requires the user to specify an instance of \ncom.datatorrent.lib.io.jms.JMSBase.ConnectionFactoryBuilder\n. This builder creates the connection factory that encapsulates the underlying JMS client API library (e.g. ActiveMQ or Amazon SQS). By default the operator uses \ncom.datatorrent.lib.io.jms.JMSBase.DefaultConnectionFactoryBuilder\n which is used for ActiveMQ. One of the examples below describes the Amazon SQS use-case. \n\n\n\n\n\n\n\n\nAbstract Methods\n\n\nThe following abstract methods need to be implemented by concrete subclasses.\n\n\nT convert(Message message): This method converts a JMS Message object to type T.\n\n\nvoid emit(T payload): This method emits a tuple given the payload extracted from a JMS message.\n\n\nConcrete Classes\n\n\n\n\n\n\nJMSStringInputOperator :\nThis class extends AbstractJMSInputOperator to deliver String payloads in the tuple.\n\n\n\n\n\n\nJMSObjectInputOperator:\nThis class extends AbstractJMSInputOperator to deliver String, byte array, Map or POJO payloads in the tuple.\n\n\n\n\n\n\nApplication Examples\n\n\nActiveMQ Example\n\n\nThe source code for the tutorial can be found here:\n\n\nhttps://github.com/DataTorrent/examples/tree/master/tutorials/jmsActiveMQ\n\n\nThe following code snippet from the example illustrates how the DAG is created:\n\n\n  @Override\n  public void populateDAG(DAG dag, Configuration conf)\n  {\n    JMSStringInputOperator amqInput = dag.addOperator(\"amqIn\", \n        new JMSStringInputOperator());\n\n    LineOutputOperator out = dag.addOperator(\"fileOut\", new LineOutputOperator());\n\n    dag.addStream(\"data\", amqInput.output, out.input);\n  }\n\n\n\n\nThe DAG consists of only 2 operators: the \nJMSStringInputOperator\n which is the input operator that feeds received ActiveMQ messages into the output operator \nLineOutputOperator\n which outputs these messages into a file or files.\n\n\nThe default connectionFactoryBuilder supports ActiveMQ so there is no need to set this value. However the following ActiveMQ related values need to be set either from properties files or using the appropriate setter methods in the code:\n\n\n\n\n\n\n\n\n\n\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\nconnectionFactoryProperties\n\n\nThis is a Map of key and value strings and can be set directly from configuration as in the example above. The table below describes the most important properties.\n\n\n\n\n\n\ntopic\n\n\nThis boolean value is set to true for the publish-subscribe case and false for the PTP (point-to-point) case.\n\n\n\n\n\n\nsubject\n\n\nThis is the queue name for PTP (point-to-point) use-case and topic name for the publish-subscribe use case.\n\n\n\n\n\n\ndurable\n\n\nThis boolean value is set to true for durable subscriptionss, false otherwise. Durable subscriptions save messages to persistent storage until consumed. Used only when the clientId (see below) is set.\n\n\n\n\n\n\nclientId\n\n\nThe client-ID for this ActiveMQ consumer in the durable subscription mode as described above.\n\n\n\n\n\n\ntransacted\n\n\nThis boolean value is set to true for transacted JMS sessions as described in \n\nSession\n.\n\n\n\n\n\n\nackMode\n\n\nThis string value sets the acknowledgement mode as described in \n\nSession fields\n.\n\n\n\n\n\n\n\n\n\nThe following table describes the string properties to be set in the map that is passed in the connectionFactoryProperties value described above.\n\n\n\n\n\n\n\n\n\n\n\n\nProperty Name\n\n\nDescription\n\n\n\n\n\n\nbrokerURL\n\n\nThe \nconnection URL\n \nused to connect to the ActiveMQ broker\n\n\n\n\nuserName\n\n\nThe JMS userName used by connections created by this factory (optional when anonymous access is used)\n\n\n\n\n\n\npassword\n\n\nThe JMS password used for connections created from this factory (optional when anonymous access is used)\n\n\n\n\n\n\n\n\n\nThese properties can be set from the properties.xml file as shown below \n(from the example \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/jmsActiveMQ\n ).\n\n\n<configuration>\n  <property>\n    <name>dt.operator.amqIn.prop.connectionFactoryProperties.brokerURL</name>\n    <value>vm://localhost</value>\n  </property>\n  <property>\n    <name>dt.operator.amqIn.prop.subject</name>\n    <value>jms4Amq</value>\n  </property>\n</configuration>                                                                                                        \n\n\n\n\nSQS Example\n\n\nThe source code for the tutorial can be found here:\n\n\nhttps://github.com/DataTorrent/examples/tree/master/tutorials/jmsSqs\n\n\nThe following code snippet from the example illustrates how the DAG is created:\n\n\n @Override\n public void populateDAG(DAG dag, Configuration conf)\n {\n\n   JMSStringInputOperator sqsInput = dag.addOperator(\"sqsIn\", \n       new JMSStringInputOperator());\n\n   MyConnectionFactoryBuilder factoryBuilder = new MyConnectionFactoryBuilder();\n\n   factoryBuilder.sqsDevCredsFilename = conf.get(SQSDEV_CREDS_FILENAME_PROPERTY);\n\n   sqsInput.setConnectionFactoryBuilder(factoryBuilder);\n\n   LineOutputOperator out = dag.addOperator(\"fileOut\", new LineOutputOperator());\n\n   dag.addStream(\"data\", sqsInput.output, out.input);\n }\n\n\n\n\nThe DAG consists of only 2 operators: the \nJMSStringInputOperator\n which is the input operator that feeds received SQS messages into the output operator \nLineOutputOperator\n which outputs these messages into a file or files. The code also shows how the AWS/SQS credentials are initialized in the factory builder. \n\n\nFor SQS you will have to provide a custom connectionFactoryBuilder as shown in the example above and in \nSQSConnectionFactory.java\n. The builder is typically used to supply AWS region and credential information that cannot be supplied via any JMS interfaces.\n\n\nThe following code snippet shows a typical Builder implementation that can be supplied to the operator. The AWS credentials are supplied via a \nPropertiesFileCredentialsProvider\n object in which sqsCredsFilename is the fully qualified path to a properties file from which the AWS security credentials are to be loaded. For example \n/etc/somewhere/credentials.properties\n\n\nstatic class MyConnectionFactoryBuilder implements JMSBase.ConnectionFactoryBuilder {\n\nString sqsCredsFilename;\n\nMyConnectionFactoryBuilder()\n{\n}\n\n@Override\npublic ConnectionFactory buildConnectionFactory() \n{\n  // Create the connection factory using the properties file credential provider.\n  // Connections this factory creates can talk to the queues in us-east-1 region. \n  SQSConnectionFactory connectionFactory =\n    SQSConnectionFactory.builder()\n      .withRegion(Region.getRegion(Regions.US_EAST_1))\n      .withAWSCredentialsProvider(new PropertiesFileCredentialsProvider(sqsCredsFilename))\n      .build();\n    return connectionFactory;\n  }\n}",
            "title": "JMS Input"
        },
        {
            "location": "/operators/jmsInputOperator/#jms-input-operator",
            "text": "",
            "title": "JMS INPUT OPERATOR"
        },
        {
            "location": "/operators/jmsInputOperator/#introduction-about-the-jms-input-operator",
            "text": "The JMS input operator consumes data from a messaging system using the JMS client API. JMS not being a communication protocol, the operator needs an underlying JMS client API library to talk to a messaging system. Currently the operator has been tested with the Amazon SQS and Apache ActiveMQ System brokers via their respective JMS client API libraries.",
            "title": "Introduction: About the JMS Input Operator"
        },
        {
            "location": "/operators/jmsInputOperator/#why-is-it-needed",
            "text": "You will need the operator to read data from a messaging system (e.g. Apache ActiveMQ) via the JMS client API. The operator supports both the publish-subscribe (topics) and point-to-point (queues) modes. The operator currently does not support partitioning and dynamic scalability.",
            "title": "Why is it needed ?"
        },
        {
            "location": "/operators/jmsInputOperator/#jmsbase",
            "text": "This class encapsulates various JMS properties and behaviors and maintains connections with the JMS broker. This is the base class for JMS input and output adaptor operators. Operators should not directly subclass JMSBase but one of the JMS input or output operators.",
            "title": "JMSBase"
        },
        {
            "location": "/operators/jmsInputOperator/#abstractjmsinputoperator",
            "text": "This abstract implementation serves as the base class for consuming generic messages from an external messaging system. Concrete subclasses implement conversion and emit methods to emit tuples for a concrete type. JMSStringInputOperator is one such subclass in the library used for String messages. JMSObjectInputOperator is another one used for multiple message types where the user has the ability to get String, byte array, Map or POJO messages on the respective output ports.",
            "title": "AbstractJMSInputOperator"
        },
        {
            "location": "/operators/jmsInputOperator/#configuration-parameters",
            "text": "Common configuration parameters are described here.      Parameter  Description    windowDataManager  This is an instance of  WindowDataManager  that implements idempotency. Idempotency ensures that an operator will process the same set of messages in a window before and after a failure. For example, say the operator completed window 10 and failed before or during window 11. If the operator gets restored at window 10, it will replay the messages of window 10 which were saved from the previous run before the failure. Although important, idempotency comes at a price because an operator needs to persist some state at the end of each window. Default Value =  org.apache.apex.malhar.lib.wal.FSWindowDataManager    connectionFactoryBuilder  The operator uses the builder pattern that requires the user to specify an instance of  com.datatorrent.lib.io.jms.JMSBase.ConnectionFactoryBuilder . This builder creates the connection factory that encapsulates the underlying JMS client API library (e.g. ActiveMQ or Amazon SQS). By default the operator uses  com.datatorrent.lib.io.jms.JMSBase.DefaultConnectionFactoryBuilder  which is used for ActiveMQ. One of the examples below describes the Amazon SQS use-case.",
            "title": "Configuration Parameters"
        },
        {
            "location": "/operators/jmsInputOperator/#abstract-methods",
            "text": "The following abstract methods need to be implemented by concrete subclasses.  T convert(Message message): This method converts a JMS Message object to type T.  void emit(T payload): This method emits a tuple given the payload extracted from a JMS message.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/jmsInputOperator/#concrete-classes",
            "text": "JMSStringInputOperator :\nThis class extends AbstractJMSInputOperator to deliver String payloads in the tuple.    JMSObjectInputOperator:\nThis class extends AbstractJMSInputOperator to deliver String, byte array, Map or POJO payloads in the tuple.",
            "title": "Concrete Classes"
        },
        {
            "location": "/operators/jmsInputOperator/#application-examples",
            "text": "",
            "title": "Application Examples"
        },
        {
            "location": "/operators/jmsInputOperator/#activemq-example",
            "text": "The source code for the tutorial can be found here:  https://github.com/DataTorrent/examples/tree/master/tutorials/jmsActiveMQ  The following code snippet from the example illustrates how the DAG is created:    @Override\n  public void populateDAG(DAG dag, Configuration conf)\n  {\n    JMSStringInputOperator amqInput = dag.addOperator(\"amqIn\", \n        new JMSStringInputOperator());\n\n    LineOutputOperator out = dag.addOperator(\"fileOut\", new LineOutputOperator());\n\n    dag.addStream(\"data\", amqInput.output, out.input);\n  }  The DAG consists of only 2 operators: the  JMSStringInputOperator  which is the input operator that feeds received ActiveMQ messages into the output operator  LineOutputOperator  which outputs these messages into a file or files.  The default connectionFactoryBuilder supports ActiveMQ so there is no need to set this value. However the following ActiveMQ related values need to be set either from properties files or using the appropriate setter methods in the code:       Value  Description    connectionFactoryProperties  This is a Map of key and value strings and can be set directly from configuration as in the example above. The table below describes the most important properties.    topic  This boolean value is set to true for the publish-subscribe case and false for the PTP (point-to-point) case.    subject  This is the queue name for PTP (point-to-point) use-case and topic name for the publish-subscribe use case.    durable  This boolean value is set to true for durable subscriptionss, false otherwise. Durable subscriptions save messages to persistent storage until consumed. Used only when the clientId (see below) is set.    clientId  The client-ID for this ActiveMQ consumer in the durable subscription mode as described above.    transacted  This boolean value is set to true for transacted JMS sessions as described in  Session .    ackMode  This string value sets the acknowledgement mode as described in  Session fields .     The following table describes the string properties to be set in the map that is passed in the connectionFactoryProperties value described above.       Property Name  Description    brokerURL  The  connection URL  \nused to connect to the ActiveMQ broker   userName  The JMS userName used by connections created by this factory (optional when anonymous access is used)    password  The JMS password used for connections created from this factory (optional when anonymous access is used)     These properties can be set from the properties.xml file as shown below \n(from the example  https://github.com/DataTorrent/examples/tree/master/tutorials/jmsActiveMQ  ).  <configuration>\n  <property>\n    <name>dt.operator.amqIn.prop.connectionFactoryProperties.brokerURL</name>\n    <value>vm://localhost</value>\n  </property>\n  <property>\n    <name>dt.operator.amqIn.prop.subject</name>\n    <value>jms4Amq</value>\n  </property>\n</configuration>",
            "title": "ActiveMQ Example"
        },
        {
            "location": "/operators/jmsInputOperator/#sqs-example",
            "text": "The source code for the tutorial can be found here:  https://github.com/DataTorrent/examples/tree/master/tutorials/jmsSqs  The following code snippet from the example illustrates how the DAG is created:   @Override\n public void populateDAG(DAG dag, Configuration conf)\n {\n\n   JMSStringInputOperator sqsInput = dag.addOperator(\"sqsIn\", \n       new JMSStringInputOperator());\n\n   MyConnectionFactoryBuilder factoryBuilder = new MyConnectionFactoryBuilder();\n\n   factoryBuilder.sqsDevCredsFilename = conf.get(SQSDEV_CREDS_FILENAME_PROPERTY);\n\n   sqsInput.setConnectionFactoryBuilder(factoryBuilder);\n\n   LineOutputOperator out = dag.addOperator(\"fileOut\", new LineOutputOperator());\n\n   dag.addStream(\"data\", sqsInput.output, out.input);\n }  The DAG consists of only 2 operators: the  JMSStringInputOperator  which is the input operator that feeds received SQS messages into the output operator  LineOutputOperator  which outputs these messages into a file or files. The code also shows how the AWS/SQS credentials are initialized in the factory builder.   For SQS you will have to provide a custom connectionFactoryBuilder as shown in the example above and in  SQSConnectionFactory.java . The builder is typically used to supply AWS region and credential information that cannot be supplied via any JMS interfaces.  The following code snippet shows a typical Builder implementation that can be supplied to the operator. The AWS credentials are supplied via a  PropertiesFileCredentialsProvider  object in which sqsCredsFilename is the fully qualified path to a properties file from which the AWS security credentials are to be loaded. For example  /etc/somewhere/credentials.properties  static class MyConnectionFactoryBuilder implements JMSBase.ConnectionFactoryBuilder {\n\nString sqsCredsFilename;\n\nMyConnectionFactoryBuilder()\n{\n}\n\n@Override\npublic ConnectionFactory buildConnectionFactory() \n{\n  // Create the connection factory using the properties file credential provider.\n  // Connections this factory creates can talk to the queues in us-east-1 region. \n  SQSConnectionFactory connectionFactory =\n    SQSConnectionFactory.builder()\n      .withRegion(Region.getRegion(Regions.US_EAST_1))\n      .withAWSCredentialsProvider(new PropertiesFileCredentialsProvider(sqsCredsFilename))\n      .build();\n    return connectionFactory;\n  }\n}",
            "title": "SQS Example"
        },
        {
            "location": "/operators/jsonFormatter/",
            "text": "Json Formatter\n\n\nOperator Objective\n\n\nPurpose of JsonFormatter is to consume Plain Old Java Object (\"POJO\") and write them as JSON.\nJson Formatter is \nidempotent\n, \nfault-tolerance\n & \nstatically/dynamically partitionable\n.\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location:\n_malhar-library\n\n\nAvailable since:\n3.2.0\n\n\nOperator state:\nEvolving\n\n\nJava Package:\ncom.datatorrent.lib.formatter.JsonFormatter\n\n\n\n\nProperties, Attributes and Ports\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on input port which tells operator the class of incoming POJO\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be formatted are recieved on this port\n\n\nObject (POJO)\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid Tuples that are emitted as JSON\n\n\nString\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid Tuples are emitted on this port\n\n\nObject\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nJSON Formatter is both statically and dynamically partitionable.\n\n\nStatic Partitioning\n\n\nThis can be achieved in 2 ways\n\n\n\n\nSpecifying the partitioner and number of partitions in the populateDAG() method\n\n\n\n\nJsonFormatter jsonFormatter = dag.addOperator(\"jsonFormatter\", JsonFormatter.class);\nStatelessPartitioner<JsonFormatter> partitioner1 = new StatelessPartitioner<JsonFormatter>(2);\ndag.setAttribute(jsonFormatter, Context.OperatorContext.PARTITIONER, partitioner1 );\n\n\n\n\n\n\nSpecifying the partitioner in properties file.\n\n\n\n\n <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>\n\n\n\n\nwhere {OperatorName} is the name of the JsonFormatter operator.\n Above lines will partition JsonFormatter statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Paritioning\n\n\nJsonFormatter can be dynamically partitioned using an out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partition JsonFormatter:\n\n\nJsonFormatter jsonFormatter = dag.addOperator(\"jsonFormatter\", JsonFormatter.class);\nStatelessThroughputBasedPartitioner<JsonFormatter> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(JsonFormatter, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(JsonFormatter, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition JsonFormatter when the throughput changes.\nIf the overall throughput of JsonFormatter goes beyond 30000 or less than 10000, the platform will repartition JsonFormatter\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nExample for Json Formatter can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/parser\n\n\nAdvance Features\n\n\nJsonFormatter is based on \njackson-databind\n and so users can make use of \nannotations\n in POJO class. Here are few annotations that are relavant while using JsonFormatter\n1. \n@JsonProperty\n : Sometimes POJOs contain properties that has different name from incoming POJOs.You can specify names as:\n\n\npublic class Ad{\n  @JsonProperty(\"desc\")\n  public String description;\n  public List<String> sizes;\n}\n\n\n\n\n\n\n@JsonIgnore\n : Sometimes POJOs contain properties that you do not want to write out, so you can do:\n\n\n\n\npublic class Value {\n  public int value;\n  @JsonIgnore\n  public int internalValue;\n}\n\n\n\n\n\n\n@JsonFormat\n :  Sometimes Date fields need to be printed in custom format, so you can do:\n\n\n\n\npublic class Ad{\n  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"EEE, d MMM yyyy HH:mm:ss\")\n   public Date startDate;\n}",
            "title": "JSON Formatter"
        },
        {
            "location": "/operators/jsonFormatter/#json-formatter",
            "text": "",
            "title": "Json Formatter"
        },
        {
            "location": "/operators/jsonFormatter/#operator-objective",
            "text": "Purpose of JsonFormatter is to consume Plain Old Java Object (\"POJO\") and write them as JSON.\nJson Formatter is  idempotent ,  fault-tolerance  &  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/jsonFormatter/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/jsonFormatter/#operator-information",
            "text": "Operator location: _malhar-library  Available since: 3.2.0  Operator state: Evolving  Java Package: com.datatorrent.lib.formatter.JsonFormatter",
            "title": "Operator Information"
        },
        {
            "location": "/operators/jsonFormatter/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/jsonFormatter/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      in.TUPLE_CLASS  TUPLE_CLASS attribute on input port which tells operator the class of incoming POJO  Class or FQCN  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/jsonFormatter/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be formatted are recieved on this port  Object (POJO)  Yes    out  Valid Tuples that are emitted as JSON  String  No    err  Invalid Tuples are emitted on this port  Object  No",
            "title": "Ports"
        },
        {
            "location": "/operators/jsonFormatter/#partitioning",
            "text": "JSON Formatter is both statically and dynamically partitionable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/jsonFormatter/#static-partitioning",
            "text": "This can be achieved in 2 ways   Specifying the partitioner and number of partitions in the populateDAG() method   JsonFormatter jsonFormatter = dag.addOperator(\"jsonFormatter\", JsonFormatter.class);\nStatelessPartitioner<JsonFormatter> partitioner1 = new StatelessPartitioner<JsonFormatter>(2);\ndag.setAttribute(jsonFormatter, Context.OperatorContext.PARTITIONER, partitioner1 );   Specifying the partitioner in properties file.    <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>  where {OperatorName} is the name of the JsonFormatter operator.\n Above lines will partition JsonFormatter statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/jsonFormatter/#dynamic-paritioning",
            "text": "JsonFormatter can be dynamically partitioned using an out-of-the-box partitioner:",
            "title": "Dynamic Paritioning"
        },
        {
            "location": "/operators/jsonFormatter/#throughput-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partition JsonFormatter:  JsonFormatter jsonFormatter = dag.addOperator(\"jsonFormatter\", JsonFormatter.class);\nStatelessThroughputBasedPartitioner<JsonFormatter> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(JsonFormatter, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(JsonFormatter, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition JsonFormatter when the throughput changes.\nIf the overall throughput of JsonFormatter goes beyond 30000 or less than 10000, the platform will repartition JsonFormatter\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/jsonFormatter/#example",
            "text": "Example for Json Formatter can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Example"
        },
        {
            "location": "/operators/jsonFormatter/#advance-features",
            "text": "JsonFormatter is based on  jackson-databind  and so users can make use of  annotations  in POJO class. Here are few annotations that are relavant while using JsonFormatter\n1.  @JsonProperty  : Sometimes POJOs contain properties that has different name from incoming POJOs.You can specify names as:  public class Ad{\n  @JsonProperty(\"desc\")\n  public String description;\n  public List<String> sizes;\n}   @JsonIgnore  : Sometimes POJOs contain properties that you do not want to write out, so you can do:   public class Value {\n  public int value;\n  @JsonIgnore\n  public int internalValue;\n}   @JsonFormat  :  Sometimes Date fields need to be printed in custom format, so you can do:   public class Ad{\n  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"EEE, d MMM yyyy HH:mm:ss\")\n   public Date startDate;\n}",
            "title": "Advance Features"
        },
        {
            "location": "/operators/jsonParser/",
            "text": "Json Parser\n\n\nOperator Objective\n\n\nPurpose of JsonParser operator is to parse JSON records and construct a Plain Old Java Object (\"POJO\") out of it. The operator also emits each record as JSONObject if the relevant output port is connected. User can also provide a schema describing JSON data to validate incoming JSON records. Valid records will be emitted as POJO / JSONObject while invalid ones are emitted on error port with the error message if the error port is connected.\n\n\nJson Parser is \nidempotent\n, \nfault-tolerant\n & \nstatically/dynamically partitionable\n.\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location:\nmalhar-contrib\n\n\nAvailable since:\n3.2.0\n\n\nOperator state:\nEvolving\n\n\nJava Package:\ncom.datatorrent.contrib.parser.JsonParser\n\n\n\n\nProperties, Attributes and Ports\n\n\nProperties of Json Parser\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\njsonSchema\n\n\nSchema\n  describing JSON data. Incoming records can be validated using the jsonSchema. If the data is not as per the requirements specified in jsonSchema, they are emitted on the error port.This is an optional property. If the schema is not provided, incoming tuples are simply converted to POJO or JSONObject without any validations\n\n\nString\n\n\nNO\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influences operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nout.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which needs to be emitted. The name of the field members of the class must match with the names in incoming POJO. The operator ignores unknown properties.\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be parsed are recieved on this port\n\n\nbyte[]\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid Tuples that are emitted as pojo. Tuples are converted to POJO only if the port is connected.\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nparsedOutput\n\n\nValid Tuples that are emitted as JSONObject. Tuples are converted to JSONObject only if the port is connected.\n\n\nJSONObject\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid Tuples are emitted with error message. Invaid tuples are discarded if the port is not connected.\n\n\nKeyValPair <String, String>\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nJSON Parser is both statically and dynamically partitionable.\n\n\nStatic Partitioning\n\n\nThis can be achieved in 2 ways\n\n\n\n\nSpecifying the partitioner and number of partitions in the populateDAG() method\n\n\n\n\nJsonParser jsonParser = dag.addOperator(\"jsonParser\", JsonParser.class);\nStatelessPartitioner<JsonParser> partitioner1 = new StatelessPartitioner<JsonParser>(2);\ndag.setAttribute(jsonParser, Context.OperatorContext.PARTITIONER, partitioner1 );\n\n\n\n\n\n\nSpecifying the partitioner in properties file.\n\n\n\n\n <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>\n\n\n\n\nwhere {OperatorName} is the name of the JsonParser operator.\n Above lines will partition JsonParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Paritioning\n\n\nJsonParser can be dynamically partitioned using an out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG method of application to dynamically partition JsonParser:\n\n\nJsonParser jsonParser = dag.addOperator(\"jsonParser\", JsonParser.class);\nStatelessThroughputBasedPartitioner<JsonParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(jsonParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(jsonParser, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition JsonParser when the throughput changes.\nIf the overall throughput of JsonParser goes beyond 30000 or less than 10000, the platform will repartition JsonParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nExample for Json Parser can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "JSON Parser"
        },
        {
            "location": "/operators/jsonParser/#json-parser",
            "text": "",
            "title": "Json Parser"
        },
        {
            "location": "/operators/jsonParser/#operator-objective",
            "text": "Purpose of JsonParser operator is to parse JSON records and construct a Plain Old Java Object (\"POJO\") out of it. The operator also emits each record as JSONObject if the relevant output port is connected. User can also provide a schema describing JSON data to validate incoming JSON records. Valid records will be emitted as POJO / JSONObject while invalid ones are emitted on error port with the error message if the error port is connected.  Json Parser is  idempotent ,  fault-tolerant  &  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/jsonParser/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/jsonParser/#operator-information",
            "text": "Operator location: malhar-contrib  Available since: 3.2.0  Operator state: Evolving  Java Package: com.datatorrent.contrib.parser.JsonParser",
            "title": "Operator Information"
        },
        {
            "location": "/operators/jsonParser/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/jsonParser/#platform-attributes-that-influences-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      out.TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which needs to be emitted. The name of the field members of the class must match with the names in incoming POJO. The operator ignores unknown properties.  Class or FQCN  Yes",
            "title": "Platform Attributes that influences operator behavior"
        },
        {
            "location": "/operators/jsonParser/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be parsed are recieved on this port  byte[]  Yes    out  Valid Tuples that are emitted as pojo. Tuples are converted to POJO only if the port is connected.  Object (POJO)  No    parsedOutput  Valid Tuples that are emitted as JSONObject. Tuples are converted to JSONObject only if the port is connected.  JSONObject  No    err  Invalid Tuples are emitted with error message. Invaid tuples are discarded if the port is not connected.  KeyValPair <String, String>  No",
            "title": "Ports"
        },
        {
            "location": "/operators/jsonParser/#partitioning",
            "text": "JSON Parser is both statically and dynamically partitionable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/jsonParser/#static-partitioning",
            "text": "This can be achieved in 2 ways   Specifying the partitioner and number of partitions in the populateDAG() method   JsonParser jsonParser = dag.addOperator(\"jsonParser\", JsonParser.class);\nStatelessPartitioner<JsonParser> partitioner1 = new StatelessPartitioner<JsonParser>(2);\ndag.setAttribute(jsonParser, Context.OperatorContext.PARTITIONER, partitioner1 );   Specifying the partitioner in properties file.    <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>  where {OperatorName} is the name of the JsonParser operator.\n Above lines will partition JsonParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/jsonParser/#dynamic-paritioning",
            "text": "JsonParser can be dynamically partitioned using an out-of-the-box partitioner:",
            "title": "Dynamic Paritioning"
        },
        {
            "location": "/operators/jsonParser/#throughput-based",
            "text": "Following code can be added to populateDAG method of application to dynamically partition JsonParser:  JsonParser jsonParser = dag.addOperator(\"jsonParser\", JsonParser.class);\nStatelessThroughputBasedPartitioner<JsonParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\npartitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\npartitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\ndag.setAttribute(jsonParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(jsonParser, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition JsonParser when the throughput changes.\nIf the overall throughput of JsonParser goes beyond 30000 or less than 10000, the platform will repartition JsonParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/jsonParser/#example",
            "text": "Example for Json Parser can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Example"
        },
        {
            "location": "/operators/kafkaInputOperator/",
            "text": "KAFKA INPUT OPERATOR\n\n\nIntroduction\n\n\nApache Kafka\n is a pull-based and distributed publish subscribe messaging system,\ntopics are partitioned and replicated across nodes. \n\n\nThe Kafka input operator consumes data from the partitions of a Kafka topic for processing in Apex. \nThe operator has the ability to automatically scale with the Kafka partitioning for high throughput. \nIt is fault-tolerant (consumer offset checkpointing) and guarantees idempotency to allow exactly-once results in the downstream pipeline.\n\n\nFor more information about the operator design see this \npresentation\n\nand for processing guarantees this \nblog\n.\n\n\nThere are two separate implementations of the input operator,\none built against Kafka 0.8 client and a newer version for the\nKafka 0.9 consumer API that also works with MapR Streams.\nThese reside in different packages and are described separately below.\n\n\nKafka Input Operator for Kafka 0.8.x\n\n\nPackage: \ncom.datatorrent.contrib.kafka\n\n\nMaven artifact: \nmalhar-contrib\n\n\nAbstractKafkaInputOperator\n\n\nThis is the abstract implementation that serves as base class for consuming messages from Kafka messaging system. This class doesn\u2019t have any ports.\n\n\n\n\nConfiguration Parameters\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\nmaxTuplesPerWindow\n\n\nControls the maximum number of messages emitted in each streaming window from this operator. Minimum value is 1. Default value = MAX_VALUE \n\n\n\n\n\n\nidempotentStorageManager\n\n\nThis is an instance of IdempotentStorageManager. Idempotency ensures that the operator will process the same set of messages in a window before and after a failure. For example, let's say the operator completed window 10 and failed somewhere between window 11. If the operator gets restored at window 10 then it will process the same messages again in window 10 which it did in the previous run before the failure. Idempotency is important but comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window. Default Value = com.datatorrent.lib.io.IdempotentStorageManager.\nNoopIdempotentStorageManager\n\n\n\n\n\n\nstrategy\n\n\nOperator supports two types of partitioning strategies, ONE_TO_ONE and ONE_TO_MANY.\n\n\nONE_TO_ONE: If this is enabled, the AppMaster creates one input operator instance per Kafka topic partition. So the number of Kafka topic partitions equals the number of operator instances.\n\n\nONE_TO_MANY: The AppMaster creates K = min(initialPartitionCount, N) Kafka input operator instances where N is the number of Kafka topic partitions. If K is less than N, the remaining topic partitions are assigned to the K operator instances in round-robin fashion. If K is less than initialPartitionCount, the AppMaster creates one input operator instance per Kafka topic partition. For example, if initialPartitionCount = 5 and number of Kafka partitions(N) = 2 then AppMaster creates 2 Kafka input operator instances.\nDefault Value = ONE_TO_ONE\n\n\n\n\n\n\nmsgRateUpperBound\n\n\nMaximum messages upper bound. Operator repartitions when the \nmsgProcessedPS\n exceeds this bound. \nmsgProcessedPS\n is the average number of messages processed per second by this operator.\n\n\n\n\n\n\nbyteRateUpperBound\n\n\nMaximum bytes upper bound. Operator repartitions when the \nbytesPS\n exceeds this bound. \nbytesPS\n is the average number of bytes processed per second by this operator.\n\n\n\n\n\n\n\n\noffsetManager\n\n\nThis is an optional parameter that is useful when the application restarts or start at specific offsets (offsets are explained below)\n\n\n\n\n\n\nrepartitionInterval\n\n\nInterval specified in milliseconds. This value specifies the minimum time required between two repartition actions. Default Value = 30 Seconds\n\n\n\n\n\n\nrepartitionCheckInterval\n\n\nInterval specified in milliseconds. This value specifies the minimum interval between two offset updates. Default Value = 5 Seconds\n\n\n\n\n\n\ninitialPartitionCount\n\n\nWhen the ONE_TO_MANY partition strategy is enabled, this value indicates the number of Kafka input operator instances. Default Value = 1\n\n\n\n\n\n\nconsumer\n\n\nThis is an instance of com.datatorrent.contrib.kafka.KafkaConsumer. Default Value = Instance of SimpleKafkaConsumer.\n\n\n\n\n\n\n\n\nAbstract Methods\n\n\nvoid emitTuple(Message message)\n: Abstract method that emits tuples extracted from Kafka message.\n\n\nKafkaConsumer\n\n\nThis is an abstract implementation of Kafka consumer. It sends the fetch\nrequests to the leading brokers of Kafka partitions. For each request,\nit receives the set of messages and stores them into the buffer which is\nArrayBlockingQueue. SimpleKafkaConsumer\u00a0which extends\nKafkaConsumer and serves the functionality of Simple Consumer API and\nHighLevelKafkaConsumer which extends KafkaConsumer and \u00a0serves the\nfunctionality of High Level Consumer API.\n\n\nPre-requisites\n\n\nThis operator uses the Kafka 0.8.2.1 client consumer API\nand will work with 0.8.x and 0.7.x versions of Kafka broker.\n\n\nConfiguration Parameters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\nzookeeper\n\n\nString\n\n\n\n\nSpecifies the zookeeper quorum of Kafka clusters that you want to consume messages from. zookeeper \u00a0is a string in the form of hostname1:port1,hostname2:port2,hostname3:port3 \u00a0where hostname1,hostname2,hostname3 are hosts and port1,port2,port3 are ports of zookeeper server. \u00a0If the topic name is the same across the Kafka clusters and want to consume data from these clusters, then configure the zookeeper as follows: c1::hs1:p1,hs2:p2,hs3:p3;c2::hs4:p4,hs5:p5,c3::hs6:p6\n\n\nwhere\n\n\nc1,c2,c3 indicates the cluster names, hs1,hs2,hs3,hs4,hs5,hs6 are zookeeper hosts and p1,p2,p3,p4,p5,p6 are corresponding ports. Here, cluster name is optional in case of single cluster\n\n\n\n\n\n\ncacheSize\n\n\nint\n\n\n1024\n\n\nMaximum of buffered messages hold in memory.\n\n\n\n\n\n\ntopic\n\n\nString\n\n\ndefault_topic\n\n\nIndicates the name of the topic.\n\n\n\n\n\n\ninitialOffset\n\n\nString\n\n\nlatest\n\n\nIndicates the type of offset i.e, \u201cearliest or latest\u201d. If initialOffset is \u201clatest\u201d, then the operator consumes messages from latest point of Kafka queue. If initialOffset is \u201cearliest\u201d, then the operator consumes messages starting from message queue. This can be overridden by OffsetManager.\n\n\n\n\n\n\n\n\n\nAbstract Methods\n\n\n\n\nvoid commitOffset(): Commit the offsets at checkpoint.\n\n\nMap <KafkaPartition, Long> getCurrentOffsets(): Return the current\n    offset status.\n\n\nresetPartitionsAndOffset(Set <KafkaPartition> partitionIds,\n    Map <KafkaPartition, Long> startOffset): Reset the partitions with\n    parittionIds and offsets with startOffset.\n\n\n\n\nConfiguration Parameters\u00a0for SimpleKafkaConsumer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\nbufferSize\n\n\nint\n\n\n1 MB\n\n\nSpecifies the maximum total size of messages for each fetch request.\n\n\n\n\n\n\nmetadataRefreshInterval\n\n\nint\n\n\n30 Seconds\n\n\nInterval in between refresh the metadata change(broker change) in milliseconds. Enabling metadata refresh guarantees an automatic reconnect when a new broker is elected as the host. A value of -1 disables this feature.\n\n\n\n\n\n\nmetadataRefreshRetryLimit\n\n\nint\n\n\n-1\n\n\nSpecifies the maximum brokers' metadata refresh retry limit. -1 means unlimited retry.\n\n\n\n\n\n\n\n\n\nOffsetManager\n\n\nThis is an interface for offset management and is useful when consuming data\nfrom specified offsets. Updates the offsets for all the Kafka partitions\nperiodically. Below is the code snippet:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\n\npublic interface OffsetManager\n{\n  public Map<KafkaPartition, Long> loadInitialOffsets();\n  public void updateOffsets(Map<KafkaPartition, Long> offsetsOfPartitions);\n}\n\n\n\n\nAbstract Methods\n\n\nMap <KafkaPartition, Long> loadInitialOffsets()\n: Specifies the initial offset for consuming messages; called at the activation stage.\n\n\nupdateOffsets(Map<KafkaPartition, Long> offsetsOfPartitions)\n: \u00a0This\nmethod is called at every repartitionCheckInterval to update offsets.\n\n\nPartitioning\n\n\nThe logical instance of the KafkaInputOperator acts as the Partitioner\nas well as a StatsListener. This is because the\nAbstractKafkaInputOperator implements both the\ncom.datatorrent.api.Partitioner and com.datatorrent.api.StatsListener\ninterfaces and provides an implementation of definePartitions(...) and\nprocessStats(...) which makes it auto-scalable.\n\n\nResponse processStats(BatchedOperatorStats stats)\n\n\nThe application master invokes this method on the logical instance with\nthe stats (tuplesProcessedPS, bytesPS, etc.) of each partition.\nRe-partitioning happens based on whether any new Kafka partitions added for\nthe topic or bytesPS and msgPS cross their respective upper bounds.\n\n\nDefinePartitions\n\n\nBased on the repartitionRequired field of the Response object which is\nreturned by processStats(...) method, the application master invokes\ndefinePartitions(...) on the logical instance which is also the\npartitioner instance. Dynamic partition can be disabled by setting the\nparameter repartitionInterval value to a negative value.\n\n\nAbstractSinglePortKafkaInputOperator\n\n\nThis class extends AbstractKafkaInputOperator to emit messages through single output port.\n\n\nPorts\n\n\noutputPort <T>\n: Tuples extracted from Kafka messages are emitted through this port.\n\n\nAbstract Methods\n\n\nT getTuple(Message msg)\n: Converts the Kafka message to tuple.\n\n\nConcrete Classes\n\n\n\n\nKafkaSinglePortStringInputOperator: extends \nAbstractSinglePortKafkaInputOperator\n, extracts string from Kafka message.\n\n\nKafkaSinglePortByteArrayInputOperator: extends \nAbstractSinglePortKafkaInputOperator\n, extracts byte array from Kafka message.\n\n\n\n\nApplication Example\n\n\nThis section builds an Apex application using Kafka input operator.\nBelow is the code snippet:\n\n\n@ApplicationAnnotation(name = \"KafkaApp\")\npublic class ExampleKafkaApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration entries)\n  {\n    KafkaSinglePortByteArrayInputOperator input =  dag.addOperator(\"MessageReader\", new KafkaSinglePortByteArrayInputOperator());\n    ConsoleOutputOperator output = dag.addOperator(\"Output\", new ConsoleOutputOperator());\n    dag.addStream(\"MessageData\", input.outputPort, output.input);\n  }\n}\n\n\n\n\nBelow is the configuration for \u201ctest\u201d Kafka topic name and\n\u201clocalhost:2181\u201d is the zookeeper forum:\n\n\n<property>\n  <name>dt.operator.MessageReader.prop.topic</name>\n  <value>test</value>\n</property>\n\n<property>\n  <name>dt.operator.KafkaInputOperator.prop.zookeeper</nam>\n  <value>localhost:2181</value>\n</property>\n\n\n\n\nKafka Input Operator for Kafka 0.9.x\n\n\nPackage: \norg.apache.apex.malhar.kafka\n\n\nMaven Artifact: \nmalhar-kafka\n\n\nThis version uses the new 0.9 version of consumer API and works with Kafka broker version 0.9 and later.\nThe operator is fault-tolerant, scalable and supports input from multiple clusters and multiple topics in a single operator instance.\n\n\nPre-requisites\n\n\nThis operator requires version 0.9.0 or later of the Kafka Consumer API.\n\n\nAbstractKafkaInputOperator\n\n\nPorts\n\n\n\n\nThis abstract class doesn't have any ports.\n\n\nConfiguration properties\n\n\n\n\n\n\n\n\nclusters\n - String[]\n\n\n\n\nMandatory Parameter.\n\n\nSpecifies the Kafka clusters that you want to consume messages from. To configure multi-cluster support, you need to specify the clusters separated by \";\".\n\n\n\n\n\n\n\n\ntopics\n - String[]\n\n\n\n\nMandatory Parameter.\n\n\nSpecified the Kafka topics that you want to consume messages from. If you want multi-topic support, then specify the topics separated by \",\".\n\n\n\n\n\n\n\n\nstrategy\n - PartitionStrategy\n\n\n\n\n\n\nOperator supports two types of partitioning strategies, \nONE_TO_ONE\n and \nONE_TO_MANY\n.\n\n\nONE_TO_ONE\n: If this is enabled, the AppMaster creates one input operator instance per Kafka topic partition. So the number of Kafka topic partitions equals the number of operator instances.\n\nONE_TO_MANY\n: The AppMaster creates K = min(initialPartitionCount, N) Kafka input operator instances where N is the number of Kafka topic partitions. If K is less than N, the remaining topic partitions are assigned to the K operator instances in round-robin fashion. If K is less than initialPartitionCount, the AppMaster creates one input operator instance per Kafka topic partition. For example, if initialPartitionCount = 5 and number of Kafka partitions(N) = 2 then AppMaster creates 2 Kafka input operator instances.\nDefault Value = \nPartitionStrategy.ONE_TO_ONE\n.\n\n\n\n\n\n\n\n\n\n\ninitialPartitionCount\n - Integer\n\n\n\n\nWhen the ONE_TO_MANY partition strategy is enabled, this value indicates the number of Kafka input operator instances. \n    Default Value = 1.\n\n\n\n\n\n\n\n\nrepartitionInterval\n - Long\n\n\n\n\nInterval specified in milliseconds. This value specifies the minimum time required between two repartition actions. \n    Default Value = 30 Seconds.\n\n\n\n\n\n\n\n\nrepartitionCheckInterval\n - Long\n\n\n\n\nInterval specified in milliseconds. This value specifies the minimum interval between two stat checks.\n    Default Value = 5 Seconds.\n\n\n\n\n\n\n\n\nmaxTuplesPerWindow\n - Integer\n\n\n\n\nControls the maximum number of messages emitted in each streaming window from this operator. Minimum value is 1. \n    Default value = \nMAX_VALUE\n \n\n\n\n\n\n\n\n\ninitialOffset\n - InitialOffset\n\n\n\n\nIndicates the type of offset i.e, \nEARLIEST\n or \nLATEST\n or \nAPPLICATION_OR_EARLIEST\n or \nAPPLICATION_OR_LATEST\n. \n    \nLATEST\n => Consume new messages from latest offset in the topic. \n    \nEARLIEST\n => Consume all messages available in the topic.\n    \nAPPLICATION_OR_EARLIEST\n => Consume messages from committed position from last run. If there is no committed offset, then start consuming from beginning.\n    \nAPPLICATION_OR_LATEST\n => Consumes messages from committed position from last run. If a committed offset is unavailable, then start consuming from latest position.\n    Default value = \nInitialOffset.APPLICATION_OR_LATEST\n\n\n\n\n\n\n\n\nmetricsRefreshInterval\n - Long\n\n\n\n\nInterval specified in milliseconds. This value specifies the minimum interval between two metric stat updates.\n    Default value = 5 Seconds.\n\n\n\n\n\n\n\n\nconsumerTimeout\n - Long\n\n\n\n\nIndicates the \ntime waiting in poll\n when data is not available.\n    Default value = 5 Seconds.\n\n\n\n\n\n\n\n\nholdingBufferSize\n - Long\n\n\n\n\nIndicates the maximum number of messages kept in memory for emitting.\n    Default value = 1024.\n\n\n\n\n\n\n\n\nconsumerProps\n - Properties\n\n\n\n\nSpecify the [consumer properties[(http://kafka.apache.org/090/documentation.html#newconsumerconfigs) which are not yet set to the operator.\n\n\n\n\n\n\n\n\nwindowDataManager\n - WindowDataManager\n\n\n\n\nIf set to a value other than the default, such as \nFSWindowDataManager\n, specifies that the operator will process the same set of messages in a window before and after a failure. This is important but it comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window.\n    Default value = \nWindowDataManager.NoopWindowDataManager\n.\n\n\n\n\n\n\n\n\nAbstract Methods\n\n\nvoid emitTuple(String cluster, ConsumerRecord<byte[], byte[]> message)\n: Abstract method that emits tuples\nextracted from Kafka message.\n\n\nConcrete Classes\n\n\nKafkaSinglePortInputOperator\n\n\nThis class extends from AbstractKafkaInputOperator and defines the \ngetTuple()\n method which extracts byte array from Kafka message.\n\n\nPorts\n\n\noutputPort <byte[]>\n: Tuples extracted from Kafka messages are emitted through this port.\n\n\nApplication Example\n\n\nThis section builds an Apex application using Kafka input operator.\nBelow is the code snippet:\n\n\n@ApplicationAnnotation(name = \"KafkaApp\")\npublic class ExampleKafkaApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration entries)\n  {\n    KafkaSinglePortInputOperator input =  dag.addOperator(\"MessageReader\", new KafkaSinglePortInputOperator());\n    ConsoleOutputOperator output = dag.addOperator(\"Output\", new ConsoleOutputOperator());\n    dag.addStream(\"MessageData\", input.outputPort, output.input);\n  }\n}\n\n\n\n\nBelow is the configuration for topic \u201ctest\u201d and broker \u201clocalhost:9092\u201d:\n\n\n<property>\n  <name>apex.operator.MessageReader.prop.topics</name>\n  <value>test</value>\n</property>\n\n<property>\n  <name>apex.operator.KafkaInputOperator.prop.clusters</name>\n  <value>localhost:9092</value>\n</property>\n\n\n\n\nMultiple topics can be specified as a comma-separated list; similarly, multiple clusters can be specified as a semicolon-separated list; for example:\n\n\n<property>\n  <name>apex.operator.MessageReader.prop.topics</name>\n  <value>test1, test2</value>\n</property>\n\n<property>\n  <name>apex.operator.KafkaInputOperator.prop.clusters</nam>\n  <value>localhost:9092; localhost:9093; localhost:9094</value>\n</property>\n\n\n\n\nA full example application project can be found \nhere\n.\n\n\nSecurity\n\n\nKafka from 0.9.x onwards supports \nAuthentication, Encryption and Authorization\n.\n\n\nSee \nhere\n for more information.",
            "title": "Kafka Input"
        },
        {
            "location": "/operators/kafkaInputOperator/#kafka-input-operator",
            "text": "",
            "title": "KAFKA INPUT OPERATOR"
        },
        {
            "location": "/operators/kafkaInputOperator/#introduction",
            "text": "Apache Kafka  is a pull-based and distributed publish subscribe messaging system,\ntopics are partitioned and replicated across nodes.   The Kafka input operator consumes data from the partitions of a Kafka topic for processing in Apex. \nThe operator has the ability to automatically scale with the Kafka partitioning for high throughput. \nIt is fault-tolerant (consumer offset checkpointing) and guarantees idempotency to allow exactly-once results in the downstream pipeline.  For more information about the operator design see this  presentation \nand for processing guarantees this  blog .  There are two separate implementations of the input operator,\none built against Kafka 0.8 client and a newer version for the\nKafka 0.9 consumer API that also works with MapR Streams.\nThese reside in different packages and are described separately below.",
            "title": "Introduction"
        },
        {
            "location": "/operators/kafkaInputOperator/#kafka-input-operator-for-kafka-08x",
            "text": "Package:  com.datatorrent.contrib.kafka  Maven artifact:  malhar-contrib",
            "title": "Kafka Input Operator for Kafka 0.8.x"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstractkafkainputoperator",
            "text": "This is the abstract implementation that serves as base class for consuming messages from Kafka messaging system. This class doesn\u2019t have any ports.",
            "title": "AbstractKafkaInputOperator"
        },
        {
            "location": "/operators/kafkaInputOperator/#configuration-parameters",
            "text": "Parameter  Description    maxTuplesPerWindow  Controls the maximum number of messages emitted in each streaming window from this operator. Minimum value is 1. Default value = MAX_VALUE     idempotentStorageManager  This is an instance of IdempotentStorageManager. Idempotency ensures that the operator will process the same set of messages in a window before and after a failure. For example, let's say the operator completed window 10 and failed somewhere between window 11. If the operator gets restored at window 10 then it will process the same messages again in window 10 which it did in the previous run before the failure. Idempotency is important but comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window. Default Value = com.datatorrent.lib.io.IdempotentStorageManager. NoopIdempotentStorageManager    strategy  Operator supports two types of partitioning strategies, ONE_TO_ONE and ONE_TO_MANY.  ONE_TO_ONE: If this is enabled, the AppMaster creates one input operator instance per Kafka topic partition. So the number of Kafka topic partitions equals the number of operator instances.  ONE_TO_MANY: The AppMaster creates K = min(initialPartitionCount, N) Kafka input operator instances where N is the number of Kafka topic partitions. If K is less than N, the remaining topic partitions are assigned to the K operator instances in round-robin fashion. If K is less than initialPartitionCount, the AppMaster creates one input operator instance per Kafka topic partition. For example, if initialPartitionCount = 5 and number of Kafka partitions(N) = 2 then AppMaster creates 2 Kafka input operator instances.\nDefault Value = ONE_TO_ONE    msgRateUpperBound  Maximum messages upper bound. Operator repartitions when the  msgProcessedPS  exceeds this bound.  msgProcessedPS  is the average number of messages processed per second by this operator.    byteRateUpperBound  Maximum bytes upper bound. Operator repartitions when the  bytesPS  exceeds this bound.  bytesPS  is the average number of bytes processed per second by this operator.     offsetManager  This is an optional parameter that is useful when the application restarts or start at specific offsets (offsets are explained below)    repartitionInterval  Interval specified in milliseconds. This value specifies the minimum time required between two repartition actions. Default Value = 30 Seconds    repartitionCheckInterval  Interval specified in milliseconds. This value specifies the minimum interval between two offset updates. Default Value = 5 Seconds    initialPartitionCount  When the ONE_TO_MANY partition strategy is enabled, this value indicates the number of Kafka input operator instances. Default Value = 1    consumer  This is an instance of com.datatorrent.contrib.kafka.KafkaConsumer. Default Value = Instance of SimpleKafkaConsumer.",
            "title": "Configuration Parameters"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstract-methods",
            "text": "void emitTuple(Message message) : Abstract method that emits tuples extracted from Kafka message.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/kafkaInputOperator/#kafkaconsumer",
            "text": "This is an abstract implementation of Kafka consumer. It sends the fetch\nrequests to the leading brokers of Kafka partitions. For each request,\nit receives the set of messages and stores them into the buffer which is\nArrayBlockingQueue. SimpleKafkaConsumer\u00a0which extends\nKafkaConsumer and serves the functionality of Simple Consumer API and\nHighLevelKafkaConsumer which extends KafkaConsumer and \u00a0serves the\nfunctionality of High Level Consumer API.",
            "title": "KafkaConsumer"
        },
        {
            "location": "/operators/kafkaInputOperator/#pre-requisites",
            "text": "This operator uses the Kafka 0.8.2.1 client consumer API\nand will work with 0.8.x and 0.7.x versions of Kafka broker.",
            "title": "Pre-requisites"
        },
        {
            "location": "/operators/kafkaInputOperator/#configuration-parameters_1",
            "text": "Parameter  Type  Default  Description    zookeeper  String   Specifies the zookeeper quorum of Kafka clusters that you want to consume messages from. zookeeper \u00a0is a string in the form of hostname1:port1,hostname2:port2,hostname3:port3 \u00a0where hostname1,hostname2,hostname3 are hosts and port1,port2,port3 are ports of zookeeper server. \u00a0If the topic name is the same across the Kafka clusters and want to consume data from these clusters, then configure the zookeeper as follows: c1::hs1:p1,hs2:p2,hs3:p3;c2::hs4:p4,hs5:p5,c3::hs6:p6  where  c1,c2,c3 indicates the cluster names, hs1,hs2,hs3,hs4,hs5,hs6 are zookeeper hosts and p1,p2,p3,p4,p5,p6 are corresponding ports. Here, cluster name is optional in case of single cluster    cacheSize  int  1024  Maximum of buffered messages hold in memory.    topic  String  default_topic  Indicates the name of the topic.    initialOffset  String  latest  Indicates the type of offset i.e, \u201cearliest or latest\u201d. If initialOffset is \u201clatest\u201d, then the operator consumes messages from latest point of Kafka queue. If initialOffset is \u201cearliest\u201d, then the operator consumes messages starting from message queue. This can be overridden by OffsetManager.",
            "title": "Configuration Parameters"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstract-methods_1",
            "text": "void commitOffset(): Commit the offsets at checkpoint.  Map <KafkaPartition, Long> getCurrentOffsets(): Return the current\n    offset status.  resetPartitionsAndOffset(Set <KafkaPartition> partitionIds,\n    Map <KafkaPartition, Long> startOffset): Reset the partitions with\n    parittionIds and offsets with startOffset.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/kafkaInputOperator/#configuration-parameters-for-simplekafkaconsumer",
            "text": "Parameter  Type  Default  Description    bufferSize  int  1 MB  Specifies the maximum total size of messages for each fetch request.    metadataRefreshInterval  int  30 Seconds  Interval in between refresh the metadata change(broker change) in milliseconds. Enabling metadata refresh guarantees an automatic reconnect when a new broker is elected as the host. A value of -1 disables this feature.    metadataRefreshRetryLimit  int  -1  Specifies the maximum brokers' metadata refresh retry limit. -1 means unlimited retry.",
            "title": "Configuration Parameters\u00a0for SimpleKafkaConsumer"
        },
        {
            "location": "/operators/kafkaInputOperator/#offsetmanager",
            "text": "This is an interface for offset management and is useful when consuming data\nfrom specified offsets. Updates the offsets for all the Kafka partitions\nperiodically. Below is the code snippet:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  public interface OffsetManager\n{\n  public Map<KafkaPartition, Long> loadInitialOffsets();\n  public void updateOffsets(Map<KafkaPartition, Long> offsetsOfPartitions);\n}",
            "title": "OffsetManager"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstract-methods_2",
            "text": "Map <KafkaPartition, Long> loadInitialOffsets() : Specifies the initial offset for consuming messages; called at the activation stage.  updateOffsets(Map<KafkaPartition, Long> offsetsOfPartitions) : \u00a0This\nmethod is called at every repartitionCheckInterval to update offsets.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/kafkaInputOperator/#partitioning",
            "text": "The logical instance of the KafkaInputOperator acts as the Partitioner\nas well as a StatsListener. This is because the\nAbstractKafkaInputOperator implements both the\ncom.datatorrent.api.Partitioner and com.datatorrent.api.StatsListener\ninterfaces and provides an implementation of definePartitions(...) and\nprocessStats(...) which makes it auto-scalable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/kafkaInputOperator/#response-processstatsbatchedoperatorstats-stats",
            "text": "The application master invokes this method on the logical instance with\nthe stats (tuplesProcessedPS, bytesPS, etc.) of each partition.\nRe-partitioning happens based on whether any new Kafka partitions added for\nthe topic or bytesPS and msgPS cross their respective upper bounds.",
            "title": "Response processStats(BatchedOperatorStats stats)"
        },
        {
            "location": "/operators/kafkaInputOperator/#definepartitions",
            "text": "Based on the repartitionRequired field of the Response object which is\nreturned by processStats(...) method, the application master invokes\ndefinePartitions(...) on the logical instance which is also the\npartitioner instance. Dynamic partition can be disabled by setting the\nparameter repartitionInterval value to a negative value.",
            "title": "DefinePartitions"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstractsingleportkafkainputoperator",
            "text": "This class extends AbstractKafkaInputOperator to emit messages through single output port.",
            "title": "AbstractSinglePortKafkaInputOperator"
        },
        {
            "location": "/operators/kafkaInputOperator/#ports",
            "text": "outputPort <T> : Tuples extracted from Kafka messages are emitted through this port.",
            "title": "Ports"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstract-methods_3",
            "text": "T getTuple(Message msg) : Converts the Kafka message to tuple.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/kafkaInputOperator/#concrete-classes",
            "text": "KafkaSinglePortStringInputOperator: extends  AbstractSinglePortKafkaInputOperator , extracts string from Kafka message.  KafkaSinglePortByteArrayInputOperator: extends  AbstractSinglePortKafkaInputOperator , extracts byte array from Kafka message.",
            "title": "Concrete Classes"
        },
        {
            "location": "/operators/kafkaInputOperator/#application-example",
            "text": "This section builds an Apex application using Kafka input operator.\nBelow is the code snippet:  @ApplicationAnnotation(name = \"KafkaApp\")\npublic class ExampleKafkaApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration entries)\n  {\n    KafkaSinglePortByteArrayInputOperator input =  dag.addOperator(\"MessageReader\", new KafkaSinglePortByteArrayInputOperator());\n    ConsoleOutputOperator output = dag.addOperator(\"Output\", new ConsoleOutputOperator());\n    dag.addStream(\"MessageData\", input.outputPort, output.input);\n  }\n}  Below is the configuration for \u201ctest\u201d Kafka topic name and\n\u201clocalhost:2181\u201d is the zookeeper forum:  <property>\n  <name>dt.operator.MessageReader.prop.topic</name>\n  <value>test</value>\n</property>\n\n<property>\n  <name>dt.operator.KafkaInputOperator.prop.zookeeper</nam>\n  <value>localhost:2181</value>\n</property>",
            "title": "Application Example"
        },
        {
            "location": "/operators/kafkaInputOperator/#kafka-input-operator-for-kafka-09x",
            "text": "Package:  org.apache.apex.malhar.kafka  Maven Artifact:  malhar-kafka  This version uses the new 0.9 version of consumer API and works with Kafka broker version 0.9 and later.\nThe operator is fault-tolerant, scalable and supports input from multiple clusters and multiple topics in a single operator instance.",
            "title": "Kafka Input Operator for Kafka 0.9.x"
        },
        {
            "location": "/operators/kafkaInputOperator/#pre-requisites_1",
            "text": "This operator requires version 0.9.0 or later of the Kafka Consumer API.",
            "title": "Pre-requisites"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstractkafkainputoperator_1",
            "text": "",
            "title": "AbstractKafkaInputOperator"
        },
        {
            "location": "/operators/kafkaInputOperator/#ports_1",
            "text": "This abstract class doesn't have any ports.",
            "title": "Ports"
        },
        {
            "location": "/operators/kafkaInputOperator/#configuration-properties",
            "text": "clusters  - String[]   Mandatory Parameter.  Specifies the Kafka clusters that you want to consume messages from. To configure multi-cluster support, you need to specify the clusters separated by \";\".     topics  - String[]   Mandatory Parameter.  Specified the Kafka topics that you want to consume messages from. If you want multi-topic support, then specify the topics separated by \",\".     strategy  - PartitionStrategy    Operator supports two types of partitioning strategies,  ONE_TO_ONE  and  ONE_TO_MANY .  ONE_TO_ONE : If this is enabled, the AppMaster creates one input operator instance per Kafka topic partition. So the number of Kafka topic partitions equals the number of operator instances. ONE_TO_MANY : The AppMaster creates K = min(initialPartitionCount, N) Kafka input operator instances where N is the number of Kafka topic partitions. If K is less than N, the remaining topic partitions are assigned to the K operator instances in round-robin fashion. If K is less than initialPartitionCount, the AppMaster creates one input operator instance per Kafka topic partition. For example, if initialPartitionCount = 5 and number of Kafka partitions(N) = 2 then AppMaster creates 2 Kafka input operator instances.\nDefault Value =  PartitionStrategy.ONE_TO_ONE .      initialPartitionCount  - Integer   When the ONE_TO_MANY partition strategy is enabled, this value indicates the number of Kafka input operator instances. \n    Default Value = 1.     repartitionInterval  - Long   Interval specified in milliseconds. This value specifies the minimum time required between two repartition actions. \n    Default Value = 30 Seconds.     repartitionCheckInterval  - Long   Interval specified in milliseconds. This value specifies the minimum interval between two stat checks.\n    Default Value = 5 Seconds.     maxTuplesPerWindow  - Integer   Controls the maximum number of messages emitted in each streaming window from this operator. Minimum value is 1. \n    Default value =  MAX_VALUE       initialOffset  - InitialOffset   Indicates the type of offset i.e,  EARLIEST  or  LATEST  or  APPLICATION_OR_EARLIEST  or  APPLICATION_OR_LATEST . \n     LATEST  => Consume new messages from latest offset in the topic. \n     EARLIEST  => Consume all messages available in the topic.\n     APPLICATION_OR_EARLIEST  => Consume messages from committed position from last run. If there is no committed offset, then start consuming from beginning.\n     APPLICATION_OR_LATEST  => Consumes messages from committed position from last run. If a committed offset is unavailable, then start consuming from latest position.\n    Default value =  InitialOffset.APPLICATION_OR_LATEST     metricsRefreshInterval  - Long   Interval specified in milliseconds. This value specifies the minimum interval between two metric stat updates.\n    Default value = 5 Seconds.     consumerTimeout  - Long   Indicates the  time waiting in poll  when data is not available.\n    Default value = 5 Seconds.     holdingBufferSize  - Long   Indicates the maximum number of messages kept in memory for emitting.\n    Default value = 1024.     consumerProps  - Properties   Specify the [consumer properties[(http://kafka.apache.org/090/documentation.html#newconsumerconfigs) which are not yet set to the operator.     windowDataManager  - WindowDataManager   If set to a value other than the default, such as  FSWindowDataManager , specifies that the operator will process the same set of messages in a window before and after a failure. This is important but it comes with higher cost because at the end of each window the operator needs to persist some state with respect to that window.\n    Default value =  WindowDataManager.NoopWindowDataManager .",
            "title": "Configuration properties"
        },
        {
            "location": "/operators/kafkaInputOperator/#abstract-methods_4",
            "text": "void emitTuple(String cluster, ConsumerRecord<byte[], byte[]> message) : Abstract method that emits tuples\nextracted from Kafka message.",
            "title": "Abstract Methods"
        },
        {
            "location": "/operators/kafkaInputOperator/#concrete-classes_1",
            "text": "",
            "title": "Concrete Classes"
        },
        {
            "location": "/operators/kafkaInputOperator/#kafkasingleportinputoperator",
            "text": "This class extends from AbstractKafkaInputOperator and defines the  getTuple()  method which extracts byte array from Kafka message.",
            "title": "KafkaSinglePortInputOperator"
        },
        {
            "location": "/operators/kafkaInputOperator/#ports_2",
            "text": "outputPort <byte[]> : Tuples extracted from Kafka messages are emitted through this port.",
            "title": "Ports"
        },
        {
            "location": "/operators/kafkaInputOperator/#application-example_1",
            "text": "This section builds an Apex application using Kafka input operator.\nBelow is the code snippet:  @ApplicationAnnotation(name = \"KafkaApp\")\npublic class ExampleKafkaApplication implements StreamingApplication\n{\n  @Override\n  public void populateDAG(DAG dag, Configuration entries)\n  {\n    KafkaSinglePortInputOperator input =  dag.addOperator(\"MessageReader\", new KafkaSinglePortInputOperator());\n    ConsoleOutputOperator output = dag.addOperator(\"Output\", new ConsoleOutputOperator());\n    dag.addStream(\"MessageData\", input.outputPort, output.input);\n  }\n}  Below is the configuration for topic \u201ctest\u201d and broker \u201clocalhost:9092\u201d:  <property>\n  <name>apex.operator.MessageReader.prop.topics</name>\n  <value>test</value>\n</property>\n\n<property>\n  <name>apex.operator.KafkaInputOperator.prop.clusters</name>\n  <value>localhost:9092</value>\n</property>  Multiple topics can be specified as a comma-separated list; similarly, multiple clusters can be specified as a semicolon-separated list; for example:  <property>\n  <name>apex.operator.MessageReader.prop.topics</name>\n  <value>test1, test2</value>\n</property>\n\n<property>\n  <name>apex.operator.KafkaInputOperator.prop.clusters</nam>\n  <value>localhost:9092; localhost:9093; localhost:9094</value>\n</property>  A full example application project can be found  here .",
            "title": "Application Example"
        },
        {
            "location": "/operators/kafkaInputOperator/#security",
            "text": "Kafka from 0.9.x onwards supports  Authentication, Encryption and Authorization .  See  here  for more information.",
            "title": "Security"
        },
        {
            "location": "/operators/regexparser/",
            "text": "Regex Parser Operator\n\n\nOperator Objective\n\n\nRegexParser\n is designed to parse records based on a regex pattern and construct a concrete java class also known as \n\"POJO\"\n out of it. User needs to provide the regex pattern and schema definition to describe the data pattern. Based on regex pattern, the operator will split the data and then schema definition will be used to map the incoming record to POJO. User can also provide date format if any, in the schema. The supported constraints are listed in \nconstraints table\n.\n\n\nThe regex pattern has to match the tuple in its entirety. Valid records will be emitted as POJOs while invalid ones are emitted on the error port with an error message if the corresponding ports are connected.\n\n\nNote\n: field names of POJO must match field names in schema and in the same order as it appears in the incoming data.\n\n\nOverview\n\n\nThe operator is \nidempotent\n, \nfault-tolerant\n and \npartitionable\n.\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-contrib\n\n\nAvailable since: \n3.7.0\n\n\nOperator state: \nEvolving\n\n\nJava Package: \ncom.datatorrent.contrib.parser.RegexParser\n\n\n\n\nProperties of RegexParser\n\n\nUser needs to set the \nschema\n JSON string which describes data as well as specify the format on date fields if any.\n\nNote\n: In the examples below {ApplicationName} and {OperatorName} are placeholders for the respective names of the application and the operator.\n\n\ne.g.\n\n\n    <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.prop.schema</name>\n        <value>{\n                 \"fields\": [\n                   {\n                     \"name\": \"date\",\n                     \"type\": \"Date\",\n                     \"constraints\": {\n                       \"format\": \"yyyy:MM:dd:hh:mm:ss\"\n                     }\n                   },\n                   {\n                     \"name\": \"id\",\n                     \"type\": \"Integer\"\n                   },\n                   {\n                     \"name\": \"signInId\",\n                     \"type\": \"String\"\n                   },\n                   {\n                     \"name\": \"ipAddress\",\n                     \"type\": \"String\"\n                   },\n                   {\n                     \"name\": \"serviceId\",\n                     \"type\": \"Double\"\n                   },\n                   {\n                     \"name\": \"accountId\",\n                     \"type\": \"Long\"\n                   },\n                   {\n                     \"name\": \"platform\",\n                     \"type\": \"Boolean\"\n                   }\n                 ]\n               }\n        </value>\n    </property>\n\n\n\n\nNote that \nBoolean\n type in the above example accepts case insensitive values for either true or false.\n\n\nUser needs to set the \nsplitRegexPattern\n property whose value is the regular expression that describes the pattern of the incoming data.\nBelow is the example for setting \nsplitRegexPattern\n from \nproperties.xml\n of the application.\n\n\n    <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.prop.splitRegexPattern</name>\n        <value>.+\\[SEQ=\\w+\\]\\s*(\\d+:[\\d\\d:]+)\\s(\\d+)\\s* sign-in_id=(\\S+) .*ip_address=(\\S+).* service_id=(\\S+).*account_id=(\\S+).*platform=(\\S+)</value>\n    </property>\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nSchema\n  describing data (see example above)\n\n\nString\n\n\nYES\n\n\nN/A\n\n\n\n\n\n\nsplitRegexPattern\n\n\nregex expression that describes the pattern of incoming data\n\n\nString\n\n\nYES\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influence operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nTUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted\n\n\nClass\n\n\nYes\n\n\n\n\n\n\n\n\nThe operator takes care of converting the byte array received on the input port to a string by decoding using the JVM's default \nCharset\n. Then, splits the string using the \nsplitRegexPattern\n and populates an object using the \nschema\n. Apex platform converts this object to the object of \nTUPLE_CLASS\n attribute value while emitting.\n\n\nBelow is the example for setting \nTUPLE_CLASS\n attribute on output port from \nproperties.xml\n file of the application.\n\n\n    <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.port.out.attr.TUPLE_CLASS</name>\n        <value>com.datatorrent.tutorial.regexparser.ServerLog</value>\n    </property>\n\n\n\n\nBelow is the example for setting \nTUPLE_CLASS\n attribute on output port from \nApplication.java\n file of the application.\n\n\nRegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\ndag.setOutputPortAttribute(regexParser.out, Context.PortContext.TUPLE_CLASS, ServerLog.class);\n\n\n\n\nwhere the value (ServerLog) set above is the expected output POJO class from the operator and example is as below.\n\n\n    public class ServerLog\n    {\n      private Date date;\n      private int id;\n      private String signInId;\n      private String ipAddress;\n      private double serviceId;\n      private long accountId;\n      private boolean platform;\n      public int getId()\n      {\n        return id;\n      }\n      public void setId(int id)\n      {\n        this.id = id;\n      }\n      public Date getDate()\n      {\n        return date;\n      }\n      public void setDate(Date date)\n      {\n        this.date = date;\n      }\n      public String getSignInId()\n      {\n        return signInId;\n      }\n      public void setSignInId(String signInId)\n      {\n        this.signInId = signInId;\n      }\n      public String getIpAddress()\n      {\n        return ipAddress;\n      }\n      public void setIpAddress(String ipAddress)\n      {\n        this.ipAddress = ipAddress;\n      }\n      public double getServiceId()\n      {\n        return serviceId;\n      }\n      public void setServiceId(double serviceId)\n      {\n        this.serviceId = serviceId;\n      }\n      public long getAccountId()\n      {\n        return accountId;\n      }\n      public void setAccountId(long accountId)\n      {\n        this.accountId = accountId;\n      }\n      public boolean getPlatform()\n      {\n        return platform;\n      }\n      public void setPlatform(boolean platform)\n      {\n        this.platform = platform;\n      }\n    }\n\n\n\n\nLet us look at how the data gets populated into the POJO using the example \nschema\n, \nsplitRegexPattern\n and \nTUPLE_CLASS\n definitions given above.\n\n\nConsider sample event log as below that matches with the \nsplitRegexPattern\n.\n\n\n2015-10-01T03:14:49.000-07:00 lvn-d1-dev DevServer[9876]: INFO: [EVENT][SEQ=248717] 2015:10:01:03:14:49 101 sign-in_id=11111@psop.com ip_address=1.1.1.1  service_id=IP1234-NPB12345_00 result=RESULT_SUCCES console_id=0000000138e91b4e58236bf32besdafasdfasdfasdfsadf  account_id=11111  platform=pik\n\n\n\n\nThe below images depict the expression match on the data. The parentheses corresponding to \ncapturing groups\n are highlighted in green and each such group corresponds to one field of the POJO. There will be 7 such groups in the current example.\n\n\n\n\nThe matched data in the event log is highlighted with 7 different colors below.\n\n\n\n\nThe matched fields above will be populated onto an object based on the \nschema\n definition defined above. Object population will be based on one to one mapping from matched data to \nschema\n definition fields in the match order. Once the object is populated, it will be converted to the \nTUPLE_CLASS\n type while emitting on the output port \nout\n by the Apex platform.\n\n\nSupported DataTypes in Schema\n\n\n\n\nInteger\n\n\nLong\n\n\nDouble\n\n\nCharacter\n\n\nString\n\n\nBoolean\n\n\nDate\n\n\nFloat\n\n\n\n\nSchema Constraints\n\n\nOnly Date constraints are supported by the operator as of now.\n\n\n\n\n\n\n\n\nDataType\n\n\nConstraints\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nformat\n\n\nA simple date format as specified in the \nSimpleDateFormat\n class\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be parsed are received on this port\n\n\nbyte[]\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid tuples that are emitted as POJO\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid tuples are emitted with error message\n\n\nKeyValPair <String, String>\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nRegex Parser can be statically or dynamically partitioned.\n\n\nStatic Partitioning\n\n\nThis can be achieved in the below 2 ways.\n\n\nSpecifying the partitioner and number of partitions in the populateDAG() method.\n\n\n    RegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\n    StatelessPartitioner<RegexParser> partitioner = new StatelessPartitioner<RegexParser>(2);\n    dag.setAttribute(regexParser, Context.OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nSpecifying the partitioner in properties file.\n\n\n    <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.attr.PARTITIONER</name>\n        <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n    </property>\n\n\n\n\nAbove lines will partition RegexParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partitioning\n\n\nRegexParser can be dynamically partitioned using the out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to the \npopulateDAG\n method of application to dynamically partition RegexParser:\n\n\n    RegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\n    StatelessThroughputBasedPartitioner<RegexParser> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(regexParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(regexParser, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition RegexParser when the throughput changes.\nIf the overall throughput of regexParser goes beyond 30000 or less than 10000, the platform will repartition RegexParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nComing Soon",
            "title": "Regex Parser"
        },
        {
            "location": "/operators/regexparser/#regex-parser-operator",
            "text": "",
            "title": "Regex Parser Operator"
        },
        {
            "location": "/operators/regexparser/#operator-objective",
            "text": "RegexParser  is designed to parse records based on a regex pattern and construct a concrete java class also known as  \"POJO\"  out of it. User needs to provide the regex pattern and schema definition to describe the data pattern. Based on regex pattern, the operator will split the data and then schema definition will be used to map the incoming record to POJO. User can also provide date format if any, in the schema. The supported constraints are listed in  constraints table .  The regex pattern has to match the tuple in its entirety. Valid records will be emitted as POJOs while invalid ones are emitted on the error port with an error message if the corresponding ports are connected.  Note : field names of POJO must match field names in schema and in the same order as it appears in the incoming data.",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/regexparser/#overview",
            "text": "The operator is  idempotent ,  fault-tolerant  and  partitionable .",
            "title": "Overview"
        },
        {
            "location": "/operators/regexparser/#operator-information",
            "text": "Operator location:  malhar-contrib  Available since:  3.7.0  Operator state:  Evolving  Java Package:  com.datatorrent.contrib.parser.RegexParser",
            "title": "Operator Information"
        },
        {
            "location": "/operators/regexparser/#platform-attributes-that-influence-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which need to be emitted  Class  Yes     The operator takes care of converting the byte array received on the input port to a string by decoding using the JVM's default  Charset . Then, splits the string using the  splitRegexPattern  and populates an object using the  schema . Apex platform converts this object to the object of  TUPLE_CLASS  attribute value while emitting.  Below is the example for setting  TUPLE_CLASS  attribute on output port from  properties.xml  file of the application.      <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.port.out.attr.TUPLE_CLASS</name>\n        <value>com.datatorrent.tutorial.regexparser.ServerLog</value>\n    </property>  Below is the example for setting  TUPLE_CLASS  attribute on output port from  Application.java  file of the application.  RegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\ndag.setOutputPortAttribute(regexParser.out, Context.PortContext.TUPLE_CLASS, ServerLog.class);  where the value (ServerLog) set above is the expected output POJO class from the operator and example is as below.      public class ServerLog\n    {\n      private Date date;\n      private int id;\n      private String signInId;\n      private String ipAddress;\n      private double serviceId;\n      private long accountId;\n      private boolean platform;\n      public int getId()\n      {\n        return id;\n      }\n      public void setId(int id)\n      {\n        this.id = id;\n      }\n      public Date getDate()\n      {\n        return date;\n      }\n      public void setDate(Date date)\n      {\n        this.date = date;\n      }\n      public String getSignInId()\n      {\n        return signInId;\n      }\n      public void setSignInId(String signInId)\n      {\n        this.signInId = signInId;\n      }\n      public String getIpAddress()\n      {\n        return ipAddress;\n      }\n      public void setIpAddress(String ipAddress)\n      {\n        this.ipAddress = ipAddress;\n      }\n      public double getServiceId()\n      {\n        return serviceId;\n      }\n      public void setServiceId(double serviceId)\n      {\n        this.serviceId = serviceId;\n      }\n      public long getAccountId()\n      {\n        return accountId;\n      }\n      public void setAccountId(long accountId)\n      {\n        this.accountId = accountId;\n      }\n      public boolean getPlatform()\n      {\n        return platform;\n      }\n      public void setPlatform(boolean platform)\n      {\n        this.platform = platform;\n      }\n    }  Let us look at how the data gets populated into the POJO using the example  schema ,  splitRegexPattern  and  TUPLE_CLASS  definitions given above.  Consider sample event log as below that matches with the  splitRegexPattern .  2015-10-01T03:14:49.000-07:00 lvn-d1-dev DevServer[9876]: INFO: [EVENT][SEQ=248717] 2015:10:01:03:14:49 101 sign-in_id=11111@psop.com ip_address=1.1.1.1  service_id=IP1234-NPB12345_00 result=RESULT_SUCCES console_id=0000000138e91b4e58236bf32besdafasdfasdfasdfsadf  account_id=11111  platform=pik  The below images depict the expression match on the data. The parentheses corresponding to  capturing groups  are highlighted in green and each such group corresponds to one field of the POJO. There will be 7 such groups in the current example.   The matched data in the event log is highlighted with 7 different colors below.   The matched fields above will be populated onto an object based on the  schema  definition defined above. Object population will be based on one to one mapping from matched data to  schema  definition fields in the match order. Once the object is populated, it will be converted to the  TUPLE_CLASS  type while emitting on the output port  out  by the Apex platform.",
            "title": "Platform Attributes that influence operator behavior"
        },
        {
            "location": "/operators/regexparser/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be parsed are received on this port  byte[]  Yes    out  Valid tuples that are emitted as POJO  Object (POJO)  No    err  Invalid tuples are emitted with error message  KeyValPair <String, String>  No",
            "title": "Ports"
        },
        {
            "location": "/operators/regexparser/#partitioning",
            "text": "Regex Parser can be statically or dynamically partitioned.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/regexparser/#static-partitioning",
            "text": "This can be achieved in the below 2 ways.  Specifying the partitioner and number of partitions in the populateDAG() method.      RegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\n    StatelessPartitioner<RegexParser> partitioner = new StatelessPartitioner<RegexParser>(2);\n    dag.setAttribute(regexParser, Context.OperatorContext.PARTITIONER, partitioner);  Specifying the partitioner in properties file.      <property>\n        <name>dt.application.{ApplicationName}.operator.{OperatorName}.attr.PARTITIONER</name>\n        <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n    </property>  Above lines will partition RegexParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/regexparser/#dynamic-partitioning",
            "text": "RegexParser can be dynamically partitioned using the out-of-the-box partitioner:",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/regexparser/#throughput-based",
            "text": "Following code can be added to the  populateDAG  method of application to dynamically partition RegexParser:      RegexParser regexParser = dag.addOperator(\"regexParser\", RegexParser.class);\n    StatelessThroughputBasedPartitioner<RegexParser> partitioner = new StatelessThroughputBasedPartitioner<>();\n    partitioner.setCooldownMillis(conf.getLong(COOL_DOWN_MILLIS, 10000));\n    partitioner.setMaximumEvents(conf.getLong(MAX_THROUGHPUT, 30000));\n    partitioner.setMinimumEvents(conf.getLong(MIN_THROUGHPUT, 10000));\n    dag.setAttribute(regexParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\n    dag.setAttribute(regexParser, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition RegexParser when the throughput changes.\nIf the overall throughput of regexParser goes beyond 30000 or less than 10000, the platform will repartition RegexParser\nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/regexparser/#example",
            "text": "Coming Soon",
            "title": "Example"
        },
        {
            "location": "/operators/s3outputmodule/",
            "text": "S3OutputModule\n\n\nAbout Amazon S3\n\n\n\n\nAmazon S3 (Simple Storage Service)\n is an object storage system with a web service interface to store and retrieve any amount of data at any time from anywhere on the web, offered by Amazon Web Services.\n\n\nS3 Output Module\n\n\n\n\nPurpose of S3Output module is to upload files/directories into an Amazon S3 bucket using the multipart upload feature(see below).\n\n\nS3Output module is \nfault-tolerant\n, \nstatically/dynamically partitionable\n and has \nexactly once\n semantics.\n\n\nModule class is \nS3OutputModule\n located in the package \norg.apache.apex.malhar.lib.fs.s3\n; please refer to \ngithub URL\n.\n\n\nOverview\n\n\n\n\nFile upload to S3 can also be done using \nAbstractFileOutputOperator\n but that operator uploads large files sequentially; the current module in contrast can substantially improve the upload speed of large files by reading and uploading their constituent blocks in parallel. \n\n\nThe table below lists additional benefits of this module over \nAbstractFileOutputOperator\n.\n\n\n\n\n\n\n\n\nS3OutputModule\n\n\nAbstractFileOutputOperator\n\n\n\n\n\n\n\n\n\n\nMaximum upload file size is 5TB.\n\n\nMaximum upload file size is 5GB.\n\n\n\n\n\n\nBest fit for both large and small files.\n\n\nBest fit for small files.\n\n\n\n\n\n\nModule uses AmazonS3Client API's to upload objects into S3. Large files will upload using multipart feature and small files(single block) will upload using \nputObject(...)\n API\n\n\nOperator uses Hadoop filesystems like \nS3AFileSystem\n. Consists of couple of steps to upload object into S3: (1) Write the data into the local filesystem. (2) When the stream closes, filesystem uploads the local object into S3.\n\n\n\n\n\n\nIf a block fails to upload then you need to re-upload the data for that block only\n\n\nIf a file fails to upload then you need to re-upload the complete file.\n\n\n\n\n\n\n\n\nMultipart Upload Feature\n\n\n\n\nUploading parts of a file is done via the \nmultipart feature\n; using this feature, each part of a file can be uploaded independently.\nAfter all parts of a file are uploaded successfully, Amazon S3 combines the parts as a single object.\n\n\nPlease refer to the \nJava code\n for uploading file into Amazon S3 bucket using multipart feature.\n\n\nModule\n\n\n\n\nA \nmodule\n is a group of operators pre-wired together so they work as a single conceptual entity in an application. Typically, a module will contain a set of input ports, output ports and configuration properties. The operators internal to the module will be automatically configured based on the supplied module properties.\n\n\nOperators in S3OutputModule\n\n\n\n\nFollowing diagram illustrates the DAG in this module:\n\n\n\n\n\n\n\n\nS3InitiateFileUploadOperator\n\n\n\n\nInitiate the upload for the file using \nAmazonS3Client.initiateMultipartUpload(...)\n method only if the number of blocks for a file is greater than 1. By successfully initiating the upload, S3 returns a response of type \nInitiateMultipartUploadResult\n, which includes the \nupload ID\n, which is the unique identifier for the multipart upload. This \nupload ID\n must be included in each operation like block upload and upload completion request.\nIf the file has single block then the operator emits an empty string, this is an indication to downstream operators to not use the multi-part feature.\n\n\nThis operator emits the pair \n(filemetadata, uploadId)\n to \nS3FileMerger\n and the triple \n(filePath, metadata, uploadId)\n to \nS3BlockUploadOperator\n.\n\n\n\n\n\n\n\n\nS3BlockUploadOperator\n\n\n\n\nThis operator upload the blocks into S3 using different calls which depend on number of blocks of a file.\nIf the file has single block then upload the block using \nAmazonS3Client.putObject(...)\n call. S3 returns a response of type \nPutObjectResult\n which includes the \nETag\n.\nIf the file has more blocks then upload the block using \nAmazonS3Client.uploadPart(...)\n call. S3 returns a response of type \nUploadPartResult\n which includes the \nETag\n. This \nETag\n value must be included in the request to complete multipart upload.\n\n\nS3BlockUploadOperator\n emits the pair \n(path, ETag)\n to \ns3FileMerger\n.\n\n\n\n\n\n\n\n\nS3FileMerger\n\n\n\n\nComplete multipart upload request using \nAmazonS3Client.completeMultipartUpload(...)\n. This call must include the \nupload ID\n and a list of both part numbers and corresponding \nETag\n values. \nS3FileMerger\n sends the complete multi-part upload request to S3 once it has all the \npart ETag's\n of a file. \n\nAmazon S3\n creates an object by concatenating the parts in ascending order based on part number. After a successful upload request, the parts no longer exist and S3 response includes an \nETag\n which uniquely identifies the combined object data. \n\n\n\n\n\n\n\n\nConfiguration Parameters\n\n\n\n\n\n\n\n\naccessKey\n -   String\n\n\n\n\nMandatory Parameter    \n\n\nSpecifies the AWS access key to access Amazon S3 and has permissions to access the specified bucket.\n\n\nExample value = AKIAJVAGFANC2LSZCJ4Q\n\n\n\n\n\n\n\n\nsecretAccessKey\n   -   String\n\n\n\n\nMandatory Parameter\n\n\nSpecifies the AWS secret access key to access Amazon S3 and has permissions to access the specified bucket.\n\n\nExample value = wpVr3U82RmCKJoY007YfkaawT7CenhTcK1B8clue\n\n\n\n\n\n\n\n\nendPoint\n  -   String\n\n\n\n\nEndpoint is the URL for the entry point for a web service. Specify the valid endpoint to access S3 bucket.\n\n\nThis is an optional parameter. If the bucket is accessed only from specific end point then the user has to specify this parameter.\n\n\nPlease refer to \nendPoint\n table about the endpoints supported by S3. \n\n\nExample value = s3.amazonaws.com \n\n\n\n\n\n\n\n\nbucketName\n    -   String\n\n\n\n\nMandatory Parameter\n\n\nS3 buckets are used to store objects which consists of data and metadata that describes the data. Specify the name of the bucket.\n\n\nExample value = apex.app.test.s3\n\n\n\n\n\n\n\n\noutputDirectoryPath\n   -   String\n\n\n\n\nMandatory Parameter\n\n\nSpecifies the path of the output directory. \n\n\nExample value = dt/app/output\n\n\n\n\n\n\n\n\nmergerCount\n   -   int\n\n\n\n\nSpecify the number of instances of S3FileMerger operator.\n\n\nDefault value = 1\n\n\n\n\n\n\n\n\ntimeOutWIndowCount\n    -   int\n\n\n\n\nThis property maps to the \nOperatorContext.TIMEOUT_WINDOW_COUNT\n attribute and is a count of streaming windows. If specified, it will be set on all the operators of this module. Since these operators interact with S3, there may be additional latencies that cause the platform to kill them because they are considered stalled. Increasing this value prevents this and allows the application to proceed despite the latencies.\n\n\nDefault value = 6000\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nfilesMetadataInput\n    -   AbstractFileSplitter.FileMetadata\n\n\n\n\nInput port for files metadata.\n\n\nMandatory\n\n\n\n\n\n\n\n\nblocksMetadataInput\n   -   BlockMetadata.FileBlockMetadata\n\n\n\n\nInput port for blocks metadata.\n\n\nMandatory\n\n\n\n\n\n\n\n\nblockData\n -   AbstractBlockReader.ReaderRecord\n\n\n\n\nInput port for blocks data.\n\n\nMandatory\n\n\n\n\n\n\n\n\nApplication Example\n\n\n\n\nPlease refer to \nExample\n for S3OutputModule sample application.\n\n\nPartitioning\n\n\n\n\nPartitioning the module means that the operators in the module can be partitioned.\n\n\nStateless Partitioning\n\n\n\n\nPartitioning the operator in module can be achieved as follows:\n\n\nS3InitiateFileUploadOperator\n\n\n\n\nPartition of this operator is achieved indirectly as follows:\n\n\n<property>\n  <name>dt.operator.{ModuleName}#InitiateUpload.attr.PARTITIONER</name>\n  <value>com.datatorrent.common.partitioner.StatelessPartitioner:{N}</value>\n</property>     \n\n\n\n\nwhere {ModuleName} is the name of the S3OutputModule and\n      {N} is the number of static partitions.\nAbove lines will partition S3InitiateFileUploadOperator statically {N} times.\n\n\nS3BlockUploadOperator\n\n\n\n\nLocality of S3BlockUploadOperator with upstream operator (FSInputModule/BlockReader) must set to PARTITION_PARALLEL for performance benefits by avoiding serialization/deserialization of objects. So, partitioning of this operator depends on upstream operator which is of type FSInputModule/BlockReader.\n\n\nS3FileMerger\n\n\n\n\nBy setting the parameter \"mergerCount\", \nS3FileMerger\n be statically partitioned. This can be achieved by two ways:\n\n\n(a) Following code can be added to populateDAG(DAG dag, Configuration conf) method of application to statically partitioning \nS3FileMerger\n {N} times:\n\n\n  FSInputModule inputModule = dag.addModule(\"HDFSInputModule\", new FSInputModule());\n  S3OutputModule outputModule = dag.addModule(\"S3OutputModule\", new S3OutputModule());\n  outputModule.setMergerCount({N});\n\n\n\n\n(b) By setting the parameter in properties file as follows\n\n\n  <property>\n    <name>dt.operator.{ModuleName}.prop.mergerCount</name>\n    <value>{N}</value>\n  </property>\n\n\n\n\nwhere {ModuleName} is the name of the S3OutputModule and {N} is the number of static partitions.\nAbove lines will partition \nS3FileMerger\n statically {N} times.          \n\n\nDynamic Partitioning\n\n\n\n\nDynamic partitioning is a feature of Apex platform which changes the number of partitions of an operator at run time.\nLocality of \nS3BlockUploadOperator\n with upstream operator(FSInputModule/BlockReader) must set to PARTITION_PARALLEL for performance benefits by avoiding serialization/deserialization of objects. So, dynamic partitioning of this operator depends on upstream operator which is of type FSInputModule/BlockReader.\n\n\nFrom the example application, by setting the maxReaders and minReaders value to FSInputModule, \nS3BlockUploadOperator\n dynamically partitioned between minReaders and maxReaders. This can be achieved by two ways:\n(a) Following code can be added to \npopulateDAG(DAG dag, Configuration conf)\n method of application to dynamically partitioned \nS3BlockUploadOperator\n between {N1} and {N2} times:\n\n\nFSInputModule inputModule = dag.addModule(\"HDFSInputModule\", new FSInputModule());\ninputModule.setMinReaders({N1});\ninputModule.setMaxReaders({N2});\nS3OutputModule outputModule = dag.addModule(\"S3OutputModule\", new S3OutputModule());\n\n\n\n\n(b) By setting the parameter in properties file as follows:\n\n\n<property>\n  <name>dt.operator.HDFSInputModule.prop.minReaders</name>\n  <value>{N1}</value>\n</property>\n<property>\n  <name>dt.operator.HDFSInputModule.prop.maxReaders</name>\n  <value>{N2}</value>\n</property>         \n\n\n\n\n{N1} and {N2} represents the number of minimum and maximum partitions of BlockReader.\nAbove lines will dynamically partitioned the \nS3BlockUploadOperator\n between {N1} and {N2} times.",
            "title": "S3 Output Module"
        },
        {
            "location": "/operators/s3outputmodule/#s3outputmodule",
            "text": "",
            "title": "S3OutputModule"
        },
        {
            "location": "/operators/s3outputmodule/#about-amazon-s3",
            "text": "Amazon S3 (Simple Storage Service)  is an object storage system with a web service interface to store and retrieve any amount of data at any time from anywhere on the web, offered by Amazon Web Services.",
            "title": "About Amazon S3"
        },
        {
            "location": "/operators/s3outputmodule/#s3-output-module",
            "text": "Purpose of S3Output module is to upload files/directories into an Amazon S3 bucket using the multipart upload feature(see below).  S3Output module is  fault-tolerant ,  statically/dynamically partitionable  and has  exactly once  semantics.  Module class is  S3OutputModule  located in the package  org.apache.apex.malhar.lib.fs.s3 ; please refer to  github URL .",
            "title": "S3 Output Module"
        },
        {
            "location": "/operators/s3outputmodule/#overview",
            "text": "File upload to S3 can also be done using  AbstractFileOutputOperator  but that operator uploads large files sequentially; the current module in contrast can substantially improve the upload speed of large files by reading and uploading their constituent blocks in parallel.   The table below lists additional benefits of this module over  AbstractFileOutputOperator .     S3OutputModule  AbstractFileOutputOperator      Maximum upload file size is 5TB.  Maximum upload file size is 5GB.    Best fit for both large and small files.  Best fit for small files.    Module uses AmazonS3Client API's to upload objects into S3. Large files will upload using multipart feature and small files(single block) will upload using  putObject(...)  API  Operator uses Hadoop filesystems like  S3AFileSystem . Consists of couple of steps to upload object into S3: (1) Write the data into the local filesystem. (2) When the stream closes, filesystem uploads the local object into S3.    If a block fails to upload then you need to re-upload the data for that block only  If a file fails to upload then you need to re-upload the complete file.",
            "title": "Overview"
        },
        {
            "location": "/operators/s3outputmodule/#multipart-upload-feature",
            "text": "Uploading parts of a file is done via the  multipart feature ; using this feature, each part of a file can be uploaded independently.\nAfter all parts of a file are uploaded successfully, Amazon S3 combines the parts as a single object.  Please refer to the  Java code  for uploading file into Amazon S3 bucket using multipart feature.",
            "title": "Multipart Upload Feature"
        },
        {
            "location": "/operators/s3outputmodule/#module",
            "text": "A  module  is a group of operators pre-wired together so they work as a single conceptual entity in an application. Typically, a module will contain a set of input ports, output ports and configuration properties. The operators internal to the module will be automatically configured based on the supplied module properties.",
            "title": "Module"
        },
        {
            "location": "/operators/s3outputmodule/#operators-in-s3outputmodule",
            "text": "Following diagram illustrates the DAG in this module:     S3InitiateFileUploadOperator   Initiate the upload for the file using  AmazonS3Client.initiateMultipartUpload(...)  method only if the number of blocks for a file is greater than 1. By successfully initiating the upload, S3 returns a response of type  InitiateMultipartUploadResult , which includes the  upload ID , which is the unique identifier for the multipart upload. This  upload ID  must be included in each operation like block upload and upload completion request.\nIf the file has single block then the operator emits an empty string, this is an indication to downstream operators to not use the multi-part feature.  This operator emits the pair  (filemetadata, uploadId)  to  S3FileMerger  and the triple  (filePath, metadata, uploadId)  to  S3BlockUploadOperator .     S3BlockUploadOperator   This operator upload the blocks into S3 using different calls which depend on number of blocks of a file.\nIf the file has single block then upload the block using  AmazonS3Client.putObject(...)  call. S3 returns a response of type  PutObjectResult  which includes the  ETag .\nIf the file has more blocks then upload the block using  AmazonS3Client.uploadPart(...)  call. S3 returns a response of type  UploadPartResult  which includes the  ETag . This  ETag  value must be included in the request to complete multipart upload.  S3BlockUploadOperator  emits the pair  (path, ETag)  to  s3FileMerger .     S3FileMerger   Complete multipart upload request using  AmazonS3Client.completeMultipartUpload(...) . This call must include the  upload ID  and a list of both part numbers and corresponding  ETag  values.  S3FileMerger  sends the complete multi-part upload request to S3 once it has all the  part ETag's  of a file.  Amazon S3  creates an object by concatenating the parts in ascending order based on part number. After a successful upload request, the parts no longer exist and S3 response includes an  ETag  which uniquely identifies the combined object data.",
            "title": "Operators in S3OutputModule"
        },
        {
            "location": "/operators/s3outputmodule/#configuration-parameters",
            "text": "accessKey  -   String   Mandatory Parameter      Specifies the AWS access key to access Amazon S3 and has permissions to access the specified bucket.  Example value = AKIAJVAGFANC2LSZCJ4Q     secretAccessKey    -   String   Mandatory Parameter  Specifies the AWS secret access key to access Amazon S3 and has permissions to access the specified bucket.  Example value = wpVr3U82RmCKJoY007YfkaawT7CenhTcK1B8clue     endPoint   -   String   Endpoint is the URL for the entry point for a web service. Specify the valid endpoint to access S3 bucket.  This is an optional parameter. If the bucket is accessed only from specific end point then the user has to specify this parameter.  Please refer to  endPoint  table about the endpoints supported by S3.   Example value = s3.amazonaws.com      bucketName     -   String   Mandatory Parameter  S3 buckets are used to store objects which consists of data and metadata that describes the data. Specify the name of the bucket.  Example value = apex.app.test.s3     outputDirectoryPath    -   String   Mandatory Parameter  Specifies the path of the output directory.   Example value = dt/app/output     mergerCount    -   int   Specify the number of instances of S3FileMerger operator.  Default value = 1     timeOutWIndowCount     -   int   This property maps to the  OperatorContext.TIMEOUT_WINDOW_COUNT  attribute and is a count of streaming windows. If specified, it will be set on all the operators of this module. Since these operators interact with S3, there may be additional latencies that cause the platform to kill them because they are considered stalled. Increasing this value prevents this and allows the application to proceed despite the latencies.  Default value = 6000",
            "title": "Configuration Parameters"
        },
        {
            "location": "/operators/s3outputmodule/#ports",
            "text": "filesMetadataInput     -   AbstractFileSplitter.FileMetadata   Input port for files metadata.  Mandatory     blocksMetadataInput    -   BlockMetadata.FileBlockMetadata   Input port for blocks metadata.  Mandatory     blockData  -   AbstractBlockReader.ReaderRecord   Input port for blocks data.  Mandatory",
            "title": "Ports"
        },
        {
            "location": "/operators/s3outputmodule/#application-example",
            "text": "Please refer to  Example  for S3OutputModule sample application.",
            "title": "Application Example"
        },
        {
            "location": "/operators/s3outputmodule/#partitioning",
            "text": "Partitioning the module means that the operators in the module can be partitioned.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/s3outputmodule/#stateless-partitioning",
            "text": "Partitioning the operator in module can be achieved as follows:",
            "title": "Stateless Partitioning"
        },
        {
            "location": "/operators/s3outputmodule/#s3initiatefileuploadoperator",
            "text": "Partition of this operator is achieved indirectly as follows:  <property>\n  <name>dt.operator.{ModuleName}#InitiateUpload.attr.PARTITIONER</name>\n  <value>com.datatorrent.common.partitioner.StatelessPartitioner:{N}</value>\n</property>       where {ModuleName} is the name of the S3OutputModule and\n      {N} is the number of static partitions.\nAbove lines will partition S3InitiateFileUploadOperator statically {N} times.",
            "title": "S3InitiateFileUploadOperator"
        },
        {
            "location": "/operators/s3outputmodule/#s3blockuploadoperator",
            "text": "Locality of S3BlockUploadOperator with upstream operator (FSInputModule/BlockReader) must set to PARTITION_PARALLEL for performance benefits by avoiding serialization/deserialization of objects. So, partitioning of this operator depends on upstream operator which is of type FSInputModule/BlockReader.",
            "title": "S3BlockUploadOperator"
        },
        {
            "location": "/operators/s3outputmodule/#s3filemerger",
            "text": "By setting the parameter \"mergerCount\",  S3FileMerger  be statically partitioned. This can be achieved by two ways:  (a) Following code can be added to populateDAG(DAG dag, Configuration conf) method of application to statically partitioning  S3FileMerger  {N} times:    FSInputModule inputModule = dag.addModule(\"HDFSInputModule\", new FSInputModule());\n  S3OutputModule outputModule = dag.addModule(\"S3OutputModule\", new S3OutputModule());\n  outputModule.setMergerCount({N});  (b) By setting the parameter in properties file as follows    <property>\n    <name>dt.operator.{ModuleName}.prop.mergerCount</name>\n    <value>{N}</value>\n  </property>  where {ModuleName} is the name of the S3OutputModule and {N} is the number of static partitions.\nAbove lines will partition  S3FileMerger  statically {N} times.",
            "title": "S3FileMerger"
        },
        {
            "location": "/operators/s3outputmodule/#dynamic-partitioning",
            "text": "Dynamic partitioning is a feature of Apex platform which changes the number of partitions of an operator at run time.\nLocality of  S3BlockUploadOperator  with upstream operator(FSInputModule/BlockReader) must set to PARTITION_PARALLEL for performance benefits by avoiding serialization/deserialization of objects. So, dynamic partitioning of this operator depends on upstream operator which is of type FSInputModule/BlockReader.  From the example application, by setting the maxReaders and minReaders value to FSInputModule,  S3BlockUploadOperator  dynamically partitioned between minReaders and maxReaders. This can be achieved by two ways:\n(a) Following code can be added to  populateDAG(DAG dag, Configuration conf)  method of application to dynamically partitioned  S3BlockUploadOperator  between {N1} and {N2} times:  FSInputModule inputModule = dag.addModule(\"HDFSInputModule\", new FSInputModule());\ninputModule.setMinReaders({N1});\ninputModule.setMaxReaders({N2});\nS3OutputModule outputModule = dag.addModule(\"S3OutputModule\", new S3OutputModule());  (b) By setting the parameter in properties file as follows:  <property>\n  <name>dt.operator.HDFSInputModule.prop.minReaders</name>\n  <value>{N1}</value>\n</property>\n<property>\n  <name>dt.operator.HDFSInputModule.prop.maxReaders</name>\n  <value>{N2}</value>\n</property>           {N1} and {N2} represents the number of minimum and maximum partitions of BlockReader.\nAbove lines will dynamically partitioned the  S3BlockUploadOperator  between {N1} and {N2} times.",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/transform/",
            "text": "Transform - Operator Documentation\n\n\nAbout Transform operator\n\n\n\n\nTransform means mapping of field expression from input to output or conversion of fields from one type to another.\nThis operator is stateless. This operator receives objects on its input port; for each such input object, it creates a new output object whose fields are computed as expressions involving fields of the input object. \nThe types of the input and output objects are configurable as are the expressions used to compute the output fields. \n\n\nThe operator class is \nTransformOperator\n located in the package \ncom.datatorrent.lib.transform\n.\nPlease refer to \ngithub URL\n for \nTransformOperator\n.\n\n\nUse Case\n\n\n\n\nConsider the data that needs to be transformed as per output schema.\n\n\nConsider input objects with these fields:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\n\n\n\n\n\n\n\n\nFirstName\n\n\nString\n\n\n\n\n\n\nLastName\n\n\nString\n\n\n\n\n\n\nPhone\n\n\nString\n\n\n\n\n\n\nDateOfBirth\n\n\njava.util.Date\n\n\n\n\n\n\nAddress\n\n\nString\n\n\n\n\n\n\n\n\nand output objects with fields: \n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\n\n\n\n\n\n\n\n\nName\n\n\nString\n\n\n\n\n\n\nPhone\n\n\nString\n\n\n\n\n\n\nAge\n\n\nInteger\n\n\n\n\n\n\nAddress\n\n\nString\n\n\n\n\n\n\n\n\nSuppose \nName\n is a concatenation of \nFirstName\n and \nLastName\n and \n        \nAge\n is computed by subtracting the \nDateOfBirth\n from the current year.\n\n\nThese simple computations can be expressed as Java expressions where the input object is\nrepresented by $ and provided as configuration parameters as follows:\n\n\nName => {$.FirstName}.concat(\\\" \\\").concat({$.LastName})\nAge => (new java.util.Date()).getYear() - {$.dateOfBirth}.getYear()\n\n\n\n\nConfiguration Parameters\n\n\n\n\n\n\n\n\nexpressionMap\n -   Map\n\n\n\n\nMandatory Parameter\n\n\nSpecifies the map between the output field (key) and the expression used to compute it (value) using fields of the input Java object.\n\n\n\n\n\n\n\n\nexpressionFunctions\n -   List\n\n\n\n\nList of imported classes or methods should be made available to expression to use. It overrides the default list.\n\n\nDefault Value = {java.lang.Math.\n, org.apache.commons.lang3.StringUtils.\n, org.apache.commons.lang3.StringEscapeUtils.\n, org.apache.commons.lang3.time.DurationFormatUtils.\n, org.apache.commons.lang3.time.DateFormatUtils.*}\n\n\n\n\n\n\n\n\ncopyMatchingFields\n -   boolean\n\n\n\n\nSpecifies whether matching fields should be copied; here matching means the name and type of an input field is the same as the name and type of an output field. \n    If the matching field appears in \nexpressionMap\n then it ignores copy to output object.\n\n\nDefault Value = true.\n\n\n\n\n\n\n\n\nConfiguration Example\n\n\n\n\nConsider input object with fields:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\n\n\n\n\n\n\n\n\nFirstName\n\n\nString\n\n\n\n\n\n\nLastName\n\n\nString\n\n\n\n\n\n\nStartDate\n\n\norg.joda.time.DateTime\n\n\n\n\n\n\n\n\nand output objects with fields:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\n\n\n\n\n\n\n\n\nName\n\n\nString\n\n\n\n\n\n\nisLeapYear\n\n\nBoolean\n\n\n\n\n\n\n\n\nNote: \norg.joda.time.DateTime\n class is not present in the default list. So, we need to add this library to \nexpressionFunctions\n as below in populateDAG method:\n\n\nTransformOperator operator = dag.addOperator(\"transform\", new TransformOperator());\noperator.setExpressionFunctions(Arrays.asList(\"org.joda.time.DateTime\", org.apache.commons.lang3.StringUtils));\nMap<String,String> expressionMap = new HashMap<>();\nexpressionMap.put(isLeapYear, {$.StartDate}.year().isLeap());\nexpressionMap.put(Name, org.apache.commons.lang3.StringUtils.joinWith(\\\" \\\", {$.FirstName},{$.LastName});\noperator.setExpressionMap(expressionMap);\n\n\n\n\nAbove Properties also can be set in properties file as follows:\n\n\n<property>\n  <name>dt.operator.transform.expressionFunctions[0]</name>\n  <value>org.joda.time.DateTime</value>\n</property>     \n<property>\n  <name>dt.operator.transform.expressionFunctions[1]</name>\n  <value>org.apache.commons.lang3.StringUtils</value>\n</property>\n<property>\n  <name>dt.operator.transform.expressionMap(isLeapYear)</name>\n  <value>{$.StartDate}.year().isLeap()</value>\n</property>\n<property>\n  <name>dt.operator.transform.expressionMap(Name)</name>\n  <value>org.apache.commons.lang3.StringUtils.joinWith(\\\" \\\", {$.FirstName}, {$.LastName})</value>\n</property>\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\ninput\n -   Port for input tuples.\n\n\n\n\nMandatory input port\n\n\n\n\n\n\n\n\noutput\n    -   Port for transformed output tuples.\n\n\n\n\nMandatory output port\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\n\nInput port Attribute - input.TUPLE_CLASS\n\u00a0- Fully qualified class name and class should be Kryo serializable.\n\n\n\n\nMandatory attribute\n\n\nType of input tuple.\n\n\n\n\n\n\n\n\nOutput port Attribute - output.TUPLE_CLASS\n\u00a0- Fully qualified class name and class should be Kryo serializable.\n\n\n\n\nMandatory attribute\n\n\nType of output tuple.\n\n\n\n\n\n\n\n\nApplication Example\n\n\n\n\nPlease refer \nExample\n for transform sample application.\n\n\nPartitioning\n\n\n\n\nBeing stateless, this operator can be partitioned using any of the built-in partitioners present in the Malhar library by setting a few properties as follows:\n\n\nStateless partitioning\n\n\nStateless partitioning will ensure that TransformOperator will be partitioned right at the starting of the application and will remain partitioned throughout the lifetime of the DAG.\nTransformOperator can be stateless partitioned by adding following lines to properties.xml:\n\n\n  <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:{N}/value>\n  </property>\n\n\n\n\nwhere {OperatorName} is the name of the TransformOperator operator and\n      {N} is the number of static partitions.\nAbove lines will partition TransformOperator statically {N} times. \n\n\nDynamic Partitioning\n\n\nDynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain condition.\nTransformOperator can be dynamically partitioned using the below two partitioners:\n\n\nThroughput based\n\n\nFollowing code can be added to populateDAG(DAG dag, Configuration conf) method of application to dynamically partitioning TransformOperator:\n\n\nStatelessThroughputBasedPartitioner<TransformOperator> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(10000);\npartitioner.setMaximumEvents(30000);\npartitioner.setMinimumEvents(10000);\ndag.setAttribute(transform, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(transform, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition TransformOperator when the throughput changes.\nIf the overall throughput of TransformOperator goes beyond 30000 or less than 10000, the platform will repartition TransformOperator \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughout change is observed.\n\n\nSource code for this dynamic application can be found \nhere\n.",
            "title": "Transformer"
        },
        {
            "location": "/operators/transform/#transform-operator-documentation",
            "text": "",
            "title": "Transform - Operator Documentation"
        },
        {
            "location": "/operators/transform/#about-transform-operator",
            "text": "Transform means mapping of field expression from input to output or conversion of fields from one type to another.\nThis operator is stateless. This operator receives objects on its input port; for each such input object, it creates a new output object whose fields are computed as expressions involving fields of the input object. \nThe types of the input and output objects are configurable as are the expressions used to compute the output fields.   The operator class is  TransformOperator  located in the package  com.datatorrent.lib.transform .\nPlease refer to  github URL  for  TransformOperator .",
            "title": "About Transform operator"
        },
        {
            "location": "/operators/transform/#use-case",
            "text": "Consider the data that needs to be transformed as per output schema.  Consider input objects with these fields:     Name  Type      FirstName  String    LastName  String    Phone  String    DateOfBirth  java.util.Date    Address  String     and output objects with fields:      Name  Type      Name  String    Phone  String    Age  Integer    Address  String     Suppose  Name  is a concatenation of  FirstName  and  LastName  and \n         Age  is computed by subtracting the  DateOfBirth  from the current year.  These simple computations can be expressed as Java expressions where the input object is\nrepresented by $ and provided as configuration parameters as follows:  Name => {$.FirstName}.concat(\\\" \\\").concat({$.LastName})\nAge => (new java.util.Date()).getYear() - {$.dateOfBirth}.getYear()",
            "title": "Use Case"
        },
        {
            "location": "/operators/transform/#configuration-parameters",
            "text": "expressionMap  -   Map   Mandatory Parameter  Specifies the map between the output field (key) and the expression used to compute it (value) using fields of the input Java object.     expressionFunctions  -   List   List of imported classes or methods should be made available to expression to use. It overrides the default list.  Default Value = {java.lang.Math. , org.apache.commons.lang3.StringUtils. , org.apache.commons.lang3.StringEscapeUtils. , org.apache.commons.lang3.time.DurationFormatUtils. , org.apache.commons.lang3.time.DateFormatUtils.*}     copyMatchingFields  -   boolean   Specifies whether matching fields should be copied; here matching means the name and type of an input field is the same as the name and type of an output field. \n    If the matching field appears in  expressionMap  then it ignores copy to output object.  Default Value = true.",
            "title": "Configuration Parameters"
        },
        {
            "location": "/operators/transform/#configuration-example",
            "text": "Consider input object with fields:     Name  Type      FirstName  String    LastName  String    StartDate  org.joda.time.DateTime     and output objects with fields:     Name  Type      Name  String    isLeapYear  Boolean     Note:  org.joda.time.DateTime  class is not present in the default list. So, we need to add this library to  expressionFunctions  as below in populateDAG method:  TransformOperator operator = dag.addOperator(\"transform\", new TransformOperator());\noperator.setExpressionFunctions(Arrays.asList(\"org.joda.time.DateTime\", org.apache.commons.lang3.StringUtils));\nMap<String,String> expressionMap = new HashMap<>();\nexpressionMap.put(isLeapYear, {$.StartDate}.year().isLeap());\nexpressionMap.put(Name, org.apache.commons.lang3.StringUtils.joinWith(\\\" \\\", {$.FirstName},{$.LastName});\noperator.setExpressionMap(expressionMap);  Above Properties also can be set in properties file as follows:  <property>\n  <name>dt.operator.transform.expressionFunctions[0]</name>\n  <value>org.joda.time.DateTime</value>\n</property>     \n<property>\n  <name>dt.operator.transform.expressionFunctions[1]</name>\n  <value>org.apache.commons.lang3.StringUtils</value>\n</property>\n<property>\n  <name>dt.operator.transform.expressionMap(isLeapYear)</name>\n  <value>{$.StartDate}.year().isLeap()</value>\n</property>\n<property>\n  <name>dt.operator.transform.expressionMap(Name)</name>\n  <value>org.apache.commons.lang3.StringUtils.joinWith(\\\" \\\", {$.FirstName}, {$.LastName})</value>\n</property>",
            "title": "Configuration Example"
        },
        {
            "location": "/operators/transform/#ports",
            "text": "input  -   Port for input tuples.   Mandatory input port     output     -   Port for transformed output tuples.   Mandatory output port",
            "title": "Ports"
        },
        {
            "location": "/operators/transform/#attributes",
            "text": "Input port Attribute - input.TUPLE_CLASS \u00a0- Fully qualified class name and class should be Kryo serializable.   Mandatory attribute  Type of input tuple.     Output port Attribute - output.TUPLE_CLASS \u00a0- Fully qualified class name and class should be Kryo serializable.   Mandatory attribute  Type of output tuple.",
            "title": "Attributes"
        },
        {
            "location": "/operators/transform/#application-example",
            "text": "Please refer  Example  for transform sample application.",
            "title": "Application Example"
        },
        {
            "location": "/operators/transform/#partitioning",
            "text": "Being stateless, this operator can be partitioned using any of the built-in partitioners present in the Malhar library by setting a few properties as follows:",
            "title": "Partitioning"
        },
        {
            "location": "/operators/transform/#stateless-partitioning",
            "text": "Stateless partitioning will ensure that TransformOperator will be partitioned right at the starting of the application and will remain partitioned throughout the lifetime of the DAG.\nTransformOperator can be stateless partitioned by adding following lines to properties.xml:    <property>\n    <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n    <value>com.datatorrent.common.partitioner.StatelessPartitioner:{N}/value>\n  </property>  where {OperatorName} is the name of the TransformOperator operator and\n      {N} is the number of static partitions.\nAbove lines will partition TransformOperator statically {N} times.",
            "title": "Stateless partitioning"
        },
        {
            "location": "/operators/transform/#dynamic-partitioning",
            "text": "Dynamic partitioning is a feature of Apex platform which changes the partition of the operator based on certain condition.\nTransformOperator can be dynamically partitioned using the below two partitioners:",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/transform/#throughput-based",
            "text": "Following code can be added to populateDAG(DAG dag, Configuration conf) method of application to dynamically partitioning TransformOperator:  StatelessThroughputBasedPartitioner<TransformOperator> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(10000);\npartitioner.setMaximumEvents(30000);\npartitioner.setMinimumEvents(10000);\ndag.setAttribute(transform, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(transform, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition TransformOperator when the throughput changes.\nIf the overall throughput of TransformOperator goes beyond 30000 or less than 10000, the platform will repartition TransformOperator \nto balance throughput of a single partition to be between 10000 and 30000.\nCooldownMillis of 10000 will be used as the threshold time for which the throughout change is observed.  Source code for this dynamic application can be found  here .",
            "title": "Throughput based"
        },
        {
            "location": "/operators/windowedOperator/",
            "text": "WINDOWED OPERATOR\n\n\nIntroduction\n\n\nThe \nWindowedOperator\n is an operator in the Apex Malhar Library that supports the windowing semantics outlined by Apache Beam, including the notions of watermarks, triggers, accumulation modes, and allowed lateness. It currently supports event time windows, sliding event time windows, session windows, and global window. The reader of this document is encouraged to read this \nblog\n for the basic concepts of streaming applications, and this \nblog\n for Apache Beam's windowing semantics before using this operator.\n\n\nOur High-Level API supports event-time processing through the WindowedOperator. If you'd like to process tuples based on event time, you are encouraged to use this operator either directly with our DAG-level API, or indirectly through our High-Level API.\n\n\nIt is important to note that the word \"windows\" in this document is unrelated to \"streaming windows\" or \"application windows\" in Apex, which are based on ingression time. For more information about \"streaming windows\" and \"application windows\" in Apex, please refer to \nthis document\n.\n\n\nOperator Overview\n\n\nIn this document, we will explore the following features in the WindowedOperator.\n\n\n\n\nKeyed or Not Keyed\n\n\nWindow Option\n\n\nTimestamp Extractor\n\n\nWatermarks\n\n\nAllowed Lateness\n\n\nAccumulation\n\n\nTriggers\n\n\nAccumulation Mode\n\n\nWindow Propagation\n\n\nMerging two streams\n\n\n\n\nKeyed or Not Keyed\n\n\nOne of the first things the user of the operator has to decide is whether the operator is keyed (\nKeyedWindowedOperatorImpl\n) or not keyed (\nWindowedOperatorImpl\n). State storage, accumulation and triggers behave differently based on whether or not the operator is keyed.\n\n\nHere are examples of creating a windowed operator.\n\n\nNon-keyed:\n\n\n// Creating a non-keyed windowed operator\nWindowedOperatorImpl<InputType, AccumulationType, OutputType> windowedOperator = new WindowedOperatorImpl<>();\n\n\n\n\nKeyed:\n\n\n// Creating a keyed windowed operator\nKeyedWindowedOperatorImpl<KeyType, InputValueType, AccumulationType, OutputValueType> windowedOperator = new KeyedWindowedOperatorImpl<>();\n\n\n\n\nWe will cover the concepts of \nstate storage\n, \naccumulation\n and \ntriggers\n later in this document.\n\n\nWindow Option\n\n\nEach incoming tuple of the WindowedOperator is assigned to one or more windows. The \nWindowOption\n provides the way to specify what constitutes a window. The following \nWindowOption\ns are supported.\n\n\nGlobalWindow\n\n\nThere is only one window for the entire duration of the application. All tuples are assigned to this one window.\n\n\n// Setting the global window option\nwindowedOperator.setWindowOption(new WindowOption.GlobalWindow());\n\n\n\n\nTimeWindows\n\n\nA tuple is assigned to exactly one window based on event time, and each window has a fixed duration. One window is followed immediately by another window, and they do not overlap. As a result, one timestamp can only belong to one window.\n\n\n \n\n\n// Setting a time window option with a duration of 10 minutes\nwindowedOperator.setWindowOption(new WindowOption.TimeWindows(Duration.standardMinutes(10)));\n\n\n\n\nSlidingTimeWindows\n\n\nSimilar to \nTimeWindow\n, each window has a fixed duration. But it takes an additional duration parameter \nslideBy\n which must be smaller than the window duration and the window duration must be divisible by the \nslideBy\n duration. Each window overlaps with multiple windows. In this case, since one timestamp belongs to multiple windows, a tuple is assigned to multiple windows. The number of windows a tuple belongs to is exactly the window duration divided by the \nslideBy\n duration.\n\n\n \n\n\n// Setting a sliding time window option with a duration of 10 minutes and a slideBy duration of 2 minutes\nwindowedOperator.setWindowOption(new WindowOption.TimeWindows(Duration.standardMinutes(10)).slideBy(Duration.standardMinutes(2)));\n\n\n\n\nSessionWindows\n\n\nSessionWindow\ns have variable durations and are based on the key of the tuple. Each tuple is assigned to exactly one window. It takes a duration parameter \nminGap\n, which specifies the minimum time gap between two tuples that belong to two \ndifferent\n \nSessionWindows\n of the same key. \nminGap\n is also the duration of the \"proto-session\" window for a single timestamp, and it is the minimum duration of any session window.\n\n\n// Setting a session window option with a minimum gap of one hour\nwindowedOperator.setWindowOption(new WindowOption.SessionWindows(Duration.standardHours(1)));\n\n\n\n\nUpon arrival of a tuple, a proto-session window is created. A proto-session window for a tuple is a temporary session window with begin timestamp being the tuple timestamp and the duration being \nminGap\n.\n\n\n\n\nTo ensure that there are no two tuples of the same key in different session windows that are less than \nminGap\n apart, the \nWindowedOperator\n does the following checks:\n\n\nThe proto-session window can be fit into an existing \nSessionWindow\n of the same key without change\n\n\nThe new tuple is simply applied to the state of the existing \nSessionWindow\n.\n\n\n\n\nThe proto-session window overlaps with two existing session windows of the same key\n\n\nA new Session Window is created with the merged state of the two existing \nSessionWindow\ns, plus the new tuple. The two existing \nSessionWindow\ns will be deleted and retraction triggers for the two deleted windows will be fired. (Please see \nhere\n for details on \nTrigger\ns)\n\n\n \n\n\nThe proto-session window overlaps with one existing session window of the same key\n\n\nA new \nSessionWindow\n is created with the state of the existing \nSessionWindow\n, plus the new tuple, with a longer duration than the existing \nSessionWindow\n and possibly an earlier begin timestamp to cover the new tuple. The existing \nSessionWindow\n will be deleted and a retraction trigger for the old window will be fired.\n\n\n \n\n\nAll of the above checks return false\n\n\nThe proto-session window is in effect and the new tuple is assigned to that window.\n\n\nTimestamp Extractor\n\n\nThe \nWindowedOperator\n expects a timestamp extractor. This is for \nWindowedOperator\n to extract the timestamp from the tuple for window assignment.\n\n\n// Setting a time extractor\nwindowedOperator.setTimestampExtractor(new Function<InputTupleType, Long>()\n{\n  @Override\n  public Long apply(InputTupleType tuple)\n  {\n    return tuple.timestamp;\n  }\n});\n\n\n\n\n\nWatermarks\n\n\nWatermarks are control tuples that include a timestamp. A watermark tells \nWindowedOperator\n that all windows that lie completely before the given timestamp are considered late, and the rest of the windows are considered early. \n\n\nFixed Watermark\n\n\nIf watermarks are not available from upstream, the user of the WindowedOperator can set a fixed watermark. The fixed watermark represents the number of milliseconds before the timestamp derived from the Apex streaming window ID. Note that the Apex streaming window ID is an implicit timestamp that more or less represents the ingression time of the tuple.\n\n\n// Setting a fixed watermark that is 10 seconds behind the ingression time\nwindowedOperator.setFixedWatermark(10000);\n\n\n\n\nAllowed Lateness\n\n\nAllowed Lateness specifies the lateness horizon from the watermark. If a tuple has a timestamp that lies beyond the lateness horizon, it is dropped by the \nWindowedOperator\n. Also, if a window completely lies beyond the lateness horizon as a result of the arrival of a new watermark, the window along with its state is purged from \nWindowedOperator\n.\n\n\n \n\n\n// Setting allowed lateness to be one hour\nwindowedOperator.setAllowedLateness(Duration.standardHours(1));\n\n\n\n\nAccumulation\n\n\nThe Accumulation object tells the \nWindowedOperator\n how the operator state is accumulated. It tells the \nWindowedOperator\n what to do with its state upon arrival of an incoming tuple. This is where the business logic goes. Please refer to the interface definition \nhere\n in github. For non-keyed WindowedOperator, the state is per window. For keyed WindowedOperator, the state is per key per window.\n\n\n// Setting the accumulation to be the sum for longs, assuming both the input type and the output type are a long\nwindowedOperator.setAccumulation(new SumLong());\n\n\n\n\nThe user of this operator can use one of the existing accumulation implementations \nhere\n, or provides their own custom accumulation that reflects their business logic. \n\n\nTriggers\n\n\nTriggers are tuples emitted to downstream by the \nWindowedOperator\n. The data in the tuples are based on the state of \nWindowedOperator\n governed by the Accumulation object. There are two types of trigger: time-based triggers and count-based triggers. Time-based triggers are triggers that get fired in a regular time interval, and count-based triggers are triggers that get fired based on the number of tuples received. The user of WindowedOperator can specify different triggers for windows that are early or late based on the watermark.\n\n\nAlso, by default, a trigger is fired for a window when the window is flipped from being early to being late. This is also called an \"on-time\" trigger.\n\n\n// Creating a trigger option that tells the windowed operator to fire a trigger when the window is flipped from early to late, and fire a trigger every 10 seconds when it's early, and fire a trigger every time a tuple is received when it's late\nTriggerOption triggerOption = TriggerOption.AtWatermark().withEarlyFiringsAtEvery(Duration.standardSeconds(10)).withLateFiringsAtEvery(1);\n\n// Setting the trigger option for the windowed operator\nwindowedOperator.setTriggerOption(triggerOption);\n\n\n\n\nNote that for the non-keyed \nWindowedOperator\n, triggers are fired on a per-window basis. For the keyed \nWindowedOperator\n, triggers are fired on a per-key-per-window basis.\n\n\nThere is also an option the user can set (\nfireOnlyUpdatedPanes\n) to make the \nWindowedOperator\n not fire a trigger if the trigger value is the same as the value of the previous trigger. \n\n\n// Telling the windowed operator to fire a trigger only if the state has been changed since the last trigger\ntriggerOption.fireOnlyUpdatedPanes();\n\n\n\n\nAccumulation Mode\n\n\nAccumulation Mode tells the operator what to do with the state of the window when a trigger is fired.\nThere are three supported accumulation mode: \nACCUMULATING\n, \nDISCARDING\n, and \nACCUMULATING_AND_DISCARDING\n.\n\n\n\n\nACCUMULATING\n: The state of the window is preserved until purged\n\n\nDISCARDING\n: The state of the window is discarded after firing of a trigger\n\n\nACCUMULATING_AND_RETRACTING\n: The state of the window is preserved until purged, but if the state has changed upon a trigger compared to the previous trigger, an additional retraction trigger is fired.\n\n\n\n\n// Setting accumulation mode to be ACCUMULATING\ntriggerOption.accumulatingFiredPanes();\n\n// Setting accumulation mode to be DISCARDING\ntriggerOption.discardingFiredPanes();\n\n// Setting accumulation mode to be ACCUMULATING_AND_RETRACTING\ntriggerOption.accumulatingAndRetractingFiredPanes();\n\n\n\n\nWindow Propagation\n\n\nIt is possible to chain multiple instances of \nWindowedOperator\n and have only the most upstream instance assign the windows and have all downstream instances inherit the same windows of the triggers from the upstream instance. If WindowOption is \nnull\n (i.e. \nsetWindowOption\n is not called), the \nWindowedOperator\n assumes that the incoming tuples are \nWindowedTuple\ns that contain the information of the window assignment for each tuple.\n\n\nState Storage\n\n\nOne of the most important elements of the \nWindowedOperator\n is the state storage. Each window in the operator (or each window/key pair if the operator is keyed) has its own state and how the state is stored and checkpointed is likely to be the most important factor for performance.\n\n\nThe \nWindowedOperator\n currently supports two different state storage mechanisms.\n\n\nIn-Memory Windowed Storage\n stores the operator state only in memory and the entire state is copied to DFS at checkpoint. This storage is useful only if the state is expected to be small and the cardinality of valid windows and keys is small.\n\n\n// Setting the data storage for windowed operator to be an in-memory storage\nwindowedOperator.setDataStorage(new InMemoryWindowedStorage<AccumulationType>());\n\n\n\n\nSpillable Windowed Storage\n stores the operator state in DFS with a cache in memory. This storage mechanism handles large states and incremental checkpointing. \n\n\n// Setting the data storage for windowed operator to be a spillable storage\nSpillableWindowedPlainStorage<MutableLong> dataStorage = new SpillableWindowedPlainStorage<>();\n// setup of the spillable storage omitted here for brevity\nwindowedOperator.setDataStorage(dataStorage);\n\n\n\n\nMerging two streams\n\n\nThe \nWindowedMergeOperator\n is a \nWindowedOperator\n that takes two incoming data streams. It takes a \nMergeAccumulation\n instead of a regular Accumulation. The user of this operator can implement their custom merge or join accumulation based on their business logic. Examples of this type of accumulation are \nInnerJoin\n and \nCogroup\n.\n\n\nThe \nWindowedMergeOperator\n has its own watermark. Its watermark timestamp is the earlier watermark timestamp between the two input streams. When that value changes upon the arrival of incoming watermarks, a watermark control tuple with that timestamp value will be fired to downstream.\n\n\nUsage Examples\n\n\nFor an example usage of the \nWindowedOperator\n via the High level API, click \nhere\n.\n\n\nFor an example usage of the \nWindowedOperator\n via the DAG level API, click \nhere\n.\n\n\nAdvanced Topics\n\n\nIdempotency Considerations\n\n\nFor the \nWindowedOperator\n to be \nidempotent\n, both data tuples and watermarks must be emitted deterministically. i.e. When replaying from a checkpoint, the same tuples and watermarks must be emitted in the same Apex streaming window as before the failure happens.\n\n\nIn order to achieve this, the \nWindowedOperator\n has the following behavior:\n\n\n\n\n\n\nThe time-based triggers are fired based on the implicit timestamp from the Apex streaming windows, not based on the wall clock time. And the time-based triggers are fired only at the Apex streaming window boundary. This means that the Apex streaming window width should be smaller than or equal to the interval duration of any time-based trigger, and ideally the interval duration of the time-based trigger can be expressed as an integer multiple of the Apex streaming window width.\n\n\n\n\n\n\nThe processing of the incoming watermarks is only done at the Apex streaming window boundary. This includes the change of status from early to late for windows that lie beyond the watermark timestamp, the purging of windows from the state for windows that lie completely beyond the lateness horizon, and the propagation of watermark tuples to downstream.",
            "title": "Windowed Operator"
        },
        {
            "location": "/operators/windowedOperator/#windowed-operator",
            "text": "",
            "title": "WINDOWED OPERATOR"
        },
        {
            "location": "/operators/windowedOperator/#introduction",
            "text": "The  WindowedOperator  is an operator in the Apex Malhar Library that supports the windowing semantics outlined by Apache Beam, including the notions of watermarks, triggers, accumulation modes, and allowed lateness. It currently supports event time windows, sliding event time windows, session windows, and global window. The reader of this document is encouraged to read this  blog  for the basic concepts of streaming applications, and this  blog  for Apache Beam's windowing semantics before using this operator.  Our High-Level API supports event-time processing through the WindowedOperator. If you'd like to process tuples based on event time, you are encouraged to use this operator either directly with our DAG-level API, or indirectly through our High-Level API.  It is important to note that the word \"windows\" in this document is unrelated to \"streaming windows\" or \"application windows\" in Apex, which are based on ingression time. For more information about \"streaming windows\" and \"application windows\" in Apex, please refer to  this document .",
            "title": "Introduction"
        },
        {
            "location": "/operators/windowedOperator/#operator-overview",
            "text": "In this document, we will explore the following features in the WindowedOperator.   Keyed or Not Keyed  Window Option  Timestamp Extractor  Watermarks  Allowed Lateness  Accumulation  Triggers  Accumulation Mode  Window Propagation  Merging two streams",
            "title": "Operator Overview"
        },
        {
            "location": "/operators/windowedOperator/#keyed-or-not-keyed",
            "text": "One of the first things the user of the operator has to decide is whether the operator is keyed ( KeyedWindowedOperatorImpl ) or not keyed ( WindowedOperatorImpl ). State storage, accumulation and triggers behave differently based on whether or not the operator is keyed.  Here are examples of creating a windowed operator.  Non-keyed:  // Creating a non-keyed windowed operator\nWindowedOperatorImpl<InputType, AccumulationType, OutputType> windowedOperator = new WindowedOperatorImpl<>();  Keyed:  // Creating a keyed windowed operator\nKeyedWindowedOperatorImpl<KeyType, InputValueType, AccumulationType, OutputValueType> windowedOperator = new KeyedWindowedOperatorImpl<>();  We will cover the concepts of  state storage ,  accumulation  and  triggers  later in this document.",
            "title": "Keyed or Not Keyed"
        },
        {
            "location": "/operators/windowedOperator/#window-option",
            "text": "Each incoming tuple of the WindowedOperator is assigned to one or more windows. The  WindowOption  provides the way to specify what constitutes a window. The following  WindowOption s are supported.",
            "title": "Window Option"
        },
        {
            "location": "/operators/windowedOperator/#globalwindow",
            "text": "There is only one window for the entire duration of the application. All tuples are assigned to this one window.  // Setting the global window option\nwindowedOperator.setWindowOption(new WindowOption.GlobalWindow());",
            "title": "GlobalWindow"
        },
        {
            "location": "/operators/windowedOperator/#timewindows",
            "text": "A tuple is assigned to exactly one window based on event time, and each window has a fixed duration. One window is followed immediately by another window, and they do not overlap. As a result, one timestamp can only belong to one window.     // Setting a time window option with a duration of 10 minutes\nwindowedOperator.setWindowOption(new WindowOption.TimeWindows(Duration.standardMinutes(10)));",
            "title": "TimeWindows"
        },
        {
            "location": "/operators/windowedOperator/#slidingtimewindows",
            "text": "Similar to  TimeWindow , each window has a fixed duration. But it takes an additional duration parameter  slideBy  which must be smaller than the window duration and the window duration must be divisible by the  slideBy  duration. Each window overlaps with multiple windows. In this case, since one timestamp belongs to multiple windows, a tuple is assigned to multiple windows. The number of windows a tuple belongs to is exactly the window duration divided by the  slideBy  duration.     // Setting a sliding time window option with a duration of 10 minutes and a slideBy duration of 2 minutes\nwindowedOperator.setWindowOption(new WindowOption.TimeWindows(Duration.standardMinutes(10)).slideBy(Duration.standardMinutes(2)));",
            "title": "SlidingTimeWindows"
        },
        {
            "location": "/operators/windowedOperator/#sessionwindows",
            "text": "SessionWindow s have variable durations and are based on the key of the tuple. Each tuple is assigned to exactly one window. It takes a duration parameter  minGap , which specifies the minimum time gap between two tuples that belong to two  different   SessionWindows  of the same key.  minGap  is also the duration of the \"proto-session\" window for a single timestamp, and it is the minimum duration of any session window.  // Setting a session window option with a minimum gap of one hour\nwindowedOperator.setWindowOption(new WindowOption.SessionWindows(Duration.standardHours(1)));  Upon arrival of a tuple, a proto-session window is created. A proto-session window for a tuple is a temporary session window with begin timestamp being the tuple timestamp and the duration being  minGap .   To ensure that there are no two tuples of the same key in different session windows that are less than  minGap  apart, the  WindowedOperator  does the following checks:",
            "title": "SessionWindows"
        },
        {
            "location": "/operators/windowedOperator/#the-proto-session-window-can-be-fit-into-an-existing-sessionwindow-of-the-same-key-without-change",
            "text": "The new tuple is simply applied to the state of the existing  SessionWindow .",
            "title": "The proto-session window can be fit into an existing SessionWindow of the same key without change"
        },
        {
            "location": "/operators/windowedOperator/#the-proto-session-window-overlaps-with-two-existing-session-windows-of-the-same-key",
            "text": "A new Session Window is created with the merged state of the two existing  SessionWindow s, plus the new tuple. The two existing  SessionWindow s will be deleted and retraction triggers for the two deleted windows will be fired. (Please see  here  for details on  Trigger s)",
            "title": "The proto-session window overlaps with two existing session windows of the same key"
        },
        {
            "location": "/operators/windowedOperator/#the-proto-session-window-overlaps-with-one-existing-session-window-of-the-same-key",
            "text": "A new  SessionWindow  is created with the state of the existing  SessionWindow , plus the new tuple, with a longer duration than the existing  SessionWindow  and possibly an earlier begin timestamp to cover the new tuple. The existing  SessionWindow  will be deleted and a retraction trigger for the old window will be fired.",
            "title": "The proto-session window overlaps with one existing session window of the same key"
        },
        {
            "location": "/operators/windowedOperator/#all-of-the-above-checks-return-false",
            "text": "The proto-session window is in effect and the new tuple is assigned to that window.",
            "title": "All of the above checks return false"
        },
        {
            "location": "/operators/windowedOperator/#timestamp-extractor",
            "text": "The  WindowedOperator  expects a timestamp extractor. This is for  WindowedOperator  to extract the timestamp from the tuple for window assignment.  // Setting a time extractor\nwindowedOperator.setTimestampExtractor(new Function<InputTupleType, Long>()\n{\n  @Override\n  public Long apply(InputTupleType tuple)\n  {\n    return tuple.timestamp;\n  }\n});",
            "title": "Timestamp Extractor"
        },
        {
            "location": "/operators/windowedOperator/#watermarks",
            "text": "Watermarks are control tuples that include a timestamp. A watermark tells  WindowedOperator  that all windows that lie completely before the given timestamp are considered late, and the rest of the windows are considered early.",
            "title": "Watermarks"
        },
        {
            "location": "/operators/windowedOperator/#fixed-watermark",
            "text": "If watermarks are not available from upstream, the user of the WindowedOperator can set a fixed watermark. The fixed watermark represents the number of milliseconds before the timestamp derived from the Apex streaming window ID. Note that the Apex streaming window ID is an implicit timestamp that more or less represents the ingression time of the tuple.  // Setting a fixed watermark that is 10 seconds behind the ingression time\nwindowedOperator.setFixedWatermark(10000);",
            "title": "Fixed Watermark"
        },
        {
            "location": "/operators/windowedOperator/#allowed-lateness",
            "text": "Allowed Lateness specifies the lateness horizon from the watermark. If a tuple has a timestamp that lies beyond the lateness horizon, it is dropped by the  WindowedOperator . Also, if a window completely lies beyond the lateness horizon as a result of the arrival of a new watermark, the window along with its state is purged from  WindowedOperator .     // Setting allowed lateness to be one hour\nwindowedOperator.setAllowedLateness(Duration.standardHours(1));",
            "title": "Allowed Lateness"
        },
        {
            "location": "/operators/windowedOperator/#accumulation",
            "text": "The Accumulation object tells the  WindowedOperator  how the operator state is accumulated. It tells the  WindowedOperator  what to do with its state upon arrival of an incoming tuple. This is where the business logic goes. Please refer to the interface definition  here  in github. For non-keyed WindowedOperator, the state is per window. For keyed WindowedOperator, the state is per key per window.  // Setting the accumulation to be the sum for longs, assuming both the input type and the output type are a long\nwindowedOperator.setAccumulation(new SumLong());  The user of this operator can use one of the existing accumulation implementations  here , or provides their own custom accumulation that reflects their business logic.",
            "title": "Accumulation"
        },
        {
            "location": "/operators/windowedOperator/#triggers",
            "text": "Triggers are tuples emitted to downstream by the  WindowedOperator . The data in the tuples are based on the state of  WindowedOperator  governed by the Accumulation object. There are two types of trigger: time-based triggers and count-based triggers. Time-based triggers are triggers that get fired in a regular time interval, and count-based triggers are triggers that get fired based on the number of tuples received. The user of WindowedOperator can specify different triggers for windows that are early or late based on the watermark.  Also, by default, a trigger is fired for a window when the window is flipped from being early to being late. This is also called an \"on-time\" trigger.  // Creating a trigger option that tells the windowed operator to fire a trigger when the window is flipped from early to late, and fire a trigger every 10 seconds when it's early, and fire a trigger every time a tuple is received when it's late\nTriggerOption triggerOption = TriggerOption.AtWatermark().withEarlyFiringsAtEvery(Duration.standardSeconds(10)).withLateFiringsAtEvery(1);\n\n// Setting the trigger option for the windowed operator\nwindowedOperator.setTriggerOption(triggerOption);  Note that for the non-keyed  WindowedOperator , triggers are fired on a per-window basis. For the keyed  WindowedOperator , triggers are fired on a per-key-per-window basis.  There is also an option the user can set ( fireOnlyUpdatedPanes ) to make the  WindowedOperator  not fire a trigger if the trigger value is the same as the value of the previous trigger.   // Telling the windowed operator to fire a trigger only if the state has been changed since the last trigger\ntriggerOption.fireOnlyUpdatedPanes();",
            "title": "Triggers"
        },
        {
            "location": "/operators/windowedOperator/#accumulation-mode",
            "text": "Accumulation Mode tells the operator what to do with the state of the window when a trigger is fired.\nThere are three supported accumulation mode:  ACCUMULATING ,  DISCARDING , and  ACCUMULATING_AND_DISCARDING .   ACCUMULATING : The state of the window is preserved until purged  DISCARDING : The state of the window is discarded after firing of a trigger  ACCUMULATING_AND_RETRACTING : The state of the window is preserved until purged, but if the state has changed upon a trigger compared to the previous trigger, an additional retraction trigger is fired.   // Setting accumulation mode to be ACCUMULATING\ntriggerOption.accumulatingFiredPanes();\n\n// Setting accumulation mode to be DISCARDING\ntriggerOption.discardingFiredPanes();\n\n// Setting accumulation mode to be ACCUMULATING_AND_RETRACTING\ntriggerOption.accumulatingAndRetractingFiredPanes();",
            "title": "Accumulation Mode"
        },
        {
            "location": "/operators/windowedOperator/#window-propagation",
            "text": "It is possible to chain multiple instances of  WindowedOperator  and have only the most upstream instance assign the windows and have all downstream instances inherit the same windows of the triggers from the upstream instance. If WindowOption is  null  (i.e.  setWindowOption  is not called), the  WindowedOperator  assumes that the incoming tuples are  WindowedTuple s that contain the information of the window assignment for each tuple.",
            "title": "Window Propagation"
        },
        {
            "location": "/operators/windowedOperator/#state-storage",
            "text": "One of the most important elements of the  WindowedOperator  is the state storage. Each window in the operator (or each window/key pair if the operator is keyed) has its own state and how the state is stored and checkpointed is likely to be the most important factor for performance.  The  WindowedOperator  currently supports two different state storage mechanisms.  In-Memory Windowed Storage  stores the operator state only in memory and the entire state is copied to DFS at checkpoint. This storage is useful only if the state is expected to be small and the cardinality of valid windows and keys is small.  // Setting the data storage for windowed operator to be an in-memory storage\nwindowedOperator.setDataStorage(new InMemoryWindowedStorage<AccumulationType>());  Spillable Windowed Storage  stores the operator state in DFS with a cache in memory. This storage mechanism handles large states and incremental checkpointing.   // Setting the data storage for windowed operator to be a spillable storage\nSpillableWindowedPlainStorage<MutableLong> dataStorage = new SpillableWindowedPlainStorage<>();\n// setup of the spillable storage omitted here for brevity\nwindowedOperator.setDataStorage(dataStorage);",
            "title": "State Storage"
        },
        {
            "location": "/operators/windowedOperator/#merging-two-streams",
            "text": "The  WindowedMergeOperator  is a  WindowedOperator  that takes two incoming data streams. It takes a  MergeAccumulation  instead of a regular Accumulation. The user of this operator can implement their custom merge or join accumulation based on their business logic. Examples of this type of accumulation are  InnerJoin  and  Cogroup .  The  WindowedMergeOperator  has its own watermark. Its watermark timestamp is the earlier watermark timestamp between the two input streams. When that value changes upon the arrival of incoming watermarks, a watermark control tuple with that timestamp value will be fired to downstream.",
            "title": "Merging two streams"
        },
        {
            "location": "/operators/windowedOperator/#usage-examples",
            "text": "For an example usage of the  WindowedOperator  via the High level API, click  here .  For an example usage of the  WindowedOperator  via the DAG level API, click  here .",
            "title": "Usage Examples"
        },
        {
            "location": "/operators/windowedOperator/#advanced-topics",
            "text": "",
            "title": "Advanced Topics"
        },
        {
            "location": "/operators/windowedOperator/#idempotency-considerations",
            "text": "For the  WindowedOperator  to be  idempotent , both data tuples and watermarks must be emitted deterministically. i.e. When replaying from a checkpoint, the same tuples and watermarks must be emitted in the same Apex streaming window as before the failure happens.  In order to achieve this, the  WindowedOperator  has the following behavior:    The time-based triggers are fired based on the implicit timestamp from the Apex streaming windows, not based on the wall clock time. And the time-based triggers are fired only at the Apex streaming window boundary. This means that the Apex streaming window width should be smaller than or equal to the interval duration of any time-based trigger, and ideally the interval duration of the time-based trigger can be expressed as an integer multiple of the Apex streaming window width.    The processing of the incoming watermarks is only done at the Apex streaming window boundary. This includes the change of status from early to late for windows that lie beyond the watermark timestamp, the purging of windows from the state for windows that lie completely beyond the lateness horizon, and the propagation of watermark tuples to downstream.",
            "title": "Idempotency Considerations"
        },
        {
            "location": "/operators/xmlParserOperator/",
            "text": "Xml Parser\n\n\nOperator Objective\n\n\nThe XmlParser operator parses XML records and constructs POJOs (\"Plain Old Java Objects\") from them. The operator also emits each record as a DOM Document if the relevant output port is connected. User can also provide a XSD (XML Schema Definition) to validate incoming XML records. Valid records will be emitted as POJOs / DOM Document while invalid ones are emitted on error port with an error message if the error port is connected.\n\n\nXmlParser is \nidempotent\n, \nfault-tolerant\n and \nstatically/dynamically partitionable\n.\n\n\nClass Diagram\n\n\n\n\nOperator Information\n\n\n\n\nOperator location: \nmalhar-library\n\n\nAvailable since: \n3.2.0\n\n\nOperator state: \nEvolving\n\n\nJava Package: \ncom.datatorrent.lib.parser.XmlParser\n\n\n\n\nProperties, Attributes and Ports\n\n\nProperties of Xml Parser\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nschemaXSDFile\n\n\n[XSD] describing XML data. Incoming records can be validated using the schemaXSDFile. If the data is not as per the requirements specified in schemaXSDFile, they are emitted on the error port. This is an optional property. If the XSD is not provided, incoming tuples are simply converted to POJOs or DOM Documents without any validations\n\n\nString\n\n\nNo\n\n\nN/A\n\n\n\n\n\n\n\n\nPlatform Attributes that influence operator behavior\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nout.TUPLE_CLASS\n\n\nTUPLE_CLASS attribute on output port which tells operator the class of POJO which needs to be emitted. The name of the field members of the class must match with the names in incoming POJO. The operator ignores unknown properties i.e. fields present in POJO but not in TUPLE_CLASS or vice versa.\n\n\nClass or FQCN\n\n\nYes\n\n\n\n\n\n\n\n\nPorts\n\n\n\n\n\n\n\n\nPort\n\n\nDescription\n\n\nType\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nin\n\n\nTuples that needs to be parsed are received on this port\n\n\nbyte[]\n\n\nYes\n\n\n\n\n\n\nout\n\n\nValid Tuples that are emitted as pojo. Tuples are converted to POJO only if the port is connected.\n\n\nObject (POJO)\n\n\nNo\n\n\n\n\n\n\nparsedOutput\n\n\nValid Tuples that are emitted as DOM Document. Tuples are converted to DOM Document only if the port is connected.\n\n\nDOM Document\n\n\nNo\n\n\n\n\n\n\nerr\n\n\nInvalid Tuples are emitted with error message. Invalid tuples are discarded if the port is not connected.\n\n\nKeyValPair <String, String>\n\n\nNo\n\n\n\n\n\n\n\n\nPartitioning\n\n\nXML Parser is both statically and dynamically partitionable.\n\n\nStatic Partitioning\n\n\nThis can be achieved in 2 ways\n\n\n\n\nSpecifying the partitioner and number of partitions in the 'populateDAG()' method.\n\n\n\n\nXmlParser xmlParser = dag.addOperator(\"xmlParser\", XmlParser.class);\nStatelessPartitioner<XmlParser> partitioner1 = new StatelessPartitioner<XmlParser>(2);\ndag.setAttribute(xmlParser, Context.OperatorContext.PARTITIONER, partitioner1 );\n\n\n\n\n\n\nSpecifying the partitioner and number of partitions in properties file.\n\n\n\n\n <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>\n\n\n\n\nwhere {OperatorName} is the name of the XmlParser operator.\n Above lines will partition XmlParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.\n\n\nDynamic Partitioning\n\n\nXmlParser can be dynamically partitioned using an out-of-the-box partitioner:\n\n\nThroughput based\n\n\nFollowing code can be added to 'populateDAG' method of application to dynamically partition XmlParser:\n\n\nXmlParser xmlParser = dag.addOperator(\"xmlParser\", XmlParser.class);\nStatelessThroughputBasedPartitioner<XmlParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(\"dt.cooldown\", 10000));\npartitioner.setMaximumEvents(conf.getLong(\"dt.maxThroughput\", 30000));\npartitioner.setMinimumEvents(conf.getLong(\"dt.minThroughput\", 10000));\ndag.setAttribute(xmlParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(xmlParser, OperatorContext.PARTITIONER, partitioner);\n\n\n\n\nAbove code will dynamically partition XmlParser when the throughput changes.\nIf the overall throughput of XmlParser goes beyond 30000 or less than 10000, the platform will repartition XmlParser\nto balance throughput of a single partition to be between 10000 and 30000.\n'dt.cooldown' of 10000 will be used as the threshold time for which the throughput change is observed.\n\n\nExample\n\n\nExample for Xml Parser can be found at: \nhttps://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "XML Parser"
        },
        {
            "location": "/operators/xmlParserOperator/#xml-parser",
            "text": "",
            "title": "Xml Parser"
        },
        {
            "location": "/operators/xmlParserOperator/#operator-objective",
            "text": "The XmlParser operator parses XML records and constructs POJOs (\"Plain Old Java Objects\") from them. The operator also emits each record as a DOM Document if the relevant output port is connected. User can also provide a XSD (XML Schema Definition) to validate incoming XML records. Valid records will be emitted as POJOs / DOM Document while invalid ones are emitted on error port with an error message if the error port is connected.  XmlParser is  idempotent ,  fault-tolerant  and  statically/dynamically partitionable .",
            "title": "Operator Objective"
        },
        {
            "location": "/operators/xmlParserOperator/#class-diagram",
            "text": "",
            "title": "Class Diagram"
        },
        {
            "location": "/operators/xmlParserOperator/#operator-information",
            "text": "Operator location:  malhar-library  Available since:  3.2.0  Operator state:  Evolving  Java Package:  com.datatorrent.lib.parser.XmlParser",
            "title": "Operator Information"
        },
        {
            "location": "/operators/xmlParserOperator/#properties-attributes-and-ports",
            "text": "",
            "title": "Properties, Attributes and Ports"
        },
        {
            "location": "/operators/xmlParserOperator/#platform-attributes-that-influence-operator-behavior",
            "text": "Attribute  Description  Type  Mandatory      out.TUPLE_CLASS  TUPLE_CLASS attribute on output port which tells operator the class of POJO which needs to be emitted. The name of the field members of the class must match with the names in incoming POJO. The operator ignores unknown properties i.e. fields present in POJO but not in TUPLE_CLASS or vice versa.  Class or FQCN  Yes",
            "title": "Platform Attributes that influence operator behavior"
        },
        {
            "location": "/operators/xmlParserOperator/#ports",
            "text": "Port  Description  Type  Mandatory      in  Tuples that needs to be parsed are received on this port  byte[]  Yes    out  Valid Tuples that are emitted as pojo. Tuples are converted to POJO only if the port is connected.  Object (POJO)  No    parsedOutput  Valid Tuples that are emitted as DOM Document. Tuples are converted to DOM Document only if the port is connected.  DOM Document  No    err  Invalid Tuples are emitted with error message. Invalid tuples are discarded if the port is not connected.  KeyValPair <String, String>  No",
            "title": "Ports"
        },
        {
            "location": "/operators/xmlParserOperator/#partitioning",
            "text": "XML Parser is both statically and dynamically partitionable.",
            "title": "Partitioning"
        },
        {
            "location": "/operators/xmlParserOperator/#static-partitioning",
            "text": "This can be achieved in 2 ways   Specifying the partitioner and number of partitions in the 'populateDAG()' method.   XmlParser xmlParser = dag.addOperator(\"xmlParser\", XmlParser.class);\nStatelessPartitioner<XmlParser> partitioner1 = new StatelessPartitioner<XmlParser>(2);\ndag.setAttribute(xmlParser, Context.OperatorContext.PARTITIONER, partitioner1 );   Specifying the partitioner and number of partitions in properties file.    <property>\n   <name>dt.operator.{OperatorName}.attr.PARTITIONER</name>\n   <value>com.datatorrent.common.partitioner.StatelessPartitioner:2</value>\n </property>  where {OperatorName} is the name of the XmlParser operator.\n Above lines will partition XmlParser statically 2 times. Above value can be changed accordingly to change the number of static partitions.",
            "title": "Static Partitioning"
        },
        {
            "location": "/operators/xmlParserOperator/#dynamic-partitioning",
            "text": "XmlParser can be dynamically partitioned using an out-of-the-box partitioner:",
            "title": "Dynamic Partitioning"
        },
        {
            "location": "/operators/xmlParserOperator/#throughput-based",
            "text": "Following code can be added to 'populateDAG' method of application to dynamically partition XmlParser:  XmlParser xmlParser = dag.addOperator(\"xmlParser\", XmlParser.class);\nStatelessThroughputBasedPartitioner<XmlParser> partitioner = new StatelessThroughputBasedPartitioner<>();\npartitioner.setCooldownMillis(conf.getLong(\"dt.cooldown\", 10000));\npartitioner.setMaximumEvents(conf.getLong(\"dt.maxThroughput\", 30000));\npartitioner.setMinimumEvents(conf.getLong(\"dt.minThroughput\", 10000));\ndag.setAttribute(xmlParser, OperatorContext.STATS_LISTENERS, Arrays.asList(new StatsListener[]{partitioner}));\ndag.setAttribute(xmlParser, OperatorContext.PARTITIONER, partitioner);  Above code will dynamically partition XmlParser when the throughput changes.\nIf the overall throughput of XmlParser goes beyond 30000 or less than 10000, the platform will repartition XmlParser\nto balance throughput of a single partition to be between 10000 and 30000.\n'dt.cooldown' of 10000 will be used as the threshold time for which the throughput change is observed.",
            "title": "Throughput based"
        },
        {
            "location": "/operators/xmlParserOperator/#example",
            "text": "Example for Xml Parser can be found at:  https://github.com/DataTorrent/examples/tree/master/tutorials/parser",
            "title": "Example"
        }
    ]
}